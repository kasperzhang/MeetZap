{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { eventTypes, timeTypes } from \"@/constants\";\nimport { get } from \"./fetch_utils\";\nimport { isBetween } from \"./general_utils\";\n/* \n  Date utils \n*/\n\n/** Returns a string representation of the given date, i.e. May 14th is \"5/14\" */\nexport const getDateString = (date, utc = false) => {\n  date = new Date(date);\n  if (utc) {\n    return `${date.getUTCMonth() + 1}/${date.getUTCDate()}`;\n  }\n  return `${date.getMonth() + 1}/${date.getDate()}`;\n};\n\n/** Returns a string in the format \"Mon, 9/23, 10 AM - 12 PM PDT\" given a start date and end date */\nexport const getStartEndDateString = (startDate, endDate) => {\n  const startDay = startDate.toLocaleString(\"en-US\", {\n    weekday: \"short\"\n  });\n  const startMonth = startDate.toLocaleString(\"en-US\", {\n    month: \"short\"\n  });\n  const startDayOfMonth = startDate.toLocaleString(\"en-US\", {\n    day: \"numeric\"\n  });\n  const startTime = startDate.toLocaleString(\"en-US\", {\n    hour: \"numeric\",\n    minute: \"numeric\"\n  });\n  const endTime = endDate.toLocaleString(\"en-US\", {\n    hour: \"numeric\",\n    minute: \"numeric\",\n    timeZoneName: \"short\"\n  });\n  return `${startDay}, ${startMonth} ${startDayOfMonth}, ${startTime} - ${endTime}`;\n};\n\n/** Returns an ISO formatted date string */\nexport const getISODateString = (date, utc = false) => {\n  date = new Date(date);\n  if (utc) {\n    return date.toISOString().substring(0, 10);\n  }\n  const year = date.getFullYear();\n  const month = String(date.getMonth() + 1).padStart(2, \"0\");\n  const day = String(date.getDate()).padStart(2, \"0\");\n  return `${year}-${month}-${day}`;\n};\n\n/** Returns a string representing date range from date1 to date2, i.e. \"5/14 - 5/27\" */\nexport const getDateRangeString = (date1, date2, utc = false) => {\n  date1 = new Date(date1);\n  date2 = new Date(date2);\n\n  // Correct date2 if time is 12am (because ending at 12am doesn't begin the next day)\n  if (utc && date2.getUTCHours() == 0 || !utc && date2.getHours() == 0) {\n    date2 = getDateDayOffset(date2, -1);\n  }\n  return getDateString(date1, utc) + \" - \" + getDateString(date2, utc);\n};\n\n/** Returns a string representing the date range for the provided event */\nexport const getDateRangeStringForEvent = event => {\n  let timezone = localStorage[\"timezone\"];\n  if (timezone) timezone = JSON.parse(timezone);\n  if (event.type === eventTypes.DOW || event.type === eventTypes.GROUP) {\n    let s = \"\";\n    const dayAbbreviations = [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"];\n    for (let date of event.dates) {\n      date = getDateWithTimezone(date);\n      const abbr = dayAbbreviations[date.getUTCDay()];\n      s += abbr + \", \";\n    }\n    s = s.substring(0, s.length - 2);\n    return s;\n  } else if (event.type === eventTypes.SPECIFIC_DATES) {\n    const startDate = getDateWithTimezone(new Date(event.dates[0]));\n    const endDate = getDateWithTimezone(new Date(event.dates[event.dates.length - 1]));\n    return getDateRangeString(startDate, endDate, true);\n  }\n  return \"\";\n};\n\n/** Returns a a new date, offset by the timezone in local storage if it exists, offset by local timezone if not */\nexport const getDateWithTimezone = date => {\n  date = new Date(date);\n  let timezone = localStorage[\"timezone\"];\n  if (timezone) timezone = JSON.parse(timezone);\n  if (timezone) {\n    date.setTime(date.getTime() + timezone.offset * 60 * 1000);\n  } else {\n    date.setTime(date.getTime() - new Date().getTimezoneOffset() * 60 * 1000);\n  }\n  return date;\n};\n\n/** Returns a new date object with the given date (e.g. 5/2/2022) and the specified time (e.g. \"11:30\") */\nexport const getDateWithTime = (date, timeString) => {\n  date = new Date(date);\n  const {\n    hours,\n    minutes\n  } = splitTime(timeString);\n  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), hours, minutes);\n};\n\n/** Returns a new date object with the given date (e.g. 5/2/2022) and the specified timeNum (e.g. 11.5) */\nexport const getDateWithTimeNum = (date, timeNum, utc = false) => {\n  date = new Date(date);\n  const hours = parseInt(timeNum);\n  const minutes = (timeNum - hours) * 60;\n  if (!utc) {\n    return new Date(date.getFullYear(), date.getMonth(), date.getDate(), hours, minutes);\n  } else {\n    return new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), hours, minutes));\n  }\n};\n\n/** Returns a date object from the given mongodb objectId */\nexport const dateFromObjectId = function (objectId) {\n  return new Date(parseInt(objectId.substring(0, 8), 16) * 1000);\n};\n\n/** Takes a time string (e.g. 13:30) and splits it into hours and minutes, returning an object of the form { hours, minutes } */\nexport const splitTime = timeString => {\n  const [hours, minutes] = timeString.split(\":\");\n  return {\n    hours: parseInt(hours),\n    minutes: parseInt(minutes)\n  };\n};\n\n/** Takes a timeNum (e.g. 9.5) and splits it into hours and minutes, returning an object of the form { hours, minutes } */\nexport const splitTimeNum = timeNum => {\n  const hours = Math.floor(timeNum);\n  const minutes = Math.floor((timeNum - hours) * 60);\n  return {\n    hours,\n    minutes\n  };\n};\n\n/** Returns the specified date offset by the given number of days (can be positive or negative) */\nexport const getDateDayOffset = (date, offset) => {\n  date = new Date(date);\n  return new Date(date.getTime() + offset * 24 * 60 * 60 * 1000);\n};\n\n/** Returns the specified date offset by the given number of hours */\nexport const getDateHoursOffset = (date, hoursOffset) => {\n  const {\n    hours,\n    minutes\n  } = splitTimeNum(hoursOffset);\n  const newDate = new Date(date);\n  newDate.setHours(newDate.getHours() + hours);\n  newDate.setMinutes(newDate.getMinutes() + minutes);\n  return newDate;\n};\n\n/**\n * Returns a date, transformed to be in the same week of the dows array.\n * `reverse` determines whether to do the opposite calculation (dow date to date)\n */\nexport const dateToDowDate = (dows, date, weekOffset, reverse = false, startOnMonday = false) => {\n  // Sort dows to make sure first date is not Saturday when there are multiple dates\n  // (as such is the case when an event is created in Tokyo and you're answering in Mountain View)\n  // This fixes the dayOffset calculation so that events are displayed in the correct week\n  dows = [...dows].sort((date1, date2) => {\n    let day1 = new Date(date1).getUTCDay();\n    let day2 = new Date(date2).getUTCDay();\n    if (startOnMonday) {\n      if (day1 === 0) day1 = 7;\n      if (day2 === 0) day2 = 7;\n    }\n    return day1 - day2;\n  });\n\n  // Get Sunday of the week containing the dows\n  const dowSunday = new Date(dows[0]);\n  dowSunday.setUTCDate(dowSunday.getUTCDate() - dowSunday.getUTCDay());\n\n  // Get Sunday of the current week offset by weekOffset\n  const curSunday = new Date();\n  curSunday.setUTCDate(curSunday.getUTCDate() - curSunday.getUTCDay());\n  curSunday.setUTCDate(curSunday.getUTCDate() + 7 * weekOffset);\n  curSunday.setUTCHours(dowSunday.getUTCHours());\n  curSunday.setUTCMinutes(dowSunday.getUTCMinutes());\n  curSunday.setUTCSeconds(dowSunday.getUTCSeconds());\n  curSunday.setUTCMilliseconds(dowSunday.getUTCMilliseconds());\n\n  // Get the amount of days between both of the sundays\n  let dayOffset = Math.round((curSunday - dowSunday) / (1000 * 60 * 60 * 24));\n\n  // Reverse calculation if necessary\n  if (reverse) {\n    dayOffset *= -1;\n  }\n\n  // Offset date by the amount of days between the two sundays\n  date = new Date(date);\n  date.setUTCDate(date.getUTCDate() - dayOffset);\n  return date;\n};\n\n/** Converts a timeNum (e.g. 13) to a timeText (e.g. \"1 pm\") */\nexport const timeNumToTimeText = (timeNum, hour12 = true) => {\n  const hours = Math.floor(timeNum);\n  const minutesDecimal = timeNum - hours;\n  const minutesString = minutesDecimal > 0 ? `:${String(Math.floor(minutesDecimal * 60)).padStart(2, \"0\")}` : \"\";\n  if (hour12) {\n    if (timeNum >= 0 && timeNum < 1) return `12${minutesString} am`;else if (timeNum < 12) return `${hours}${minutesString} am`;else if (timeNum >= 12 && timeNum < 13) return `12${minutesString} pm`;\n    return `${hours - 12}${minutesString} pm`;\n  }\n  return `${hours}:${minutesString.length > 0 ? minutesString : \"00\"}`;\n};\n\n/** Converts a timeNum (e.g. 9.5) to a timeString (e.g. 09:30:00) */\nexport const timeNumToTimeString = timeNum => {\n  const hours = Math.floor(timeNum);\n  const minutesDecimal = timeNum - hours;\n  const paddedHours = String(hours).padStart(2, \"0\");\n  const paddedMinutes = String(Math.floor(minutesDecimal * 60)).padStart(2, \"0\");\n  return `${paddedHours}:${paddedMinutes}:00`;\n};\n\n/** Converts a date to a timeNum (e.g. 9.5) */\nexport const dateToTimeNum = (date, utc = false) => {\n  date = new Date(date);\n  if (utc) {\n    return date.getUTCHours() + date.getUTCMinutes() / 60;\n  }\n  return date.getHours() + date.getMinutes() / 60;\n};\n\n/** Clamps the date to the given time, type can either be \"upper\" or \"lower\" */\nexport const clampDateToTimeNum = (date, timeNum, type) => {\n  const diff = dateToTimeNum(date) - timeNum;\n  if (type === \"upper\" && diff < 0) {\n    return getDateWithTimeNum(date, timeNum);\n  } else if (type === \"lower\" && diff > 0) {\n    return getDateWithTimeNum(date, timeNum);\n  }\n\n  // Return original date\n  return date;\n};\n\n/** Returns negative if date1 < date2, positive if date2 > date1, and 0 if date1 == date2 */\nexport const dateCompare = (date1, date2) => {\n  date1 = new Date(date1);\n  date2 = new Date(date2);\n  return date1.getTime() - date2.getTime();\n};\n\n/** Returns whether the given date is between startDate and endDate */\nexport const isDateBetween = (date, startDate, endDate) => {\n  date = new Date(date).getTime();\n  startDate = new Date(startDate).getTime();\n  endDate = new Date(endDate).getTime();\n  return date >= startDate && date <= endDate;\n};\n\n/** Returns the number of days in the given month */\nexport const getDaysInMonth = (month, year) => {\n  return new Date(year, month, 0).getDate();\n};\n\n/** returns -1 if a is before b, 1 if a is after b, 0 otherwise */\nexport const compareDateDay = (a, b) => {\n  a = new Date(a);\n  b = new Date(b);\n  if (a.getFullYear() !== b.getFullYear()) {\n    return a.getFullYear() - b.getFullYear();\n  } else if (a.getMonth() !== b.getMonth()) {\n    return a.getMonth() - b.getMonth();\n  } else {\n    return a.getDate() - b.getDate();\n  }\n};\n\n/**\nReturns whether the given timeNum is between date1 and date2 \nsuch that date1.getHour() <= timeNum <= date2.getHour(), accounting \nfor the possibility that date1 and date2 might be on separate days\n*/\nexport const isTimeNumBetweenDates = (timeNum, date1, date2) => {\n  const hour1 = date1.getHours();\n  const hour2 = date2.getHours();\n  if (hour1 <= hour2) {\n    return hour1 <= timeNum && timeNum <= hour2;\n  } else {\n    return hour1 <= timeNum && timeNum < 24 || 0 <= timeNum && timeNum <= hour2;\n  }\n};\n\n/** Returns whether date is in between startDate and startDate + duration (in hours) */\nexport const isDateInRange = (date, startDate, duration) => {\n  const endDate = new Date(startDate);\n  endDate.setHours(endDate.getHours() + duration);\n  return startDate <= date && date <= endDate;\n};\n\n/** Converts a utc time int to a local time int based on the timezoneOffset */\nexport const utcTimeToLocalTime = (timeNum, timezoneOffset = new Date().getTimezoneOffset()) => {\n  let localTimeNum = timeNum - timezoneOffset / 60;\n  localTimeNum %= 24;\n  if (localTimeNum < 0) localTimeNum += 24;\n  return localTimeNum;\n};\n\n/** Returns a string representing the current timezone */\nexport const getCurrentTimezone = () => {\n  return new Date().toLocaleTimeString(\"en-us\", {\n    timeZoneName: \"short\"\n  }).split(\" \")[2];\n};\n\n/** Returns the preferred locale of the user\n * Source: https://stackoverflow.com/questions/673905/how-can-i-determine-a-users-locale-within-the-browser\n */\nexport const getLocale = () => {\n  if (navigator.languages != undefined) return navigator.languages[0];\n  return navigator.language;\n};\n\n/** Returns whether the user prefers 12h time */\nexport const userPrefers12h = () => {\n  return Intl.DateTimeFormat(getLocale(), {\n    hour: \"numeric\"\n  }).resolvedOptions().hour12;\n};\n\n/** Returns an array of time options based on whether user prefers 12h or 24h */\nexport const getTimeOptions = () => {\n  const prefers12h = !localStorage[\"timeType\"] ? userPrefers12h() : localStorage[\"timeType\"] === timeTypes.HOUR12;\n  const times = [];\n  if (prefers12h) {\n    times.push({\n      text: \"12 am\",\n      time: 0,\n      value: 0\n    });\n    for (let h = 1; h < 12; ++h) {\n      times.push({\n        text: `${h} am`,\n        time: h,\n        value: h\n      });\n    }\n    for (let h = 0; h < 12; ++h) {\n      times.push({\n        text: `${h == 0 ? 12 : h} pm`,\n        time: h + 12,\n        value: h + 12\n      });\n    }\n    times.push({\n      text: \"12 am\",\n      time: 0,\n      value: 24\n    });\n    return times;\n  }\n  for (let h = 0; h < 24; ++h) {\n    times.push({\n      text: `${h}:00`,\n      time: h,\n      value: h\n    });\n  }\n  times.push({\n    text: \"0:00\",\n    time: 0,\n    value: 24\n  });\n  return times;\n};\n\n/** \n  Returns an object of the users' calendar events for each calendar account for the given event, filtering for events\n  only between the time ranges of the event and clamping calendar events that extend beyond the time\n  ranges\n  weekOffset specifies the amount of weeks forward or backward to display events for (only used for weekly schej's)\n*/\nexport const getCalendarEventsMap = async (event, {\n  weekOffset = 0,\n  eventId = \"\"\n}) => {\n  let timeMin, timeMax;\n  if (event.type === eventTypes.SPECIFIC_DATES) {\n    // Get all calendar events between the first date and the last date in dates\n    timeMin = new Date(event.dates[0]).toISOString();\n    timeMax = getDateDayOffset(new Date(event.dates[event.dates.length - 1]), 2).toISOString();\n  } else if (event.type === eventTypes.DOW || event.type === eventTypes.GROUP) {\n    // Get all calendar events for the current week offsetted by weekOffset\n    const firstDate = dateToDowDate(event.dates, event.dates[0], weekOffset, true, event.startOnMonday);\n    const lastDate = dateToDowDate(event.dates, event.dates[event.dates.length - 1], weekOffset, true, event.startOnMonday);\n    timeMin = getDateDayOffset(firstDate, -2).toISOString();\n    timeMax = getDateDayOffset(lastDate, 2).toISOString();\n  }\n\n  // Fetch calendar events from Google Calendar\n  let calendarEventsMap;\n  if (eventId.length === 0) {\n    calendarEventsMap = await get(`/user/calendars?timeMin=${timeMin}&timeMax=${timeMax}`);\n  } else {\n    calendarEventsMap = await get(`/events/${eventId}/calendar-availabilities?timeMin=${timeMin}&timeMax=${timeMax}`);\n  }\n  return calendarEventsMap;\n};\n\n/**\n * Returns a time block object based on the date object and the hours offset and length\n */\nexport const getTimeBlock = (date, hoursOffset, hoursLength) => {\n  const startDate = new Date(date.getTime() + hoursOffset * 60 * 60 * 1000);\n  const endDate = new Date(startDate.getTime() + hoursLength * 60 * 60 * 1000);\n  return {\n    startDate: startDate,\n    endDate: endDate\n  };\n};\n\n/**\n  Returns an array of a user's calendar events split by date for a given event\n*/\nexport const splitTimeBlocksByDay = (event, timeBlocks, weekOffset = 0, timezoneOffset = null) => {\n  return processTimeBlocks(event.dates, event.duration, timeBlocks, event.type, weekOffset, event.startOnMonday, timezoneOffset);\n};\n\n/** Takes an array of time blocks and returns a new array separated by day and with hoursOffset and hoursLength properties */\nexport const processTimeBlocks = (dates, duration, timeBlocks, eventType = eventTypes.SPECIFIC_DATES, weekOffset = 0, startOnMonday = false, timezoneOffset = 0) => {\n  // Put timeBlocks into the correct format\n  timeBlocks = JSON.parse(JSON.stringify(timeBlocks)); // Make a copy so we don't mutate original array\n  timeBlocks = timeBlocks.map(e => {\n    if (eventType === eventTypes.DOW || eventType === eventTypes.GROUP) {\n      e.startDate = dateToDowDate(dates, e.startDate, weekOffset, false, startOnMonday);\n      e.endDate = dateToDowDate(dates, e.endDate, weekOffset, false, startOnMonday);\n    } else {\n      e.startDate = new Date(e.startDate);\n      e.endDate = new Date(e.endDate);\n    }\n    return e;\n  });\n  timeBlocks.sort((a, b) => dateCompare(a.startDate, b.startDate));\n\n  // Format array of calendar events by day\n  const datesSoFar = new Set();\n  const timeBlocksByDay = [];\n  for (let i = 0; i < dates.length; ++i) {\n    timeBlocksByDay[i] = [];\n    const date = new Date(dates[i]);\n    datesSoFar.add(date.getTime());\n  }\n\n  // Iterate through all dates and add calendar events to array\n  let i = 0;\n  for (const date of dates) {\n    if (timeBlocks.length == 0) break;\n    const start = new Date(date);\n    const end = new Date(start);\n    end.setHours(start.getHours() + duration);\n    const localDayStart = new Date(start.getTime() - timezoneOffset * 60 * 1000);\n    const localDayEnd = new Date(end.getTime() - timezoneOffset * 60 * 1000);\n\n    // Keep iterating through calendar events until it's empty or there are no more events for the current date\n    while (timeBlocks.length > 0 && end > timeBlocks[0].startDate) {\n      let [calendarEvent] = timeBlocks.splice(0, 1);\n\n      // Check if calendar event overlaps with event time ranges\n      const startDateWithinRange = isBetween(calendarEvent.startDate, start, end);\n      const endDateWithinRange = isBetween(calendarEvent.endDate, start, end);\n      const rangeWithinCalendarEvent = isBetween(start, calendarEvent.startDate, calendarEvent.endDate) && isBetween(end, calendarEvent.startDate, calendarEvent.endDate);\n      if (startDateWithinRange || endDateWithinRange || rangeWithinCalendarEvent) {\n        const rangeStartWithinCalendarEvent = isBetween(start, calendarEvent.startDate, calendarEvent.endDate);\n        const rangeEndWithinCalendarEvent = isBetween(end, calendarEvent.startDate, calendarEvent.endDate);\n        if (rangeStartWithinCalendarEvent) {\n          // Clamp calendarEvent start\n          calendarEvent = {\n            ...calendarEvent,\n            startDate: start\n          };\n        }\n        if (rangeEndWithinCalendarEvent) {\n          // If the calendar event potentially goes to the next day, we need to add a new time block for it (this is mostly for all day events spanning multiple days)\n          const calendarEventToAdd = {\n            ...calendarEvent,\n            startDate: end\n          };\n          timeBlocks.splice(0, 0, calendarEventToAdd);\n          timeBlocks.sort((a, b) => dateCompare(a.startDate, b.startDate));\n          // Clamp calendarEvent end\n          calendarEvent = {\n            ...calendarEvent,\n            endDate: end\n          };\n        }\n\n        // The number of hours since start time\n        const hoursOffset = (calendarEvent.startDate.getTime() - start.getTime()) / (1000 * 60 * 60);\n\n        // The length of the event in hours\n        const hoursLength = (calendarEvent.endDate.getTime() - calendarEvent.startDate.getTime()) / (1000 * 60 * 60);\n\n        // Don't display event if the event is 0 hours long\n        if (hoursLength == 0) continue;\n\n        // Check if the event goes into the next day\n        // Format the UTC date to be in the selected timezone\n        const localStart = new Date(calendarEvent.startDate.getTime() - timezoneOffset * 60 * 1000);\n        const localEnd = new Date(calendarEvent.endDate.getTime() - timezoneOffset * 60 * 1000);\n        if (localStart.getUTCDate() !== localEnd.getUTCDate()) {\n          // The event goes into the next day. Split the event into two time blocks\n          let splitDate = new Date(localStart);\n          splitDate.setUTCDate(splitDate.getUTCDate() + 1);\n          splitDate.setUTCHours(0, 0, 0, 0);\n          splitDate.setTime(splitDate.getTime() + timezoneOffset * 60 * 1000);\n          const firstTimeBlock = {\n            ...calendarEvent,\n            id: calendarEvent.id + \"-1\",\n            endDate: splitDate,\n            hoursOffset: hoursOffset,\n            hoursLength: hoursLength\n          };\n          const firstHoursLength = (firstTimeBlock.endDate.getTime() - firstTimeBlock.startDate.getTime()) / (1000 * 60 * 60);\n          const secondTimeBlock = {\n            ...calendarEvent,\n            id: calendarEvent.id + \"-2\",\n            startDate: splitDate,\n            hoursOffset: hoursOffset + firstHoursLength,\n            hoursLength: hoursLength - firstHoursLength\n          };\n          const secondHoursLength = (secondTimeBlock.endDate.getTime() - secondTimeBlock.startDate.getTime()) / (1000 * 60 * 60);\n          timeBlocksByDay[i].push({\n            ...firstTimeBlock,\n            hoursOffset: hoursOffset,\n            hoursLength: firstHoursLength\n          });\n          if (i + 1 >= timeBlocksByDay.length) {\n            timeBlocksByDay.push([]);\n          }\n          timeBlocksByDay[i + 1].push({\n            ...secondTimeBlock,\n            hoursOffset: hoursOffset + firstHoursLength,\n            hoursLength: secondHoursLength\n          });\n          continue;\n        } else if (localDayStart.getUTCDate() !== localStart.getUTCDate()) {\n          // The event starts on the next day. move the event to the next day\n          if (i + 1 >= timeBlocksByDay.length) {\n            timeBlocksByDay.push([]);\n          }\n          timeBlocksByDay[i + 1].push({\n            ...calendarEvent,\n            hoursOffset,\n            hoursLength\n          });\n          continue;\n        }\n        timeBlocksByDay[i].push({\n          ...calendarEvent,\n          hoursOffset,\n          hoursLength\n        });\n      }\n    }\n\n    // Check if the start and end of the current day are on different days in this timezone\n    if (localDayStart.getUTCDate() !== localDayEnd.getUTCDate()) {\n      const nextDate = new Date(start);\n      nextDate.setUTCDate(nextDate.getUTCDate() + 1);\n      if (!datesSoFar.has(nextDate.getTime())) {\n        // The start and end of the current day are on different days in this timezone, append a new index to the timeBlocksByDay array\n        timeBlocksByDay.push([]);\n        i += 1;\n      }\n    }\n    i++;\n  }\n  return timeBlocksByDay;\n};\nexport const getCalendarAccountKey = (email, calendarType) => {\n  return `${email}_${calendarType}`;\n};\nexport const stdTimezoneOffset = date => {\n  const jan = new Date(date.getFullYear(), 0, 1);\n  const jul = new Date(date.getFullYear(), 6, 1);\n  return Math.max(jan.getTimezoneOffset(), jul.getTimezoneOffset());\n};\nexport const isDstObserved = date => {\n  return date.getTimezoneOffset() < stdTimezoneOffset(date);\n};","map":{"version":3,"names":["eventTypes","timeTypes","get","isBetween","getDateString","date","utc","Date","getUTCMonth","getUTCDate","getMonth","getDate","getStartEndDateString","startDate","endDate","startDay","toLocaleString","weekday","startMonth","month","startDayOfMonth","day","startTime","hour","minute","endTime","timeZoneName","getISODateString","toISOString","substring","year","getFullYear","String","padStart","getDateRangeString","date1","date2","getUTCHours","getHours","getDateDayOffset","getDateRangeStringForEvent","event","timezone","localStorage","JSON","parse","type","DOW","GROUP","s","dayAbbreviations","dates","getDateWithTimezone","abbr","getUTCDay","length","SPECIFIC_DATES","setTime","getTime","offset","getTimezoneOffset","getDateWithTime","timeString","hours","minutes","splitTime","getDateWithTimeNum","timeNum","parseInt","UTC","getUTCFullYear","dateFromObjectId","objectId","split","splitTimeNum","Math","floor","getDateHoursOffset","hoursOffset","newDate","setHours","setMinutes","getMinutes","dateToDowDate","dows","weekOffset","reverse","startOnMonday","sort","day1","day2","dowSunday","setUTCDate","curSunday","setUTCHours","setUTCMinutes","getUTCMinutes","setUTCSeconds","getUTCSeconds","setUTCMilliseconds","getUTCMilliseconds","dayOffset","round","timeNumToTimeText","hour12","minutesDecimal","minutesString","timeNumToTimeString","paddedHours","paddedMinutes","dateToTimeNum","clampDateToTimeNum","diff","dateCompare","isDateBetween","getDaysInMonth","compareDateDay","a","b","isTimeNumBetweenDates","hour1","hour2","isDateInRange","duration","utcTimeToLocalTime","timezoneOffset","localTimeNum","getCurrentTimezone","toLocaleTimeString","getLocale","navigator","languages","undefined","language","userPrefers12h","Intl","DateTimeFormat","resolvedOptions","getTimeOptions","prefers12h","HOUR12","times","push","text","time","value","h","getCalendarEventsMap","eventId","timeMin","timeMax","firstDate","lastDate","calendarEventsMap","getTimeBlock","hoursLength","splitTimeBlocksByDay","timeBlocks","processTimeBlocks","eventType","stringify","map","e","datesSoFar","Set","timeBlocksByDay","i","add","start","end","localDayStart","localDayEnd","calendarEvent","splice","startDateWithinRange","endDateWithinRange","rangeWithinCalendarEvent","rangeStartWithinCalendarEvent","rangeEndWithinCalendarEvent","calendarEventToAdd","localStart","localEnd","splitDate","firstTimeBlock","id","firstHoursLength","secondTimeBlock","secondHoursLength","nextDate","has","getCalendarAccountKey","email","calendarType","stdTimezoneOffset","jan","jul","max","isDstObserved"],"sources":["/Users/kasperzhang/Desktop/MeetZap/frontend/src/utils/date_utils.js"],"sourcesContent":["import { eventTypes, timeTypes } from \"@/constants\"\nimport { get } from \"./fetch_utils\"\nimport { isBetween } from \"./general_utils\"\n/* \n  Date utils \n*/\n\n/** Returns a string representation of the given date, i.e. May 14th is \"5/14\" */\nexport const getDateString = (date, utc = false) => {\n  date = new Date(date)\n  if (utc) {\n    return `${date.getUTCMonth() + 1}/${date.getUTCDate()}`\n  }\n  return `${date.getMonth() + 1}/${date.getDate()}`\n}\n\n/** Returns a string in the format \"Mon, 9/23, 10 AM - 12 PM PDT\" given a start date and end date */\nexport const getStartEndDateString = (startDate, endDate) => {\n  const startDay = startDate.toLocaleString(\"en-US\", { weekday: \"short\" })\n  const startMonth = startDate.toLocaleString(\"en-US\", { month: \"short\" })\n  const startDayOfMonth = startDate.toLocaleString(\"en-US\", { day: \"numeric\" })\n  const startTime = startDate.toLocaleString(\"en-US\", {\n    hour: \"numeric\",\n    minute: \"numeric\",\n  })\n  const endTime = endDate.toLocaleString(\"en-US\", {\n    hour: \"numeric\",\n    minute: \"numeric\",\n    timeZoneName: \"short\",\n  })\n\n  return `${startDay}, ${startMonth} ${startDayOfMonth}, ${startTime} - ${endTime}`\n}\n\n/** Returns an ISO formatted date string */\nexport const getISODateString = (date, utc = false) => {\n  date = new Date(date)\n  if (utc) {\n    return date.toISOString().substring(0, 10)\n  }\n\n  const year = date.getFullYear()\n  const month = String(date.getMonth() + 1).padStart(2, \"0\")\n  const day = String(date.getDate()).padStart(2, \"0\")\n  return `${year}-${month}-${day}`\n}\n\n/** Returns a string representing date range from date1 to date2, i.e. \"5/14 - 5/27\" */\nexport const getDateRangeString = (date1, date2, utc = false) => {\n  date1 = new Date(date1)\n  date2 = new Date(date2)\n\n  // Correct date2 if time is 12am (because ending at 12am doesn't begin the next day)\n  if ((utc && date2.getUTCHours() == 0) || (!utc && date2.getHours() == 0)) {\n    date2 = getDateDayOffset(date2, -1)\n  }\n\n  return getDateString(date1, utc) + \" - \" + getDateString(date2, utc)\n}\n\n/** Returns a string representing the date range for the provided event */\nexport const getDateRangeStringForEvent = (event) => {\n  let timezone = localStorage[\"timezone\"]\n  if (timezone) timezone = JSON.parse(timezone)\n\n  if (event.type === eventTypes.DOW || event.type === eventTypes.GROUP) {\n    let s = \"\"\n\n    const dayAbbreviations = [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"]\n    for (let date of event.dates) {\n      date = getDateWithTimezone(date)\n\n      const abbr = dayAbbreviations[date.getUTCDay()]\n      s += abbr + \", \"\n    }\n    s = s.substring(0, s.length - 2)\n    return s\n  } else if (event.type === eventTypes.SPECIFIC_DATES) {\n    const startDate = getDateWithTimezone(new Date(event.dates[0]))\n    const endDate = getDateWithTimezone(\n      new Date(event.dates[event.dates.length - 1])\n    )\n    return getDateRangeString(startDate, endDate, true)\n  }\n\n  return \"\"\n}\n\n/** Returns a a new date, offset by the timezone in local storage if it exists, offset by local timezone if not */\nexport const getDateWithTimezone = (date) => {\n  date = new Date(date)\n\n  let timezone = localStorage[\"timezone\"]\n  if (timezone) timezone = JSON.parse(timezone)\n\n  if (timezone) {\n    date.setTime(date.getTime() + timezone.offset * 60 * 1000)\n  } else {\n    date.setTime(date.getTime() - new Date().getTimezoneOffset() * 60 * 1000)\n  }\n\n  return date\n}\n\n/** Returns a new date object with the given date (e.g. 5/2/2022) and the specified time (e.g. \"11:30\") */\nexport const getDateWithTime = (date, timeString) => {\n  date = new Date(date)\n\n  const { hours, minutes } = splitTime(timeString)\n  return new Date(\n    date.getFullYear(),\n    date.getMonth(),\n    date.getDate(),\n    hours,\n    minutes\n  )\n}\n\n/** Returns a new date object with the given date (e.g. 5/2/2022) and the specified timeNum (e.g. 11.5) */\nexport const getDateWithTimeNum = (date, timeNum, utc = false) => {\n  date = new Date(date)\n\n  const hours = parseInt(timeNum)\n  const minutes = (timeNum - hours) * 60\n  if (!utc) {\n    return new Date(\n      date.getFullYear(),\n      date.getMonth(),\n      date.getDate(),\n      hours,\n      minutes\n    )\n  } else {\n    return new Date(\n      Date.UTC(\n        date.getUTCFullYear(),\n        date.getUTCMonth(),\n        date.getUTCDate(),\n        hours,\n        minutes\n      )\n    )\n  }\n}\n\n/** Returns a date object from the given mongodb objectId */\nexport const dateFromObjectId = function (objectId) {\n  return new Date(parseInt(objectId.substring(0, 8), 16) * 1000)\n}\n\n/** Takes a time string (e.g. 13:30) and splits it into hours and minutes, returning an object of the form { hours, minutes } */\nexport const splitTime = (timeString) => {\n  const [hours, minutes] = timeString.split(\":\")\n  return { hours: parseInt(hours), minutes: parseInt(minutes) }\n}\n\n/** Takes a timeNum (e.g. 9.5) and splits it into hours and minutes, returning an object of the form { hours, minutes } */\nexport const splitTimeNum = (timeNum) => {\n  const hours = Math.floor(timeNum)\n  const minutes = Math.floor((timeNum - hours) * 60)\n  return { hours, minutes }\n}\n\n/** Returns the specified date offset by the given number of days (can be positive or negative) */\nexport const getDateDayOffset = (date, offset) => {\n  date = new Date(date)\n  return new Date(date.getTime() + offset * 24 * 60 * 60 * 1000)\n}\n\n/** Returns the specified date offset by the given number of hours */\nexport const getDateHoursOffset = (date, hoursOffset) => {\n  const { hours, minutes } = splitTimeNum(hoursOffset)\n  const newDate = new Date(date)\n  newDate.setHours(newDate.getHours() + hours)\n  newDate.setMinutes(newDate.getMinutes() + minutes)\n  return newDate\n}\n\n/**\n * Returns a date, transformed to be in the same week of the dows array.\n * `reverse` determines whether to do the opposite calculation (dow date to date)\n */\nexport const dateToDowDate = (\n  dows,\n  date,\n  weekOffset,\n  reverse = false,\n  startOnMonday = false\n) => {\n  // Sort dows to make sure first date is not Saturday when there are multiple dates\n  // (as such is the case when an event is created in Tokyo and you're answering in Mountain View)\n  // This fixes the dayOffset calculation so that events are displayed in the correct week\n  dows = [...dows].sort((date1, date2) => {\n    let day1 = new Date(date1).getUTCDay()\n    let day2 = new Date(date2).getUTCDay()\n    if (startOnMonday) {\n      if (day1 === 0) day1 = 7\n      if (day2 === 0) day2 = 7\n    }\n    return day1 - day2\n  })\n\n  // Get Sunday of the week containing the dows\n  const dowSunday = new Date(dows[0])\n  dowSunday.setUTCDate(dowSunday.getUTCDate() - dowSunday.getUTCDay())\n\n  // Get Sunday of the current week offset by weekOffset\n  const curSunday = new Date()\n  curSunday.setUTCDate(curSunday.getUTCDate() - curSunday.getUTCDay())\n  curSunday.setUTCDate(curSunday.getUTCDate() + 7 * weekOffset)\n  curSunday.setUTCHours(dowSunday.getUTCHours())\n  curSunday.setUTCMinutes(dowSunday.getUTCMinutes())\n  curSunday.setUTCSeconds(dowSunday.getUTCSeconds())\n  curSunday.setUTCMilliseconds(dowSunday.getUTCMilliseconds())\n\n  // Get the amount of days between both of the sundays\n  let dayOffset = Math.round((curSunday - dowSunday) / (1000 * 60 * 60 * 24))\n\n  // Reverse calculation if necessary\n  if (reverse) {\n    dayOffset *= -1\n  }\n\n  // Offset date by the amount of days between the two sundays\n  date = new Date(date)\n  date.setUTCDate(date.getUTCDate() - dayOffset)\n\n  return date\n}\n\n/** Converts a timeNum (e.g. 13) to a timeText (e.g. \"1 pm\") */\nexport const timeNumToTimeText = (timeNum, hour12 = true) => {\n  const hours = Math.floor(timeNum)\n  const minutesDecimal = timeNum - hours\n  const minutesString =\n    minutesDecimal > 0\n      ? `:${String(Math.floor(minutesDecimal * 60)).padStart(2, \"0\")}`\n      : \"\"\n\n  if (hour12) {\n    if (timeNum >= 0 && timeNum < 1) return `12${minutesString} am`\n    else if (timeNum < 12) return `${hours}${minutesString} am`\n    else if (timeNum >= 12 && timeNum < 13) return `12${minutesString} pm`\n    return `${hours - 12}${minutesString} pm`\n  }\n\n  return `${hours}:${minutesString.length > 0 ? minutesString : \"00\"}`\n}\n\n/** Converts a timeNum (e.g. 9.5) to a timeString (e.g. 09:30:00) */\nexport const timeNumToTimeString = (timeNum) => {\n  const hours = Math.floor(timeNum)\n  const minutesDecimal = timeNum - hours\n  const paddedHours = String(hours).padStart(2, \"0\")\n  const paddedMinutes = String(Math.floor(minutesDecimal * 60)).padStart(2, \"0\")\n\n  return `${paddedHours}:${paddedMinutes}:00`\n}\n\n/** Converts a date to a timeNum (e.g. 9.5) */\nexport const dateToTimeNum = (date, utc = false) => {\n  date = new Date(date)\n  if (utc) {\n    return date.getUTCHours() + date.getUTCMinutes() / 60\n  }\n  return date.getHours() + date.getMinutes() / 60\n}\n\n/** Clamps the date to the given time, type can either be \"upper\" or \"lower\" */\nexport const clampDateToTimeNum = (date, timeNum, type) => {\n  const diff = dateToTimeNum(date) - timeNum\n  if (type === \"upper\" && diff < 0) {\n    return getDateWithTimeNum(date, timeNum)\n  } else if (type === \"lower\" && diff > 0) {\n    return getDateWithTimeNum(date, timeNum)\n  }\n\n  // Return original date\n  return date\n}\n\n/** Returns negative if date1 < date2, positive if date2 > date1, and 0 if date1 == date2 */\nexport const dateCompare = (date1, date2) => {\n  date1 = new Date(date1)\n  date2 = new Date(date2)\n  return date1.getTime() - date2.getTime()\n}\n\n/** Returns whether the given date is between startDate and endDate */\nexport const isDateBetween = (date, startDate, endDate) => {\n  date = new Date(date).getTime()\n  startDate = new Date(startDate).getTime()\n  endDate = new Date(endDate).getTime()\n  return date >= startDate && date <= endDate\n}\n\n/** Returns the number of days in the given month */\nexport const getDaysInMonth = (month, year) => {\n  return new Date(year, month, 0).getDate()\n}\n\n/** returns -1 if a is before b, 1 if a is after b, 0 otherwise */\nexport const compareDateDay = (a, b) => {\n  a = new Date(a)\n  b = new Date(b)\n  if (a.getFullYear() !== b.getFullYear()) {\n    return a.getFullYear() - b.getFullYear()\n  } else if (a.getMonth() !== b.getMonth()) {\n    return a.getMonth() - b.getMonth()\n  } else {\n    return a.getDate() - b.getDate()\n  }\n}\n\n/**\nReturns whether the given timeNum is between date1 and date2 \nsuch that date1.getHour() <= timeNum <= date2.getHour(), accounting \nfor the possibility that date1 and date2 might be on separate days\n*/\nexport const isTimeNumBetweenDates = (timeNum, date1, date2) => {\n  const hour1 = date1.getHours()\n  const hour2 = date2.getHours()\n\n  if (hour1 <= hour2) {\n    return hour1 <= timeNum && timeNum <= hour2\n  } else {\n    return (\n      (hour1 <= timeNum && timeNum < 24) || (0 <= timeNum && timeNum <= hour2)\n    )\n  }\n}\n\n/** Returns whether date is in between startDate and startDate + duration (in hours) */\nexport const isDateInRange = (date, startDate, duration) => {\n  const endDate = new Date(startDate)\n  endDate.setHours(endDate.getHours() + duration)\n  return startDate <= date && date <= endDate\n}\n\n/** Converts a utc time int to a local time int based on the timezoneOffset */\nexport const utcTimeToLocalTime = (\n  timeNum,\n  timezoneOffset = new Date().getTimezoneOffset()\n) => {\n  let localTimeNum = timeNum - timezoneOffset / 60\n  localTimeNum %= 24\n  if (localTimeNum < 0) localTimeNum += 24\n\n  return localTimeNum\n}\n\n/** Returns a string representing the current timezone */\nexport const getCurrentTimezone = () => {\n  return new Date()\n    .toLocaleTimeString(\"en-us\", { timeZoneName: \"short\" })\n    .split(\" \")[2]\n}\n\n/** Returns the preferred locale of the user\n * Source: https://stackoverflow.com/questions/673905/how-can-i-determine-a-users-locale-within-the-browser\n */\nexport const getLocale = () => {\n  if (navigator.languages != undefined) return navigator.languages[0]\n  return navigator.language\n}\n\n/** Returns whether the user prefers 12h time */\nexport const userPrefers12h = () => {\n  return Intl.DateTimeFormat(getLocale(), { hour: \"numeric\" }).resolvedOptions()\n    .hour12\n}\n\n/** Returns an array of time options based on whether user prefers 12h or 24h */\nexport const getTimeOptions = () => {\n  const prefers12h = !localStorage[\"timeType\"]\n    ? userPrefers12h()\n    : localStorage[\"timeType\"] === timeTypes.HOUR12\n\n  const times = []\n  if (prefers12h) {\n    times.push({ text: \"12 am\", time: 0, value: 0 })\n    for (let h = 1; h < 12; ++h) {\n      times.push({ text: `${h} am`, time: h, value: h })\n    }\n    for (let h = 0; h < 12; ++h) {\n      times.push({ text: `${h == 0 ? 12 : h} pm`, time: h + 12, value: h + 12 })\n    }\n    times.push({ text: \"12 am\", time: 0, value: 24 })\n\n    return times\n  }\n\n  for (let h = 0; h < 24; ++h) {\n    times.push({ text: `${h}:00`, time: h, value: h })\n  }\n  times.push({ text: \"0:00\", time: 0, value: 24 })\n  return times\n}\n\n/** \n  Returns an object of the users' calendar events for each calendar account for the given event, filtering for events\n  only between the time ranges of the event and clamping calendar events that extend beyond the time\n  ranges\n  weekOffset specifies the amount of weeks forward or backward to display events for (only used for weekly schej's)\n*/\nexport const getCalendarEventsMap = async (\n  event,\n  { weekOffset = 0, eventId = \"\" }\n) => {\n  let timeMin, timeMax\n  if (event.type === eventTypes.SPECIFIC_DATES) {\n    // Get all calendar events between the first date and the last date in dates\n    timeMin = new Date(event.dates[0]).toISOString()\n    timeMax = getDateDayOffset(\n      new Date(event.dates[event.dates.length - 1]),\n      2\n    ).toISOString()\n  } else if (event.type === eventTypes.DOW || event.type === eventTypes.GROUP) {\n    // Get all calendar events for the current week offsetted by weekOffset\n    const firstDate = dateToDowDate(\n      event.dates,\n      event.dates[0],\n      weekOffset,\n      true,\n      event.startOnMonday\n    )\n    const lastDate = dateToDowDate(\n      event.dates,\n      event.dates[event.dates.length - 1],\n      weekOffset,\n      true,\n      event.startOnMonday\n    )\n    timeMin = getDateDayOffset(firstDate, -2).toISOString()\n    timeMax = getDateDayOffset(lastDate, 2).toISOString()\n  }\n\n  // Fetch calendar events from Google Calendar\n  let calendarEventsMap\n  if (eventId.length === 0) {\n    calendarEventsMap = await get(\n      `/user/calendars?timeMin=${timeMin}&timeMax=${timeMax}`\n    )\n  } else {\n    calendarEventsMap = await get(\n      `/events/${eventId}/calendar-availabilities?timeMin=${timeMin}&timeMax=${timeMax}`\n    )\n  }\n\n  return calendarEventsMap\n}\n\n/**\n * Returns a time block object based on the date object and the hours offset and length\n */\nexport const getTimeBlock = (date, hoursOffset, hoursLength) => {\n  const startDate = new Date(date.getTime() + hoursOffset * 60 * 60 * 1000)\n  const endDate = new Date(startDate.getTime() + hoursLength * 60 * 60 * 1000)\n  return {\n    startDate: startDate,\n    endDate: endDate,\n  }\n}\n\n/**\n  Returns an array of a user's calendar events split by date for a given event\n*/\nexport const splitTimeBlocksByDay = (\n  event,\n  timeBlocks,\n  weekOffset = 0,\n  timezoneOffset = null\n) => {\n  return processTimeBlocks(\n    event.dates,\n    event.duration,\n    timeBlocks,\n    event.type,\n    weekOffset,\n    event.startOnMonday,\n    timezoneOffset\n  )\n}\n\n/** Takes an array of time blocks and returns a new array separated by day and with hoursOffset and hoursLength properties */\nexport const processTimeBlocks = (\n  dates,\n  duration,\n  timeBlocks,\n  eventType = eventTypes.SPECIFIC_DATES,\n  weekOffset = 0,\n  startOnMonday = false,\n  timezoneOffset = 0\n) => {\n  // Put timeBlocks into the correct format\n  timeBlocks = JSON.parse(JSON.stringify(timeBlocks)) // Make a copy so we don't mutate original array\n  timeBlocks = timeBlocks.map((e) => {\n    if (eventType === eventTypes.DOW || eventType === eventTypes.GROUP) {\n      e.startDate = dateToDowDate(\n        dates,\n        e.startDate,\n        weekOffset,\n        false,\n        startOnMonday\n      )\n      e.endDate = dateToDowDate(\n        dates,\n        e.endDate,\n        weekOffset,\n        false,\n        startOnMonday\n      )\n    } else {\n      e.startDate = new Date(e.startDate)\n      e.endDate = new Date(e.endDate)\n    }\n    return e\n  })\n  timeBlocks.sort((a, b) => dateCompare(a.startDate, b.startDate))\n\n  // Format array of calendar events by day\n  const datesSoFar = new Set()\n  const timeBlocksByDay = []\n  for (let i = 0; i < dates.length; ++i) {\n    timeBlocksByDay[i] = []\n    const date = new Date(dates[i])\n    datesSoFar.add(date.getTime())\n  }\n\n  // Iterate through all dates and add calendar events to array\n  let i = 0\n  for (const date of dates) {\n    if (timeBlocks.length == 0) break\n\n    const start = new Date(date)\n    const end = new Date(start)\n    end.setHours(start.getHours() + duration)\n\n    const localDayStart = new Date(start.getTime() - timezoneOffset * 60 * 1000)\n    const localDayEnd = new Date(end.getTime() - timezoneOffset * 60 * 1000)\n\n    // Keep iterating through calendar events until it's empty or there are no more events for the current date\n    while (timeBlocks.length > 0 && end > timeBlocks[0].startDate) {\n      let [calendarEvent] = timeBlocks.splice(0, 1)\n\n      // Check if calendar event overlaps with event time ranges\n      const startDateWithinRange = isBetween(\n        calendarEvent.startDate,\n        start,\n        end\n      )\n      const endDateWithinRange = isBetween(calendarEvent.endDate, start, end)\n      const rangeWithinCalendarEvent =\n        isBetween(start, calendarEvent.startDate, calendarEvent.endDate) &&\n        isBetween(end, calendarEvent.startDate, calendarEvent.endDate)\n      if (\n        startDateWithinRange ||\n        endDateWithinRange ||\n        rangeWithinCalendarEvent\n      ) {\n        const rangeStartWithinCalendarEvent = isBetween(\n          start,\n          calendarEvent.startDate,\n          calendarEvent.endDate\n        )\n        const rangeEndWithinCalendarEvent = isBetween(\n          end,\n          calendarEvent.startDate,\n          calendarEvent.endDate\n        )\n        if (rangeStartWithinCalendarEvent) {\n          // Clamp calendarEvent start\n          calendarEvent = { ...calendarEvent, startDate: start }\n        }\n        if (rangeEndWithinCalendarEvent) {\n          // If the calendar event potentially goes to the next day, we need to add a new time block for it (this is mostly for all day events spanning multiple days)\n          const calendarEventToAdd = { ...calendarEvent, startDate: end }\n          timeBlocks.splice(0, 0, calendarEventToAdd)\n          timeBlocks.sort((a, b) => dateCompare(a.startDate, b.startDate))\n          // Clamp calendarEvent end\n          calendarEvent = { ...calendarEvent, endDate: end }\n        }\n\n        // The number of hours since start time\n        const hoursOffset =\n          (calendarEvent.startDate.getTime() - start.getTime()) /\n          (1000 * 60 * 60)\n\n        // The length of the event in hours\n        const hoursLength =\n          (calendarEvent.endDate.getTime() -\n            calendarEvent.startDate.getTime()) /\n          (1000 * 60 * 60)\n\n        // Don't display event if the event is 0 hours long\n        if (hoursLength == 0) continue\n\n        // Check if the event goes into the next day\n        // Format the UTC date to be in the selected timezone\n        const localStart = new Date(\n          calendarEvent.startDate.getTime() - timezoneOffset * 60 * 1000\n        )\n        const localEnd = new Date(\n          calendarEvent.endDate.getTime() - timezoneOffset * 60 * 1000\n        )\n        if (localStart.getUTCDate() !== localEnd.getUTCDate()) {\n          // The event goes into the next day. Split the event into two time blocks\n          let splitDate = new Date(localStart)\n          splitDate.setUTCDate(splitDate.getUTCDate() + 1)\n          splitDate.setUTCHours(0, 0, 0, 0)\n          splitDate.setTime(splitDate.getTime() + timezoneOffset * 60 * 1000)\n          const firstTimeBlock = {\n            ...calendarEvent,\n            id: calendarEvent.id + \"-1\",\n            endDate: splitDate,\n            hoursOffset: hoursOffset,\n            hoursLength: hoursLength,\n          }\n          const firstHoursLength =\n            (firstTimeBlock.endDate.getTime() -\n              firstTimeBlock.startDate.getTime()) /\n            (1000 * 60 * 60)\n          const secondTimeBlock = {\n            ...calendarEvent,\n            id: calendarEvent.id + \"-2\",\n            startDate: splitDate,\n            hoursOffset: hoursOffset + firstHoursLength,\n            hoursLength: hoursLength - firstHoursLength,\n          }\n          const secondHoursLength =\n            (secondTimeBlock.endDate.getTime() -\n              secondTimeBlock.startDate.getTime()) /\n            (1000 * 60 * 60)\n          timeBlocksByDay[i].push({\n            ...firstTimeBlock,\n            hoursOffset: hoursOffset,\n            hoursLength: firstHoursLength,\n          })\n          if (i + 1 >= timeBlocksByDay.length) {\n            timeBlocksByDay.push([])\n          }\n          timeBlocksByDay[i + 1].push({\n            ...secondTimeBlock,\n            hoursOffset: hoursOffset + firstHoursLength,\n            hoursLength: secondHoursLength,\n          })\n          continue\n        } else if (localDayStart.getUTCDate() !== localStart.getUTCDate()) {\n          // The event starts on the next day. move the event to the next day\n          if (i + 1 >= timeBlocksByDay.length) {\n            timeBlocksByDay.push([])\n          }\n          timeBlocksByDay[i + 1].push({\n            ...calendarEvent,\n            hoursOffset,\n            hoursLength,\n          })\n          continue\n        }\n\n        timeBlocksByDay[i].push({\n          ...calendarEvent,\n          hoursOffset,\n          hoursLength,\n        })\n      }\n    }\n\n    // Check if the start and end of the current day are on different days in this timezone\n    if (localDayStart.getUTCDate() !== localDayEnd.getUTCDate()) {\n      const nextDate = new Date(start)\n      nextDate.setUTCDate(nextDate.getUTCDate() + 1)\n      if (!datesSoFar.has(nextDate.getTime())) {\n        // The start and end of the current day are on different days in this timezone, append a new index to the timeBlocksByDay array\n        timeBlocksByDay.push([])\n        i += 1\n      }\n    }\n    i++\n  }\n\n  return timeBlocksByDay\n}\n\nexport const getCalendarAccountKey = (email, calendarType) => {\n  return `${email}_${calendarType}`\n}\n\nexport const stdTimezoneOffset = (date) => {\n  const jan = new Date(date.getFullYear(), 0, 1)\n  const jul = new Date(date.getFullYear(), 6, 1)\n  return Math.max(jan.getTimezoneOffset(), jul.getTimezoneOffset())\n}\n\nexport const isDstObserved = (date) => {\n  return date.getTimezoneOffset() < stdTimezoneOffset(date)\n}\n"],"mappings":";AAAA,SAASA,UAAU,EAAEC,SAAS,QAAQ,aAAa;AACnD,SAASC,GAAG,QAAQ,eAAe;AACnC,SAASC,SAAS,QAAQ,iBAAiB;AAC3C;AACA;AACA;;AAEA;AACA,OAAO,MAAMC,aAAa,GAAGA,CAACC,IAAI,EAAEC,GAAG,GAAG,KAAK,KAAK;EAClDD,IAAI,GAAG,IAAIE,IAAI,CAACF,IAAI,CAAC;EACrB,IAAIC,GAAG,EAAE;IACP,OAAQ,GAAED,IAAI,CAACG,WAAW,CAAC,CAAC,GAAG,CAAE,IAAGH,IAAI,CAACI,UAAU,CAAC,CAAE,EAAC;EACzD;EACA,OAAQ,GAAEJ,IAAI,CAACK,QAAQ,CAAC,CAAC,GAAG,CAAE,IAAGL,IAAI,CAACM,OAAO,CAAC,CAAE,EAAC;AACnD,CAAC;;AAED;AACA,OAAO,MAAMC,qBAAqB,GAAGA,CAACC,SAAS,EAAEC,OAAO,KAAK;EAC3D,MAAMC,QAAQ,GAAGF,SAAS,CAACG,cAAc,CAAC,OAAO,EAAE;IAAEC,OAAO,EAAE;EAAQ,CAAC,CAAC;EACxE,MAAMC,UAAU,GAAGL,SAAS,CAACG,cAAc,CAAC,OAAO,EAAE;IAAEG,KAAK,EAAE;EAAQ,CAAC,CAAC;EACxE,MAAMC,eAAe,GAAGP,SAAS,CAACG,cAAc,CAAC,OAAO,EAAE;IAAEK,GAAG,EAAE;EAAU,CAAC,CAAC;EAC7E,MAAMC,SAAS,GAAGT,SAAS,CAACG,cAAc,CAAC,OAAO,EAAE;IAClDO,IAAI,EAAE,SAAS;IACfC,MAAM,EAAE;EACV,CAAC,CAAC;EACF,MAAMC,OAAO,GAAGX,OAAO,CAACE,cAAc,CAAC,OAAO,EAAE;IAC9CO,IAAI,EAAE,SAAS;IACfC,MAAM,EAAE,SAAS;IACjBE,YAAY,EAAE;EAChB,CAAC,CAAC;EAEF,OAAQ,GAAEX,QAAS,KAAIG,UAAW,IAAGE,eAAgB,KAAIE,SAAU,MAAKG,OAAQ,EAAC;AACnF,CAAC;;AAED;AACA,OAAO,MAAME,gBAAgB,GAAGA,CAACtB,IAAI,EAAEC,GAAG,GAAG,KAAK,KAAK;EACrDD,IAAI,GAAG,IAAIE,IAAI,CAACF,IAAI,CAAC;EACrB,IAAIC,GAAG,EAAE;IACP,OAAOD,IAAI,CAACuB,WAAW,CAAC,CAAC,CAACC,SAAS,CAAC,CAAC,EAAE,EAAE,CAAC;EAC5C;EAEA,MAAMC,IAAI,GAAGzB,IAAI,CAAC0B,WAAW,CAAC,CAAC;EAC/B,MAAMZ,KAAK,GAAGa,MAAM,CAAC3B,IAAI,CAACK,QAAQ,CAAC,CAAC,GAAG,CAAC,CAAC,CAACuB,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC;EAC1D,MAAMZ,GAAG,GAAGW,MAAM,CAAC3B,IAAI,CAACM,OAAO,CAAC,CAAC,CAAC,CAACsB,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC;EACnD,OAAQ,GAAEH,IAAK,IAAGX,KAAM,IAAGE,GAAI,EAAC;AAClC,CAAC;;AAED;AACA,OAAO,MAAMa,kBAAkB,GAAGA,CAACC,KAAK,EAAEC,KAAK,EAAE9B,GAAG,GAAG,KAAK,KAAK;EAC/D6B,KAAK,GAAG,IAAI5B,IAAI,CAAC4B,KAAK,CAAC;EACvBC,KAAK,GAAG,IAAI7B,IAAI,CAAC6B,KAAK,CAAC;;EAEvB;EACA,IAAK9B,GAAG,IAAI8B,KAAK,CAACC,WAAW,CAAC,CAAC,IAAI,CAAC,IAAM,CAAC/B,GAAG,IAAI8B,KAAK,CAACE,QAAQ,CAAC,CAAC,IAAI,CAAE,EAAE;IACxEF,KAAK,GAAGG,gBAAgB,CAACH,KAAK,EAAE,CAAC,CAAC,CAAC;EACrC;EAEA,OAAOhC,aAAa,CAAC+B,KAAK,EAAE7B,GAAG,CAAC,GAAG,KAAK,GAAGF,aAAa,CAACgC,KAAK,EAAE9B,GAAG,CAAC;AACtE,CAAC;;AAED;AACA,OAAO,MAAMkC,0BAA0B,GAAIC,KAAK,IAAK;EACnD,IAAIC,QAAQ,GAAGC,YAAY,CAAC,UAAU,CAAC;EACvC,IAAID,QAAQ,EAAEA,QAAQ,GAAGE,IAAI,CAACC,KAAK,CAACH,QAAQ,CAAC;EAE7C,IAAID,KAAK,CAACK,IAAI,KAAK9C,UAAU,CAAC+C,GAAG,IAAIN,KAAK,CAACK,IAAI,KAAK9C,UAAU,CAACgD,KAAK,EAAE;IACpE,IAAIC,CAAC,GAAG,EAAE;IAEV,MAAMC,gBAAgB,GAAG,CAAC,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,CAAC;IAC1E,KAAK,IAAI7C,IAAI,IAAIoC,KAAK,CAACU,KAAK,EAAE;MAC5B9C,IAAI,GAAG+C,mBAAmB,CAAC/C,IAAI,CAAC;MAEhC,MAAMgD,IAAI,GAAGH,gBAAgB,CAAC7C,IAAI,CAACiD,SAAS,CAAC,CAAC,CAAC;MAC/CL,CAAC,IAAII,IAAI,GAAG,IAAI;IAClB;IACAJ,CAAC,GAAGA,CAAC,CAACpB,SAAS,CAAC,CAAC,EAAEoB,CAAC,CAACM,MAAM,GAAG,CAAC,CAAC;IAChC,OAAON,CAAC;EACV,CAAC,MAAM,IAAIR,KAAK,CAACK,IAAI,KAAK9C,UAAU,CAACwD,cAAc,EAAE;IACnD,MAAM3C,SAAS,GAAGuC,mBAAmB,CAAC,IAAI7C,IAAI,CAACkC,KAAK,CAACU,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;IAC/D,MAAMrC,OAAO,GAAGsC,mBAAmB,CACjC,IAAI7C,IAAI,CAACkC,KAAK,CAACU,KAAK,CAACV,KAAK,CAACU,KAAK,CAACI,MAAM,GAAG,CAAC,CAAC,CAC9C,CAAC;IACD,OAAOrB,kBAAkB,CAACrB,SAAS,EAAEC,OAAO,EAAE,IAAI,CAAC;EACrD;EAEA,OAAO,EAAE;AACX,CAAC;;AAED;AACA,OAAO,MAAMsC,mBAAmB,GAAI/C,IAAI,IAAK;EAC3CA,IAAI,GAAG,IAAIE,IAAI,CAACF,IAAI,CAAC;EAErB,IAAIqC,QAAQ,GAAGC,YAAY,CAAC,UAAU,CAAC;EACvC,IAAID,QAAQ,EAAEA,QAAQ,GAAGE,IAAI,CAACC,KAAK,CAACH,QAAQ,CAAC;EAE7C,IAAIA,QAAQ,EAAE;IACZrC,IAAI,CAACoD,OAAO,CAACpD,IAAI,CAACqD,OAAO,CAAC,CAAC,GAAGhB,QAAQ,CAACiB,MAAM,GAAG,EAAE,GAAG,IAAI,CAAC;EAC5D,CAAC,MAAM;IACLtD,IAAI,CAACoD,OAAO,CAACpD,IAAI,CAACqD,OAAO,CAAC,CAAC,GAAG,IAAInD,IAAI,CAAC,CAAC,CAACqD,iBAAiB,CAAC,CAAC,GAAG,EAAE,GAAG,IAAI,CAAC;EAC3E;EAEA,OAAOvD,IAAI;AACb,CAAC;;AAED;AACA,OAAO,MAAMwD,eAAe,GAAGA,CAACxD,IAAI,EAAEyD,UAAU,KAAK;EACnDzD,IAAI,GAAG,IAAIE,IAAI,CAACF,IAAI,CAAC;EAErB,MAAM;IAAE0D,KAAK;IAAEC;EAAQ,CAAC,GAAGC,SAAS,CAACH,UAAU,CAAC;EAChD,OAAO,IAAIvD,IAAI,CACbF,IAAI,CAAC0B,WAAW,CAAC,CAAC,EAClB1B,IAAI,CAACK,QAAQ,CAAC,CAAC,EACfL,IAAI,CAACM,OAAO,CAAC,CAAC,EACdoD,KAAK,EACLC,OACF,CAAC;AACH,CAAC;;AAED;AACA,OAAO,MAAME,kBAAkB,GAAGA,CAAC7D,IAAI,EAAE8D,OAAO,EAAE7D,GAAG,GAAG,KAAK,KAAK;EAChED,IAAI,GAAG,IAAIE,IAAI,CAACF,IAAI,CAAC;EAErB,MAAM0D,KAAK,GAAGK,QAAQ,CAACD,OAAO,CAAC;EAC/B,MAAMH,OAAO,GAAG,CAACG,OAAO,GAAGJ,KAAK,IAAI,EAAE;EACtC,IAAI,CAACzD,GAAG,EAAE;IACR,OAAO,IAAIC,IAAI,CACbF,IAAI,CAAC0B,WAAW,CAAC,CAAC,EAClB1B,IAAI,CAACK,QAAQ,CAAC,CAAC,EACfL,IAAI,CAACM,OAAO,CAAC,CAAC,EACdoD,KAAK,EACLC,OACF,CAAC;EACH,CAAC,MAAM;IACL,OAAO,IAAIzD,IAAI,CACbA,IAAI,CAAC8D,GAAG,CACNhE,IAAI,CAACiE,cAAc,CAAC,CAAC,EACrBjE,IAAI,CAACG,WAAW,CAAC,CAAC,EAClBH,IAAI,CAACI,UAAU,CAAC,CAAC,EACjBsD,KAAK,EACLC,OACF,CACF,CAAC;EACH;AACF,CAAC;;AAED;AACA,OAAO,MAAMO,gBAAgB,GAAG,SAAAA,CAAUC,QAAQ,EAAE;EAClD,OAAO,IAAIjE,IAAI,CAAC6D,QAAQ,CAACI,QAAQ,CAAC3C,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,EAAE,CAAC,GAAG,IAAI,CAAC;AAChE,CAAC;;AAED;AACA,OAAO,MAAMoC,SAAS,GAAIH,UAAU,IAAK;EACvC,MAAM,CAACC,KAAK,EAAEC,OAAO,CAAC,GAAGF,UAAU,CAACW,KAAK,CAAC,GAAG,CAAC;EAC9C,OAAO;IAAEV,KAAK,EAAEK,QAAQ,CAACL,KAAK,CAAC;IAAEC,OAAO,EAAEI,QAAQ,CAACJ,OAAO;EAAE,CAAC;AAC/D,CAAC;;AAED;AACA,OAAO,MAAMU,YAAY,GAAIP,OAAO,IAAK;EACvC,MAAMJ,KAAK,GAAGY,IAAI,CAACC,KAAK,CAACT,OAAO,CAAC;EACjC,MAAMH,OAAO,GAAGW,IAAI,CAACC,KAAK,CAAC,CAACT,OAAO,GAAGJ,KAAK,IAAI,EAAE,CAAC;EAClD,OAAO;IAAEA,KAAK;IAAEC;EAAQ,CAAC;AAC3B,CAAC;;AAED;AACA,OAAO,MAAMzB,gBAAgB,GAAGA,CAAClC,IAAI,EAAEsD,MAAM,KAAK;EAChDtD,IAAI,GAAG,IAAIE,IAAI,CAACF,IAAI,CAAC;EACrB,OAAO,IAAIE,IAAI,CAACF,IAAI,CAACqD,OAAO,CAAC,CAAC,GAAGC,MAAM,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,IAAI,CAAC;AAChE,CAAC;;AAED;AACA,OAAO,MAAMkB,kBAAkB,GAAGA,CAACxE,IAAI,EAAEyE,WAAW,KAAK;EACvD,MAAM;IAAEf,KAAK;IAAEC;EAAQ,CAAC,GAAGU,YAAY,CAACI,WAAW,CAAC;EACpD,MAAMC,OAAO,GAAG,IAAIxE,IAAI,CAACF,IAAI,CAAC;EAC9B0E,OAAO,CAACC,QAAQ,CAACD,OAAO,CAACzC,QAAQ,CAAC,CAAC,GAAGyB,KAAK,CAAC;EAC5CgB,OAAO,CAACE,UAAU,CAACF,OAAO,CAACG,UAAU,CAAC,CAAC,GAAGlB,OAAO,CAAC;EAClD,OAAOe,OAAO;AAChB,CAAC;;AAED;AACA;AACA;AACA;AACA,OAAO,MAAMI,aAAa,GAAGA,CAC3BC,IAAI,EACJ/E,IAAI,EACJgF,UAAU,EACVC,OAAO,GAAG,KAAK,EACfC,aAAa,GAAG,KAAK,KAClB;EACH;EACA;EACA;EACAH,IAAI,GAAG,CAAC,GAAGA,IAAI,CAAC,CAACI,IAAI,CAAC,CAACrD,KAAK,EAAEC,KAAK,KAAK;IACtC,IAAIqD,IAAI,GAAG,IAAIlF,IAAI,CAAC4B,KAAK,CAAC,CAACmB,SAAS,CAAC,CAAC;IACtC,IAAIoC,IAAI,GAAG,IAAInF,IAAI,CAAC6B,KAAK,CAAC,CAACkB,SAAS,CAAC,CAAC;IACtC,IAAIiC,aAAa,EAAE;MACjB,IAAIE,IAAI,KAAK,CAAC,EAAEA,IAAI,GAAG,CAAC;MACxB,IAAIC,IAAI,KAAK,CAAC,EAAEA,IAAI,GAAG,CAAC;IAC1B;IACA,OAAOD,IAAI,GAAGC,IAAI;EACpB,CAAC,CAAC;;EAEF;EACA,MAAMC,SAAS,GAAG,IAAIpF,IAAI,CAAC6E,IAAI,CAAC,CAAC,CAAC,CAAC;EACnCO,SAAS,CAACC,UAAU,CAACD,SAAS,CAAClF,UAAU,CAAC,CAAC,GAAGkF,SAAS,CAACrC,SAAS,CAAC,CAAC,CAAC;;EAEpE;EACA,MAAMuC,SAAS,GAAG,IAAItF,IAAI,CAAC,CAAC;EAC5BsF,SAAS,CAACD,UAAU,CAACC,SAAS,CAACpF,UAAU,CAAC,CAAC,GAAGoF,SAAS,CAACvC,SAAS,CAAC,CAAC,CAAC;EACpEuC,SAAS,CAACD,UAAU,CAACC,SAAS,CAACpF,UAAU,CAAC,CAAC,GAAG,CAAC,GAAG4E,UAAU,CAAC;EAC7DQ,SAAS,CAACC,WAAW,CAACH,SAAS,CAACtD,WAAW,CAAC,CAAC,CAAC;EAC9CwD,SAAS,CAACE,aAAa,CAACJ,SAAS,CAACK,aAAa,CAAC,CAAC,CAAC;EAClDH,SAAS,CAACI,aAAa,CAACN,SAAS,CAACO,aAAa,CAAC,CAAC,CAAC;EAClDL,SAAS,CAACM,kBAAkB,CAACR,SAAS,CAACS,kBAAkB,CAAC,CAAC,CAAC;;EAE5D;EACA,IAAIC,SAAS,GAAG1B,IAAI,CAAC2B,KAAK,CAAC,CAACT,SAAS,GAAGF,SAAS,KAAK,IAAI,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC,CAAC;;EAE3E;EACA,IAAIL,OAAO,EAAE;IACXe,SAAS,IAAI,CAAC,CAAC;EACjB;;EAEA;EACAhG,IAAI,GAAG,IAAIE,IAAI,CAACF,IAAI,CAAC;EACrBA,IAAI,CAACuF,UAAU,CAACvF,IAAI,CAACI,UAAU,CAAC,CAAC,GAAG4F,SAAS,CAAC;EAE9C,OAAOhG,IAAI;AACb,CAAC;;AAED;AACA,OAAO,MAAMkG,iBAAiB,GAAGA,CAACpC,OAAO,EAAEqC,MAAM,GAAG,IAAI,KAAK;EAC3D,MAAMzC,KAAK,GAAGY,IAAI,CAACC,KAAK,CAACT,OAAO,CAAC;EACjC,MAAMsC,cAAc,GAAGtC,OAAO,GAAGJ,KAAK;EACtC,MAAM2C,aAAa,GACjBD,cAAc,GAAG,CAAC,GACb,IAAGzE,MAAM,CAAC2C,IAAI,CAACC,KAAK,CAAC6B,cAAc,GAAG,EAAE,CAAC,CAAC,CAACxE,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAE,EAAC,GAC9D,EAAE;EAER,IAAIuE,MAAM,EAAE;IACV,IAAIrC,OAAO,IAAI,CAAC,IAAIA,OAAO,GAAG,CAAC,EAAE,OAAQ,KAAIuC,aAAc,KAAI,MAC1D,IAAIvC,OAAO,GAAG,EAAE,EAAE,OAAQ,GAAEJ,KAAM,GAAE2C,aAAc,KAAI,MACtD,IAAIvC,OAAO,IAAI,EAAE,IAAIA,OAAO,GAAG,EAAE,EAAE,OAAQ,KAAIuC,aAAc,KAAI;IACtE,OAAQ,GAAE3C,KAAK,GAAG,EAAG,GAAE2C,aAAc,KAAI;EAC3C;EAEA,OAAQ,GAAE3C,KAAM,IAAG2C,aAAa,CAACnD,MAAM,GAAG,CAAC,GAAGmD,aAAa,GAAG,IAAK,EAAC;AACtE,CAAC;;AAED;AACA,OAAO,MAAMC,mBAAmB,GAAIxC,OAAO,IAAK;EAC9C,MAAMJ,KAAK,GAAGY,IAAI,CAACC,KAAK,CAACT,OAAO,CAAC;EACjC,MAAMsC,cAAc,GAAGtC,OAAO,GAAGJ,KAAK;EACtC,MAAM6C,WAAW,GAAG5E,MAAM,CAAC+B,KAAK,CAAC,CAAC9B,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC;EAClD,MAAM4E,aAAa,GAAG7E,MAAM,CAAC2C,IAAI,CAACC,KAAK,CAAC6B,cAAc,GAAG,EAAE,CAAC,CAAC,CAACxE,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC;EAE9E,OAAQ,GAAE2E,WAAY,IAAGC,aAAc,KAAI;AAC7C,CAAC;;AAED;AACA,OAAO,MAAMC,aAAa,GAAGA,CAACzG,IAAI,EAAEC,GAAG,GAAG,KAAK,KAAK;EAClDD,IAAI,GAAG,IAAIE,IAAI,CAACF,IAAI,CAAC;EACrB,IAAIC,GAAG,EAAE;IACP,OAAOD,IAAI,CAACgC,WAAW,CAAC,CAAC,GAAGhC,IAAI,CAAC2F,aAAa,CAAC,CAAC,GAAG,EAAE;EACvD;EACA,OAAO3F,IAAI,CAACiC,QAAQ,CAAC,CAAC,GAAGjC,IAAI,CAAC6E,UAAU,CAAC,CAAC,GAAG,EAAE;AACjD,CAAC;;AAED;AACA,OAAO,MAAM6B,kBAAkB,GAAGA,CAAC1G,IAAI,EAAE8D,OAAO,EAAErB,IAAI,KAAK;EACzD,MAAMkE,IAAI,GAAGF,aAAa,CAACzG,IAAI,CAAC,GAAG8D,OAAO;EAC1C,IAAIrB,IAAI,KAAK,OAAO,IAAIkE,IAAI,GAAG,CAAC,EAAE;IAChC,OAAO9C,kBAAkB,CAAC7D,IAAI,EAAE8D,OAAO,CAAC;EAC1C,CAAC,MAAM,IAAIrB,IAAI,KAAK,OAAO,IAAIkE,IAAI,GAAG,CAAC,EAAE;IACvC,OAAO9C,kBAAkB,CAAC7D,IAAI,EAAE8D,OAAO,CAAC;EAC1C;;EAEA;EACA,OAAO9D,IAAI;AACb,CAAC;;AAED;AACA,OAAO,MAAM4G,WAAW,GAAGA,CAAC9E,KAAK,EAAEC,KAAK,KAAK;EAC3CD,KAAK,GAAG,IAAI5B,IAAI,CAAC4B,KAAK,CAAC;EACvBC,KAAK,GAAG,IAAI7B,IAAI,CAAC6B,KAAK,CAAC;EACvB,OAAOD,KAAK,CAACuB,OAAO,CAAC,CAAC,GAAGtB,KAAK,CAACsB,OAAO,CAAC,CAAC;AAC1C,CAAC;;AAED;AACA,OAAO,MAAMwD,aAAa,GAAGA,CAAC7G,IAAI,EAAEQ,SAAS,EAAEC,OAAO,KAAK;EACzDT,IAAI,GAAG,IAAIE,IAAI,CAACF,IAAI,CAAC,CAACqD,OAAO,CAAC,CAAC;EAC/B7C,SAAS,GAAG,IAAIN,IAAI,CAACM,SAAS,CAAC,CAAC6C,OAAO,CAAC,CAAC;EACzC5C,OAAO,GAAG,IAAIP,IAAI,CAACO,OAAO,CAAC,CAAC4C,OAAO,CAAC,CAAC;EACrC,OAAOrD,IAAI,IAAIQ,SAAS,IAAIR,IAAI,IAAIS,OAAO;AAC7C,CAAC;;AAED;AACA,OAAO,MAAMqG,cAAc,GAAGA,CAAChG,KAAK,EAAEW,IAAI,KAAK;EAC7C,OAAO,IAAIvB,IAAI,CAACuB,IAAI,EAAEX,KAAK,EAAE,CAAC,CAAC,CAACR,OAAO,CAAC,CAAC;AAC3C,CAAC;;AAED;AACA,OAAO,MAAMyG,cAAc,GAAGA,CAACC,CAAC,EAAEC,CAAC,KAAK;EACtCD,CAAC,GAAG,IAAI9G,IAAI,CAAC8G,CAAC,CAAC;EACfC,CAAC,GAAG,IAAI/G,IAAI,CAAC+G,CAAC,CAAC;EACf,IAAID,CAAC,CAACtF,WAAW,CAAC,CAAC,KAAKuF,CAAC,CAACvF,WAAW,CAAC,CAAC,EAAE;IACvC,OAAOsF,CAAC,CAACtF,WAAW,CAAC,CAAC,GAAGuF,CAAC,CAACvF,WAAW,CAAC,CAAC;EAC1C,CAAC,MAAM,IAAIsF,CAAC,CAAC3G,QAAQ,CAAC,CAAC,KAAK4G,CAAC,CAAC5G,QAAQ,CAAC,CAAC,EAAE;IACxC,OAAO2G,CAAC,CAAC3G,QAAQ,CAAC,CAAC,GAAG4G,CAAC,CAAC5G,QAAQ,CAAC,CAAC;EACpC,CAAC,MAAM;IACL,OAAO2G,CAAC,CAAC1G,OAAO,CAAC,CAAC,GAAG2G,CAAC,CAAC3G,OAAO,CAAC,CAAC;EAClC;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,OAAO,MAAM4G,qBAAqB,GAAGA,CAACpD,OAAO,EAAEhC,KAAK,EAAEC,KAAK,KAAK;EAC9D,MAAMoF,KAAK,GAAGrF,KAAK,CAACG,QAAQ,CAAC,CAAC;EAC9B,MAAMmF,KAAK,GAAGrF,KAAK,CAACE,QAAQ,CAAC,CAAC;EAE9B,IAAIkF,KAAK,IAAIC,KAAK,EAAE;IAClB,OAAOD,KAAK,IAAIrD,OAAO,IAAIA,OAAO,IAAIsD,KAAK;EAC7C,CAAC,MAAM;IACL,OACGD,KAAK,IAAIrD,OAAO,IAAIA,OAAO,GAAG,EAAE,IAAM,CAAC,IAAIA,OAAO,IAAIA,OAAO,IAAIsD,KAAM;EAE5E;AACF,CAAC;;AAED;AACA,OAAO,MAAMC,aAAa,GAAGA,CAACrH,IAAI,EAAEQ,SAAS,EAAE8G,QAAQ,KAAK;EAC1D,MAAM7G,OAAO,GAAG,IAAIP,IAAI,CAACM,SAAS,CAAC;EACnCC,OAAO,CAACkE,QAAQ,CAAClE,OAAO,CAACwB,QAAQ,CAAC,CAAC,GAAGqF,QAAQ,CAAC;EAC/C,OAAO9G,SAAS,IAAIR,IAAI,IAAIA,IAAI,IAAIS,OAAO;AAC7C,CAAC;;AAED;AACA,OAAO,MAAM8G,kBAAkB,GAAGA,CAChCzD,OAAO,EACP0D,cAAc,GAAG,IAAItH,IAAI,CAAC,CAAC,CAACqD,iBAAiB,CAAC,CAAC,KAC5C;EACH,IAAIkE,YAAY,GAAG3D,OAAO,GAAG0D,cAAc,GAAG,EAAE;EAChDC,YAAY,IAAI,EAAE;EAClB,IAAIA,YAAY,GAAG,CAAC,EAAEA,YAAY,IAAI,EAAE;EAExC,OAAOA,YAAY;AACrB,CAAC;;AAED;AACA,OAAO,MAAMC,kBAAkB,GAAGA,CAAA,KAAM;EACtC,OAAO,IAAIxH,IAAI,CAAC,CAAC,CACdyH,kBAAkB,CAAC,OAAO,EAAE;IAAEtG,YAAY,EAAE;EAAQ,CAAC,CAAC,CACtD+C,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;AAClB,CAAC;;AAED;AACA;AACA;AACA,OAAO,MAAMwD,SAAS,GAAGA,CAAA,KAAM;EAC7B,IAAIC,SAAS,CAACC,SAAS,IAAIC,SAAS,EAAE,OAAOF,SAAS,CAACC,SAAS,CAAC,CAAC,CAAC;EACnE,OAAOD,SAAS,CAACG,QAAQ;AAC3B,CAAC;;AAED;AACA,OAAO,MAAMC,cAAc,GAAGA,CAAA,KAAM;EAClC,OAAOC,IAAI,CAACC,cAAc,CAACP,SAAS,CAAC,CAAC,EAAE;IAAE1G,IAAI,EAAE;EAAU,CAAC,CAAC,CAACkH,eAAe,CAAC,CAAC,CAC3EjC,MAAM;AACX,CAAC;;AAED;AACA,OAAO,MAAMkC,cAAc,GAAGA,CAAA,KAAM;EAClC,MAAMC,UAAU,GAAG,CAAChG,YAAY,CAAC,UAAU,CAAC,GACxC2F,cAAc,CAAC,CAAC,GAChB3F,YAAY,CAAC,UAAU,CAAC,KAAK1C,SAAS,CAAC2I,MAAM;EAEjD,MAAMC,KAAK,GAAG,EAAE;EAChB,IAAIF,UAAU,EAAE;IACdE,KAAK,CAACC,IAAI,CAAC;MAAEC,IAAI,EAAE,OAAO;MAAEC,IAAI,EAAE,CAAC;MAAEC,KAAK,EAAE;IAAE,CAAC,CAAC;IAChD,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,EAAE,EAAE,EAAEA,CAAC,EAAE;MAC3BL,KAAK,CAACC,IAAI,CAAC;QAAEC,IAAI,EAAG,GAAEG,CAAE,KAAI;QAAEF,IAAI,EAAEE,CAAC;QAAED,KAAK,EAAEC;MAAE,CAAC,CAAC;IACpD;IACA,KAAK,IAAIA,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,EAAE,EAAE,EAAEA,CAAC,EAAE;MAC3BL,KAAK,CAACC,IAAI,CAAC;QAAEC,IAAI,EAAG,GAAEG,CAAC,IAAI,CAAC,GAAG,EAAE,GAAGA,CAAE,KAAI;QAAEF,IAAI,EAAEE,CAAC,GAAG,EAAE;QAAED,KAAK,EAAEC,CAAC,GAAG;MAAG,CAAC,CAAC;IAC5E;IACAL,KAAK,CAACC,IAAI,CAAC;MAAEC,IAAI,EAAE,OAAO;MAAEC,IAAI,EAAE,CAAC;MAAEC,KAAK,EAAE;IAAG,CAAC,CAAC;IAEjD,OAAOJ,KAAK;EACd;EAEA,KAAK,IAAIK,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,EAAE,EAAE,EAAEA,CAAC,EAAE;IAC3BL,KAAK,CAACC,IAAI,CAAC;MAAEC,IAAI,EAAG,GAAEG,CAAE,KAAI;MAAEF,IAAI,EAAEE,CAAC;MAAED,KAAK,EAAEC;IAAE,CAAC,CAAC;EACpD;EACAL,KAAK,CAACC,IAAI,CAAC;IAAEC,IAAI,EAAE,MAAM;IAAEC,IAAI,EAAE,CAAC;IAAEC,KAAK,EAAE;EAAG,CAAC,CAAC;EAChD,OAAOJ,KAAK;AACd,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMM,oBAAoB,GAAG,MAAAA,CAClC1G,KAAK,EACL;EAAE4C,UAAU,GAAG,CAAC;EAAE+D,OAAO,GAAG;AAAG,CAAC,KAC7B;EACH,IAAIC,OAAO,EAAEC,OAAO;EACpB,IAAI7G,KAAK,CAACK,IAAI,KAAK9C,UAAU,CAACwD,cAAc,EAAE;IAC5C;IACA6F,OAAO,GAAG,IAAI9I,IAAI,CAACkC,KAAK,CAACU,KAAK,CAAC,CAAC,CAAC,CAAC,CAACvB,WAAW,CAAC,CAAC;IAChD0H,OAAO,GAAG/G,gBAAgB,CACxB,IAAIhC,IAAI,CAACkC,KAAK,CAACU,KAAK,CAACV,KAAK,CAACU,KAAK,CAACI,MAAM,GAAG,CAAC,CAAC,CAAC,EAC7C,CACF,CAAC,CAAC3B,WAAW,CAAC,CAAC;EACjB,CAAC,MAAM,IAAIa,KAAK,CAACK,IAAI,KAAK9C,UAAU,CAAC+C,GAAG,IAAIN,KAAK,CAACK,IAAI,KAAK9C,UAAU,CAACgD,KAAK,EAAE;IAC3E;IACA,MAAMuG,SAAS,GAAGpE,aAAa,CAC7B1C,KAAK,CAACU,KAAK,EACXV,KAAK,CAACU,KAAK,CAAC,CAAC,CAAC,EACdkC,UAAU,EACV,IAAI,EACJ5C,KAAK,CAAC8C,aACR,CAAC;IACD,MAAMiE,QAAQ,GAAGrE,aAAa,CAC5B1C,KAAK,CAACU,KAAK,EACXV,KAAK,CAACU,KAAK,CAACV,KAAK,CAACU,KAAK,CAACI,MAAM,GAAG,CAAC,CAAC,EACnC8B,UAAU,EACV,IAAI,EACJ5C,KAAK,CAAC8C,aACR,CAAC;IACD8D,OAAO,GAAG9G,gBAAgB,CAACgH,SAAS,EAAE,CAAC,CAAC,CAAC,CAAC3H,WAAW,CAAC,CAAC;IACvD0H,OAAO,GAAG/G,gBAAgB,CAACiH,QAAQ,EAAE,CAAC,CAAC,CAAC5H,WAAW,CAAC,CAAC;EACvD;;EAEA;EACA,IAAI6H,iBAAiB;EACrB,IAAIL,OAAO,CAAC7F,MAAM,KAAK,CAAC,EAAE;IACxBkG,iBAAiB,GAAG,MAAMvJ,GAAG,CAC1B,2BAA0BmJ,OAAQ,YAAWC,OAAQ,EACxD,CAAC;EACH,CAAC,MAAM;IACLG,iBAAiB,GAAG,MAAMvJ,GAAG,CAC1B,WAAUkJ,OAAQ,oCAAmCC,OAAQ,YAAWC,OAAQ,EACnF,CAAC;EACH;EAEA,OAAOG,iBAAiB;AAC1B,CAAC;;AAED;AACA;AACA;AACA,OAAO,MAAMC,YAAY,GAAGA,CAACrJ,IAAI,EAAEyE,WAAW,EAAE6E,WAAW,KAAK;EAC9D,MAAM9I,SAAS,GAAG,IAAIN,IAAI,CAACF,IAAI,CAACqD,OAAO,CAAC,CAAC,GAAGoB,WAAW,GAAG,EAAE,GAAG,EAAE,GAAG,IAAI,CAAC;EACzE,MAAMhE,OAAO,GAAG,IAAIP,IAAI,CAACM,SAAS,CAAC6C,OAAO,CAAC,CAAC,GAAGiG,WAAW,GAAG,EAAE,GAAG,EAAE,GAAG,IAAI,CAAC;EAC5E,OAAO;IACL9I,SAAS,EAAEA,SAAS;IACpBC,OAAO,EAAEA;EACX,CAAC;AACH,CAAC;;AAED;AACA;AACA;AACA,OAAO,MAAM8I,oBAAoB,GAAGA,CAClCnH,KAAK,EACLoH,UAAU,EACVxE,UAAU,GAAG,CAAC,EACdwC,cAAc,GAAG,IAAI,KAClB;EACH,OAAOiC,iBAAiB,CACtBrH,KAAK,CAACU,KAAK,EACXV,KAAK,CAACkF,QAAQ,EACdkC,UAAU,EACVpH,KAAK,CAACK,IAAI,EACVuC,UAAU,EACV5C,KAAK,CAAC8C,aAAa,EACnBsC,cACF,CAAC;AACH,CAAC;;AAED;AACA,OAAO,MAAMiC,iBAAiB,GAAGA,CAC/B3G,KAAK,EACLwE,QAAQ,EACRkC,UAAU,EACVE,SAAS,GAAG/J,UAAU,CAACwD,cAAc,EACrC6B,UAAU,GAAG,CAAC,EACdE,aAAa,GAAG,KAAK,EACrBsC,cAAc,GAAG,CAAC,KACf;EACH;EACAgC,UAAU,GAAGjH,IAAI,CAACC,KAAK,CAACD,IAAI,CAACoH,SAAS,CAACH,UAAU,CAAC,CAAC,EAAC;EACpDA,UAAU,GAAGA,UAAU,CAACI,GAAG,CAAEC,CAAC,IAAK;IACjC,IAAIH,SAAS,KAAK/J,UAAU,CAAC+C,GAAG,IAAIgH,SAAS,KAAK/J,UAAU,CAACgD,KAAK,EAAE;MAClEkH,CAAC,CAACrJ,SAAS,GAAGsE,aAAa,CACzBhC,KAAK,EACL+G,CAAC,CAACrJ,SAAS,EACXwE,UAAU,EACV,KAAK,EACLE,aACF,CAAC;MACD2E,CAAC,CAACpJ,OAAO,GAAGqE,aAAa,CACvBhC,KAAK,EACL+G,CAAC,CAACpJ,OAAO,EACTuE,UAAU,EACV,KAAK,EACLE,aACF,CAAC;IACH,CAAC,MAAM;MACL2E,CAAC,CAACrJ,SAAS,GAAG,IAAIN,IAAI,CAAC2J,CAAC,CAACrJ,SAAS,CAAC;MACnCqJ,CAAC,CAACpJ,OAAO,GAAG,IAAIP,IAAI,CAAC2J,CAAC,CAACpJ,OAAO,CAAC;IACjC;IACA,OAAOoJ,CAAC;EACV,CAAC,CAAC;EACFL,UAAU,CAACrE,IAAI,CAAC,CAAC6B,CAAC,EAAEC,CAAC,KAAKL,WAAW,CAACI,CAAC,CAACxG,SAAS,EAAEyG,CAAC,CAACzG,SAAS,CAAC,CAAC;;EAEhE;EACA,MAAMsJ,UAAU,GAAG,IAAIC,GAAG,CAAC,CAAC;EAC5B,MAAMC,eAAe,GAAG,EAAE;EAC1B,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGnH,KAAK,CAACI,MAAM,EAAE,EAAE+G,CAAC,EAAE;IACrCD,eAAe,CAACC,CAAC,CAAC,GAAG,EAAE;IACvB,MAAMjK,IAAI,GAAG,IAAIE,IAAI,CAAC4C,KAAK,CAACmH,CAAC,CAAC,CAAC;IAC/BH,UAAU,CAACI,GAAG,CAAClK,IAAI,CAACqD,OAAO,CAAC,CAAC,CAAC;EAChC;;EAEA;EACA,IAAI4G,CAAC,GAAG,CAAC;EACT,KAAK,MAAMjK,IAAI,IAAI8C,KAAK,EAAE;IACxB,IAAI0G,UAAU,CAACtG,MAAM,IAAI,CAAC,EAAE;IAE5B,MAAMiH,KAAK,GAAG,IAAIjK,IAAI,CAACF,IAAI,CAAC;IAC5B,MAAMoK,GAAG,GAAG,IAAIlK,IAAI,CAACiK,KAAK,CAAC;IAC3BC,GAAG,CAACzF,QAAQ,CAACwF,KAAK,CAAClI,QAAQ,CAAC,CAAC,GAAGqF,QAAQ,CAAC;IAEzC,MAAM+C,aAAa,GAAG,IAAInK,IAAI,CAACiK,KAAK,CAAC9G,OAAO,CAAC,CAAC,GAAGmE,cAAc,GAAG,EAAE,GAAG,IAAI,CAAC;IAC5E,MAAM8C,WAAW,GAAG,IAAIpK,IAAI,CAACkK,GAAG,CAAC/G,OAAO,CAAC,CAAC,GAAGmE,cAAc,GAAG,EAAE,GAAG,IAAI,CAAC;;IAExE;IACA,OAAOgC,UAAU,CAACtG,MAAM,GAAG,CAAC,IAAIkH,GAAG,GAAGZ,UAAU,CAAC,CAAC,CAAC,CAAChJ,SAAS,EAAE;MAC7D,IAAI,CAAC+J,aAAa,CAAC,GAAGf,UAAU,CAACgB,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC;;MAE7C;MACA,MAAMC,oBAAoB,GAAG3K,SAAS,CACpCyK,aAAa,CAAC/J,SAAS,EACvB2J,KAAK,EACLC,GACF,CAAC;MACD,MAAMM,kBAAkB,GAAG5K,SAAS,CAACyK,aAAa,CAAC9J,OAAO,EAAE0J,KAAK,EAAEC,GAAG,CAAC;MACvE,MAAMO,wBAAwB,GAC5B7K,SAAS,CAACqK,KAAK,EAAEI,aAAa,CAAC/J,SAAS,EAAE+J,aAAa,CAAC9J,OAAO,CAAC,IAChEX,SAAS,CAACsK,GAAG,EAAEG,aAAa,CAAC/J,SAAS,EAAE+J,aAAa,CAAC9J,OAAO,CAAC;MAChE,IACEgK,oBAAoB,IACpBC,kBAAkB,IAClBC,wBAAwB,EACxB;QACA,MAAMC,6BAA6B,GAAG9K,SAAS,CAC7CqK,KAAK,EACLI,aAAa,CAAC/J,SAAS,EACvB+J,aAAa,CAAC9J,OAChB,CAAC;QACD,MAAMoK,2BAA2B,GAAG/K,SAAS,CAC3CsK,GAAG,EACHG,aAAa,CAAC/J,SAAS,EACvB+J,aAAa,CAAC9J,OAChB,CAAC;QACD,IAAImK,6BAA6B,EAAE;UACjC;UACAL,aAAa,GAAG;YAAE,GAAGA,aAAa;YAAE/J,SAAS,EAAE2J;UAAM,CAAC;QACxD;QACA,IAAIU,2BAA2B,EAAE;UAC/B;UACA,MAAMC,kBAAkB,GAAG;YAAE,GAAGP,aAAa;YAAE/J,SAAS,EAAE4J;UAAI,CAAC;UAC/DZ,UAAU,CAACgB,MAAM,CAAC,CAAC,EAAE,CAAC,EAAEM,kBAAkB,CAAC;UAC3CtB,UAAU,CAACrE,IAAI,CAAC,CAAC6B,CAAC,EAAEC,CAAC,KAAKL,WAAW,CAACI,CAAC,CAACxG,SAAS,EAAEyG,CAAC,CAACzG,SAAS,CAAC,CAAC;UAChE;UACA+J,aAAa,GAAG;YAAE,GAAGA,aAAa;YAAE9J,OAAO,EAAE2J;UAAI,CAAC;QACpD;;QAEA;QACA,MAAM3F,WAAW,GACf,CAAC8F,aAAa,CAAC/J,SAAS,CAAC6C,OAAO,CAAC,CAAC,GAAG8G,KAAK,CAAC9G,OAAO,CAAC,CAAC,KACnD,IAAI,GAAG,EAAE,GAAG,EAAE,CAAC;;QAElB;QACA,MAAMiG,WAAW,GACf,CAACiB,aAAa,CAAC9J,OAAO,CAAC4C,OAAO,CAAC,CAAC,GAC9BkH,aAAa,CAAC/J,SAAS,CAAC6C,OAAO,CAAC,CAAC,KAClC,IAAI,GAAG,EAAE,GAAG,EAAE,CAAC;;QAElB;QACA,IAAIiG,WAAW,IAAI,CAAC,EAAE;;QAEtB;QACA;QACA,MAAMyB,UAAU,GAAG,IAAI7K,IAAI,CACzBqK,aAAa,CAAC/J,SAAS,CAAC6C,OAAO,CAAC,CAAC,GAAGmE,cAAc,GAAG,EAAE,GAAG,IAC5D,CAAC;QACD,MAAMwD,QAAQ,GAAG,IAAI9K,IAAI,CACvBqK,aAAa,CAAC9J,OAAO,CAAC4C,OAAO,CAAC,CAAC,GAAGmE,cAAc,GAAG,EAAE,GAAG,IAC1D,CAAC;QACD,IAAIuD,UAAU,CAAC3K,UAAU,CAAC,CAAC,KAAK4K,QAAQ,CAAC5K,UAAU,CAAC,CAAC,EAAE;UACrD;UACA,IAAI6K,SAAS,GAAG,IAAI/K,IAAI,CAAC6K,UAAU,CAAC;UACpCE,SAAS,CAAC1F,UAAU,CAAC0F,SAAS,CAAC7K,UAAU,CAAC,CAAC,GAAG,CAAC,CAAC;UAChD6K,SAAS,CAACxF,WAAW,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;UACjCwF,SAAS,CAAC7H,OAAO,CAAC6H,SAAS,CAAC5H,OAAO,CAAC,CAAC,GAAGmE,cAAc,GAAG,EAAE,GAAG,IAAI,CAAC;UACnE,MAAM0D,cAAc,GAAG;YACrB,GAAGX,aAAa;YAChBY,EAAE,EAAEZ,aAAa,CAACY,EAAE,GAAG,IAAI;YAC3B1K,OAAO,EAAEwK,SAAS;YAClBxG,WAAW,EAAEA,WAAW;YACxB6E,WAAW,EAAEA;UACf,CAAC;UACD,MAAM8B,gBAAgB,GACpB,CAACF,cAAc,CAACzK,OAAO,CAAC4C,OAAO,CAAC,CAAC,GAC/B6H,cAAc,CAAC1K,SAAS,CAAC6C,OAAO,CAAC,CAAC,KACnC,IAAI,GAAG,EAAE,GAAG,EAAE,CAAC;UAClB,MAAMgI,eAAe,GAAG;YACtB,GAAGd,aAAa;YAChBY,EAAE,EAAEZ,aAAa,CAACY,EAAE,GAAG,IAAI;YAC3B3K,SAAS,EAAEyK,SAAS;YACpBxG,WAAW,EAAEA,WAAW,GAAG2G,gBAAgB;YAC3C9B,WAAW,EAAEA,WAAW,GAAG8B;UAC7B,CAAC;UACD,MAAME,iBAAiB,GACrB,CAACD,eAAe,CAAC5K,OAAO,CAAC4C,OAAO,CAAC,CAAC,GAChCgI,eAAe,CAAC7K,SAAS,CAAC6C,OAAO,CAAC,CAAC,KACpC,IAAI,GAAG,EAAE,GAAG,EAAE,CAAC;UAClB2G,eAAe,CAACC,CAAC,CAAC,CAACxB,IAAI,CAAC;YACtB,GAAGyC,cAAc;YACjBzG,WAAW,EAAEA,WAAW;YACxB6E,WAAW,EAAE8B;UACf,CAAC,CAAC;UACF,IAAInB,CAAC,GAAG,CAAC,IAAID,eAAe,CAAC9G,MAAM,EAAE;YACnC8G,eAAe,CAACvB,IAAI,CAAC,EAAE,CAAC;UAC1B;UACAuB,eAAe,CAACC,CAAC,GAAG,CAAC,CAAC,CAACxB,IAAI,CAAC;YAC1B,GAAG4C,eAAe;YAClB5G,WAAW,EAAEA,WAAW,GAAG2G,gBAAgB;YAC3C9B,WAAW,EAAEgC;UACf,CAAC,CAAC;UACF;QACF,CAAC,MAAM,IAAIjB,aAAa,CAACjK,UAAU,CAAC,CAAC,KAAK2K,UAAU,CAAC3K,UAAU,CAAC,CAAC,EAAE;UACjE;UACA,IAAI6J,CAAC,GAAG,CAAC,IAAID,eAAe,CAAC9G,MAAM,EAAE;YACnC8G,eAAe,CAACvB,IAAI,CAAC,EAAE,CAAC;UAC1B;UACAuB,eAAe,CAACC,CAAC,GAAG,CAAC,CAAC,CAACxB,IAAI,CAAC;YAC1B,GAAG8B,aAAa;YAChB9F,WAAW;YACX6E;UACF,CAAC,CAAC;UACF;QACF;QAEAU,eAAe,CAACC,CAAC,CAAC,CAACxB,IAAI,CAAC;UACtB,GAAG8B,aAAa;UAChB9F,WAAW;UACX6E;QACF,CAAC,CAAC;MACJ;IACF;;IAEA;IACA,IAAIe,aAAa,CAACjK,UAAU,CAAC,CAAC,KAAKkK,WAAW,CAAClK,UAAU,CAAC,CAAC,EAAE;MAC3D,MAAMmL,QAAQ,GAAG,IAAIrL,IAAI,CAACiK,KAAK,CAAC;MAChCoB,QAAQ,CAAChG,UAAU,CAACgG,QAAQ,CAACnL,UAAU,CAAC,CAAC,GAAG,CAAC,CAAC;MAC9C,IAAI,CAAC0J,UAAU,CAAC0B,GAAG,CAACD,QAAQ,CAAClI,OAAO,CAAC,CAAC,CAAC,EAAE;QACvC;QACA2G,eAAe,CAACvB,IAAI,CAAC,EAAE,CAAC;QACxBwB,CAAC,IAAI,CAAC;MACR;IACF;IACAA,CAAC,EAAE;EACL;EAEA,OAAOD,eAAe;AACxB,CAAC;AAED,OAAO,MAAMyB,qBAAqB,GAAGA,CAACC,KAAK,EAAEC,YAAY,KAAK;EAC5D,OAAQ,GAAED,KAAM,IAAGC,YAAa,EAAC;AACnC,CAAC;AAED,OAAO,MAAMC,iBAAiB,GAAI5L,IAAI,IAAK;EACzC,MAAM6L,GAAG,GAAG,IAAI3L,IAAI,CAACF,IAAI,CAAC0B,WAAW,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;EAC9C,MAAMoK,GAAG,GAAG,IAAI5L,IAAI,CAACF,IAAI,CAAC0B,WAAW,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;EAC9C,OAAO4C,IAAI,CAACyH,GAAG,CAACF,GAAG,CAACtI,iBAAiB,CAAC,CAAC,EAAEuI,GAAG,CAACvI,iBAAiB,CAAC,CAAC,CAAC;AACnE,CAAC;AAED,OAAO,MAAMyI,aAAa,GAAIhM,IAAI,IAAK;EACrC,OAAOA,IAAI,CAACuD,iBAAiB,CAAC,CAAC,GAAGqI,iBAAiB,CAAC5L,IAAI,CAAC;AAC3D,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}