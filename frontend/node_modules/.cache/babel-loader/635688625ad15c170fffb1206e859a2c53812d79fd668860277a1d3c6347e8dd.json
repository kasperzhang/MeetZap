{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport UserAvatarContent from \"@/components/UserAvatarContent.vue\";\nimport UserChip from \"@/components/general/UserChip.vue\";\nimport { validateEmail, get, post } from \"@/utils\";\nexport default {\n  name: \"EmailReminders\",\n  props: {\n    addedEmails: {\n      type: Array,\n      default: () => []\n    }\n  },\n  data: () => ({\n    remindees: [],\n    // Currently displayed emails\n    searchedContacts: [],\n    // Contacts that match the search query\n    timeout: null,\n    // Timeout for search debouncing\n    searchDebounceTime: 250,\n    // Search debounce time in ms\n\n    hasContactsAccess: true,\n    query: \"\",\n    emailsAreValid: true // Whether all emails are valid\n  }),\n  mounted() {\n    // Send a warmup request to update cache and check if contacts permissions are enabled\n    get(`/user/searchContacts?query=`).catch(err => {\n      // User has not granted contacts permissions\n      if (err.error?.code === 403 || err.error?.code === 401) {\n        this.hasContactsAccess = false;\n      }\n    });\n    this.remindees = this.addedEmails;\n  },\n  methods: {\n    /**\n     * Requests access to contacts.\n     */\n    requestContactsAccess() {\n      this.$emit(\"requestContactsAccess\", {\n        emails: this.remindees\n      });\n    },\n    /**\n     * Searches contacts based on the query string if the user has access to contacts.\n     */\n    searchContacts() {\n      if (this.hasContactsAccess) {\n        if (this.timeout) clearTimeout(this.timeout);\n        this.timeout = setTimeout(() => {\n          get(`/user/searchContacts?query=${this.query}`).then(results => {\n            this.searchedContacts = results;\n            this.searchedContacts.map(contact => {\n              contact[\"queryString\"] = this.contactToQueryString(contact);\n            });\n          });\n        }, this.searchDebounceTime);\n      }\n    },\n    /**\n     * Removes the specified email from the remindees list.\n     */\n    removeEmail(email) {\n      // this.remindees.splice(this.remindees.indexOf(email), 1)\n\n      for (let i = 0; i < this.remindees.length; i++) {\n        if (this.isContact(this.remindees[i])) {\n          if (this.remindees[i].email == email) {\n            this.remindees.splice(i, 1);\n          }\n        } else {\n          if (this.remindees[i] == email) {\n            this.remindees.splice(i, 1);\n          }\n        }\n      }\n    },\n    /**\n     * Check if the contact is an object and not a user inputed string.\n     */\n    isContact(contact) {\n      return typeof contact === \"object\";\n    },\n    /**\n     * Takes a contact object and converts it to a query string.\n     */\n    contactToQueryString(contact) {\n      // Need to split first name to get rid of middle name\n      return `${contact[\"firstName\"].split(\" \")[0]} ${contact[\"lastName\"]} ${contact[\"email\"]}`;\n    },\n    /**\n     * Determines if emails are all valid.\n     */\n    validEmails(emails) {\n      for (const email of emails) {\n        if (email?.length > 0 && !validateEmail(email)) {\n          this.emailsAreValid = false;\n          return \"Please enter a valid email.\";\n        }\n      }\n      this.emailsAreValid = true;\n      return true;\n    },\n    reset() {\n      this.remindees = this.addedEmails;\n    }\n  },\n  watch: {\n    remindees() {\n      this.$emit(\"update:emails\", this.remindees.map(r => this.isContact(r) ? r.email : r));\n    },\n    query() {\n      if (this.query && this.query.length > 0) {\n        if (/[,\\s]/.test(this.query)) {\n          /** If the query has spaces or commas, add the valid emails to the list */\n          let successfullyAdded = false;\n          const emailsArray = this.query.split(/[,\\s]+/).filter(email => email.trim() !== \"\");\n          emailsArray.forEach(email => {\n            if (validateEmail(email) && !this.remindees.includes(email)) {\n              successfullyAdded = true;\n              this.remindees.push(email);\n            }\n          });\n          if (successfullyAdded) {\n            this.query = \"\";\n            return;\n          }\n        }\n        this.searchContacts();\n      } else {\n        clearTimeout(this.timeout);\n        this.searchedContacts = [];\n      }\n    }\n  },\n  computed: {},\n  components: {\n    UserAvatarContent,\n    UserChip\n  }\n};","map":{"version":3,"names":["UserAvatarContent","UserChip","validateEmail","get","post","name","props","addedEmails","type","Array","default","data","remindees","searchedContacts","timeout","searchDebounceTime","hasContactsAccess","query","emailsAreValid","mounted","catch","err","error","code","methods","requestContactsAccess","$emit","emails","searchContacts","clearTimeout","setTimeout","then","results","map","contact","contactToQueryString","removeEmail","email","i","length","isContact","splice","split","validEmails","reset","watch","r","test","successfullyAdded","emailsArray","filter","trim","forEach","includes","push","computed","components"],"sources":["src/components/event/EmailInput.vue"],"sourcesContent":["<template>\n  <div>\n    <slot name=\"header\"></slot>\n\n    <v-combobox\n      v-model=\"remindees\"\n      :search-input.sync=\"query\"\n      :items=\"searchedContacts\"\n      item-text=\"queryString\"\n      item-value=\"queryString\"\n      class=\"tw-mt-2 tw-text-sm\"\n      placeholder=\"Type an email address and press enter...\"\n      multiple\n      append-icon=\"\"\n      solo\n      :rules=\"[validEmails]\"\n    >\n      <template v-slot:selection=\"data, parent\">\n        <UserChip\n          :user=\"\n            isContact(data.item) ? data.item : { email: data.item, picture: '' }\n          \"\n          :removable=\"true\"\n          :removeEmail=\"removeEmail\"\n        ></UserChip>\n      </template>\n      <template v-slot:item=\"{ item }\">\n        <v-list-item-avatar>\n          <img\n            v-if=\"item.picture.length > 0\"\n            :src=\"item.picture\"\n            referrerpolicy=\"no-referrer\"\n          />\n          <v-icon v-else>mdi-account</v-icon>\n        </v-list-item-avatar>\n        <v-list-item-content>\n          <v-list-item-title\n            v-text=\"`${item.firstName} ${item.lastName}`\"\n          ></v-list-item-title>\n          <v-list-item-subtitle v-text=\"item.email\"></v-list-item-subtitle>\n        </v-list-item-content>\n      </template>\n    </v-combobox>\n\n    <div class=\"tw-transition-all tw-relative\" :class=\"emailsAreValid ? '-tw-mt-5' : ''\" @click=\"requestContactsAccess\">\n      <v-expand-transition>\n        <div class=\"tw-text-xs tw-text-dark-gray\" v-if=\"!hasContactsAccess\">\n          <a class=\"tw-underline\" @click=\"requestContactsAccess\"\n            >Enable contacts access</a\n          >\n          for email auto-suggestions.\n        </div>\n      </v-expand-transition>\n    </div>\n  </div>\n</template>\n\n<script>\nimport UserAvatarContent from \"@/components/UserAvatarContent.vue\"\nimport UserChip from \"@/components/general/UserChip.vue\"\nimport { validateEmail, get, post } from \"@/utils\"\n\nexport default {\n  name: \"EmailReminders\",\n\n  props: {\n    addedEmails: {\n      type: Array,\n      default: () => [],\n    },\n  },\n\n  data: () => ({\n    remindees: [], // Currently displayed emails\n    searchedContacts: [], // Contacts that match the search query\n    timeout: null, // Timeout for search debouncing\n    searchDebounceTime: 250, // Search debounce time in ms\n\n    hasContactsAccess: true,\n    query: \"\",\n\n    emailsAreValid: true, // Whether all emails are valid\n  }),\n\n  mounted() {\n    // Send a warmup request to update cache and check if contacts permissions are enabled\n    get(`/user/searchContacts?query=`).catch((err) => {\n      // User has not granted contacts permissions\n      if (err.error?.code === 403 || err.error?.code === 401) {\n        this.hasContactsAccess = false\n      }\n    })\n\n    this.remindees = this.addedEmails\n  },\n\n  methods: {\n    /**\n     * Requests access to contacts.\n     */\n    requestContactsAccess() {\n      this.$emit(\"requestContactsAccess\", {\n        emails: this.remindees,\n      })\n    },\n    /**\n     * Searches contacts based on the query string if the user has access to contacts.\n     */\n    searchContacts() {\n      if (this.hasContactsAccess) {\n        if (this.timeout) clearTimeout(this.timeout)\n        this.timeout = setTimeout(() => {\n          get(`/user/searchContacts?query=${this.query}`).then((results) => {\n            this.searchedContacts = results\n            this.searchedContacts.map((contact) => {\n              contact[\"queryString\"] = this.contactToQueryString(contact)\n            })\n          })\n        }, this.searchDebounceTime)\n      }\n    },\n    /**\n     * Removes the specified email from the remindees list.\n     */\n    removeEmail(email) {\n      // this.remindees.splice(this.remindees.indexOf(email), 1)\n\n      for (let i = 0; i < this.remindees.length; i++) {\n        if (this.isContact(this.remindees[i])) {\n          if (this.remindees[i].email == email) {\n            this.remindees.splice(i, 1)\n          }\n        } else {\n          if (this.remindees[i] == email) {\n            this.remindees.splice(i, 1)\n          }\n        }\n      }\n    },\n    /**\n     * Check if the contact is an object and not a user inputed string.\n     */\n    isContact(contact) {\n      return typeof contact === \"object\"\n    },\n    /**\n     * Takes a contact object and converts it to a query string.\n     */\n    contactToQueryString(contact) {\n      // Need to split first name to get rid of middle name\n      return `${contact[\"firstName\"].split(\" \")[0]} ${contact[\"lastName\"]} ${\n        contact[\"email\"]\n      }`\n    },\n    /**\n     * Determines if emails are all valid.\n     */\n    validEmails(emails) {\n      for (const email of emails) {\n        if (email?.length > 0 && !validateEmail(email)) {\n          this.emailsAreValid = false\n          return \"Please enter a valid email.\"\n        }\n      }\n      this.emailsAreValid = true\n      return true\n    },\n    reset() {\n      this.remindees = this.addedEmails\n    },\n  },\n\n  watch: {\n    remindees() {\n      this.$emit(\n        \"update:emails\",\n        this.remindees.map((r) => (this.isContact(r) ? r.email : r))\n      )\n    },\n    query() {\n      if (this.query && this.query.length > 0) {\n        if ( /[,\\s]/.test(this.query)) {\n          /** If the query has spaces or commas, add the valid emails to the list */\n          let successfullyAdded = false\n          const emailsArray = this.query.split(/[,\\s]+/).filter(email => email.trim() !== \"\");\n\n          emailsArray.forEach((email) => {\n            if (validateEmail(email) && !this.remindees.includes(email)) {\n              successfullyAdded = true\n              this.remindees.push(email)\n            }\n          })\n\n          if (successfullyAdded) {\n            this.query = \"\"\n            return\n          }\n          \n        }\n\n        this.searchContacts()\n      } else {\n        clearTimeout(this.timeout)\n        this.searchedContacts = []\n      }\n    },\n  },\n\n  computed: {},\n\n  components: { UserAvatarContent, UserChip },\n}\n</script>\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}