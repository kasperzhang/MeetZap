{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/web.url-search-params.delete.js\";\nimport \"core-js/modules/web.url-search-params.has.js\";\nimport \"core-js/modules/web.url-search-params.size.js\";\nimport { timeNumToTimeText, dateCompare, getDateHoursOffset, post, put, isBetween, clamp, isPhone, utcTimeToLocalTime, splitTimeBlocksByDay, getTimeBlock, dateToDowDate, _delete, get, getDateDayOffset, isDateBetween, generateEnabledCalendarsPayload, isTouchEnabled, isElementInViewport, lightOrDark, removeTransparencyFromHex, userPrefers12h, getCalendarAccountKey, getISODateString, getDateWithTimezone, timeNumToTimeString, isPremiumUser } from \"@/utils\";\nimport { availabilityTypes, calendarOptionsDefaults, eventTypes, timeTypes, timeslotDurations, upgradeDialogTypes } from \"@/constants\";\nimport { mapMutations, mapActions, mapState } from \"vuex\";\nimport UserAvatarContent from \"@/components/UserAvatarContent.vue\";\nimport CalendarAccounts from \"@/components/settings/CalendarAccounts.vue\";\nimport Advertisement from \"@/components/event/Advertisement.vue\";\nimport SignUpBlock from \"@/components/sign_up_form/SignUpBlock.vue\";\nimport SignUpCalendarBlock from \"@/components/sign_up_form/SignUpCalendarBlock.vue\";\nimport SignUpBlocksList from \"@/components/sign_up_form/SignUpBlocksList.vue\";\nimport ZigZag from \"./ZigZag.vue\";\nimport ConfirmDetailsDialog from \"./ConfirmDetailsDialog.vue\";\nimport ToolRow from \"./ToolRow.vue\";\nimport RespondentsList from \"./RespondentsList.vue\";\nimport GCalWeekSelector from \"./GCalWeekSelector.vue\";\nimport ExpandableSection from \"../ExpandableSection.vue\";\nimport WorkingHoursToggle from \"./WorkingHoursToggle.vue\";\nimport AlertText from \"../AlertText.vue\";\nimport Tooltip from \"../Tooltip.vue\";\nimport dayjs from \"dayjs\";\nimport \"dayjs/locale/zh-cn\";\ndayjs.locale(\"zh-cn\");\nimport ObjectID from \"bson-objectid\";\nimport utcPlugin from \"dayjs/plugin/utc\";\nimport timezonePlugin from \"dayjs/plugin/timezone\";\nimport AvailabilityTypeToggle from \"./AvailabilityTypeToggle.vue\";\nimport BufferTimeSwitch from \"./BufferTimeSwitch.vue\";\nimport CalendarEventBlock from \"./CalendarEventBlock.vue\"; // Added import\nimport SpecificTimesInstructions from \"./SpecificTimesInstructions.vue\";\ndayjs.extend(utcPlugin);\ndayjs.extend(timezonePlugin);\nexport default {\n  name: \"ScheduleOverlap\",\n  props: {\n    event: {\n      type: Object,\n      required: true\n    },\n    fromEditEvent: {\n      type: Boolean,\n      default: false\n    },\n    loadingCalendarEvents: {\n      type: Boolean,\n      default: false\n    },\n    // Whether we are currently loading the calendar events\n    calendarEventsMap: {\n      type: Object,\n      default: () => {}\n    },\n    // Object of different users' calendar events\n    sampleCalendarEventsByDay: {\n      type: Array,\n      required: false\n    },\n    // Sample calendar events to use for example calendars\n    calendarPermissionGranted: {\n      type: Boolean,\n      default: false\n    },\n    // Whether user has granted google calendar permissions\n\n    weekOffset: {\n      type: Number,\n      default: 0\n    },\n    // Week offset used for displaying calendar events on weekly schejs\n\n    alwaysShowCalendarEvents: {\n      type: Boolean,\n      default: false\n    },\n    // Whether to show calendar events all the time\n    noEventNames: {\n      type: Boolean,\n      default: false\n    },\n    // Whether to show \"busy\" instead of the event name\n    calendarOnly: {\n      type: Boolean,\n      default: false\n    },\n    // Whether to only show calendar and not respondents or any other controls\n    interactable: {\n      type: Boolean,\n      default: true\n    },\n    // Whether to allow user to interact with component\n    showSnackbar: {\n      type: Boolean,\n      default: true\n    },\n    // Whether to show snackbar when availability is automatically filled in\n    animateTimeslotAlways: {\n      type: Boolean,\n      default: false\n    },\n    // Whether to animate timeslots all the time\n    showHintText: {\n      type: Boolean,\n      default: true\n    },\n    // Whether to show the hint text telling user what to do\n\n    curGuestId: {\n      type: String,\n      default: \"\"\n    },\n    // Id of the current guest being edited\n    addingAvailabilityAsGuest: {\n      type: Boolean,\n      default: false\n    },\n    // Whether the signed in user is adding availability as a guest\n\n    initialTimezone: {\n      type: Object,\n      default: () => ({})\n    },\n    // Availability Groups\n    calendarAvailabilities: {\n      type: Object,\n      default: () => ({})\n    }\n  },\n  data() {\n    return {\n      states: {\n        HEATMAP: \"heatmap\",\n        // Display heatmap of availabilities\n        SINGLE_AVAILABILITY: \"single_availability\",\n        // Show one person's availability\n        SUBSET_AVAILABILITY: \"subset_availability\",\n        // Show availability for a subset of people\n        BEST_TIMES: \"best_times\",\n        // Show only the times that work for most people\n        EDIT_AVAILABILITY: \"edit_availability\",\n        // Edit current user's availability\n        EDIT_SIGN_UP_BLOCKS: \"edit_sign_up_blocks\",\n        // Edit the slots on a sign up form\n        SCHEDULE_EVENT: \"schedule_event\",\n        // Schedule event on gcal\n        SET_SPECIFIC_TIMES: \"set_specific_times\" // Set specific times for the event\n      },\n      state: \"best_times\",\n      availability: new Set(),\n      // The current user's availability\n      ifNeeded: new Set(),\n      // The current user's \"if needed\" availability\n      tempTimes: new Set(),\n      // The specific times that the user has selected for the event (pending save)\n      availabilityAnimTimeouts: [],\n      // Timeouts for availability animation\n      availabilityAnimEnabled: false,\n      // Whether to animate timeslots changing colors\n      maxAnimTime: 1200,\n      // Max amount of time for availability animation\n      unsavedChanges: false,\n      // If there are unsaved availability changes\n      curTimeslot: {\n        row: -1,\n        col: -1\n      },\n      // The currently highlighted timeslot\n      timeslotSelected: false,\n      // Whether a timeslot is selected (used to persist selection on desktop)\n      curTimeslotAvailability: {},\n      // The users available for the current timeslot\n      curRespondent: \"\",\n      // Id of the active respondent (set on hover)\n      curRespondents: [],\n      // Id of currently selected respondents (set on click)\n      sharedCalendarAccounts: {},\n      // The user's calendar accounts for changing calendar options for groups\n      fetchedResponses: {},\n      // Responses fetched from the server for the dates currently shown\n      loadingResponses: {\n        loading: false,\n        lastFetched: new Date().getTime()\n      },\n      // Whether we're currently fetching the responses\n      responsesFormatted: new Map(),\n      // Map where date/time is mapped to the people that are available then\n      tooltipContent: \"\",\n      // The content of the tooltip\n\n      /* Sign up form */\n      signUpBlocksByDay: [],\n      // The current event's sign up blocks by day\n      signUpBlocksToAddByDay: [],\n      // The sign up blocks to be added after hitting 'save'\n\n      /* Edit options */\n      showEditOptions: localStorage[\"showEditOptions\"] == undefined ? false : localStorage[\"showEditOptions\"] == \"true\",\n      availabilityType: availabilityTypes.AVAILABLE,\n      // The current availability type\n      overlayAvailability: false,\n      // Whether to overlay everyone's availability when editing\n      bufferTime: calendarOptionsDefaults.bufferTime,\n      // Set in mounted()\n      workingHours: calendarOptionsDefaults.workingHours,\n      // Set in mounted()\n\n      /* Event Options */\n      showEventOptions: localStorage[\"showEventOptions\"] == undefined ? false : localStorage[\"showEventOptions\"] == \"true\",\n      showBestTimes: localStorage[\"showBestTimes\"] == undefined ? false : localStorage[\"showBestTimes\"] == \"true\",\n      hideIfNeeded: false,\n      /* Variables for drag stuff */\n      DRAG_TYPES: {\n        ADD: \"add\",\n        REMOVE: \"remove\"\n      },\n      SPLIT_GAP_HEIGHT: 40,\n      SPLIT_GAP_WIDTH: 20,\n      HOUR_HEIGHT: 60,\n      timeslot: {\n        width: 0,\n        height: 0\n      },\n      dragging: false,\n      dragType: \"add\",\n      dragStart: null,\n      dragCur: null,\n      /* Variables for options */\n      curTimezone: this.initialTimezone,\n      curScheduledEvent: null,\n      // The scheduled event represented in the form {hoursOffset, hoursLength, dayIndex}\n      timeType: localStorage[\"timeType\"] ?? (userPrefers12h() ? timeTypes.HOUR12 : timeTypes.HOUR24),\n      // Whether 12-hour or 24-hour\n      showCalendarEvents: false,\n      startCalendarOnMonday: false,\n      // localStorage[\"startCalendarOnMonday\"] == undefined\n      //   ? false\n      //   : localStorage[\"startCalendarOnMonday\"] == \"true\",\n\n      /* Dialogs */\n      deleteAvailabilityDialog: false,\n      calendarOptionsDialog: false,\n      /* Variables for scrolling */\n      optionsVisible: false,\n      calendarScrollLeft: 0,\n      // The current scroll position of the calendar\n      calendarMaxScroll: 0,\n      // The maximum scroll amount of the calendar, scrolling to this point means we have scrolled to the end\n      scrolledToRespondents: false,\n      // whether we have scrolled to the respondents section\n      delayedShowStickyRespondents: false,\n      // showStickyRespondents variable but changes 100ms after the actual variable changes (to add some delay)\n      delayedShowStickyRespondentsTimeout: null,\n      // Timeout that sets delayedShowStickyRespondents\n\n      /* Variables for pagination */\n      page: 0,\n      mobileNumDays: localStorage[\"mobileNumDays\"] ? parseInt(localStorage[\"mobileNumDays\"]) : 3,\n      // The number of days to show at a time on mobile\n      pageHasChanged: false,\n      hasRefreshedAuthUser: false,\n      /* Variables for hint */\n      hintState: true,\n      /** Groups */\n      manualAvailability: {},\n      /** Constants */\n      months: [\"jan\", \"feb\", \"mar\", \"apr\", \"may\", \"jun\", \"jul\", \"aug\", \"sep\", \"oct\", \"nov\", \"dec\"]\n    };\n  },\n  computed: {\n    ...mapState([\"authUser\", \"overlayAvailabilitiesEnabled\"]),\n    /** Returns the width of the right side of the calendar */\n    rightSideWidth() {\n      if (this.isPhone) return \"100%\";\n      return this.isSignUp ? \"18rem\" : \"13rem\";\n    },\n    /** Returns the days of the week in the correct order */\n    daysOfWeek() {\n      // 返回带“周”的中文星期标题\n      return !this.startCalendarOnMonday ? [\"周日\", \"周一\", \"周二\", \"周三\", \"周四\", \"周五\", \"周六\"] : [\"周一\", \"周二\", \"周三\", \"周四\", \"周五\", \"周六\", \"周日\"];\n    },\n    /** Only allow scheduling when a curScheduledEvent exists */\n    allowScheduleEvent() {\n      return !!this.curScheduledEvent;\n    },\n    /** Returns the availability as an array */\n    availabilityArray() {\n      return [...this.availability].map(item => new Date(item));\n    },\n    /** Returns the if needed availability as an array */\n    ifNeededArray() {\n      return [...this.ifNeeded].map(item => new Date(item));\n    },\n    allowDrag() {\n      return this.state === this.states.EDIT_AVAILABILITY || this.state === this.states.EDIT_SIGN_UP_BLOCKS || this.state === this.states.SCHEDULE_EVENT || this.state === this.states.SET_SPECIFIC_TIMES;\n    },\n    /** Returns an array of calendar events for all of the authUser's enabled calendars, separated by the day they occur on */\n    calendarEventsByDay() {\n      // If this is an example calendar\n      if (this.sampleCalendarEventsByDay) return this.sampleCalendarEventsByDay;\n\n      // If the user isn't logged in or is adding availability as a guest\n      if (!this.authUser || this.addingAvailabilityAsGuest) return [];\n      let events = [];\n      let event;\n      const calendarAccounts = this.isGroup ? this.sharedCalendarAccounts : this.authUser.calendarAccounts;\n\n      // Adds events from calendar accounts that are enabled\n      for (const id in calendarAccounts) {\n        if (!calendarAccounts[id].enabled) continue;\n        if (this.calendarEventsMap.hasOwnProperty(id)) {\n          for (const index in this.calendarEventsMap[id].calendarEvents) {\n            event = this.calendarEventsMap[id].calendarEvents[index];\n\n            // Check if we need to update authUser (to get latest subcalendars)\n            const subCalendars = calendarAccounts[id].subCalendars;\n            if (!subCalendars || !(event.calendarId in subCalendars)) {\n              // authUser doesn't contain the subCalendar, so push event to events without checking if subcalendar is enabled\n              // and queue the authUser to be refreshed\n              events.push(event);\n              if (!this.hasRefreshedAuthUser && !this.isGroup) {\n                this.refreshAuthUser();\n              }\n              continue;\n            }\n\n            // Push event to events if subcalendar is enabled\n            if (subCalendars[event.calendarId].enabled) {\n              events.push(event);\n            }\n          }\n        }\n      }\n      const eventsCopy = JSON.parse(JSON.stringify(events));\n      const calendarEventsByDay = splitTimeBlocksByDay(this.event, eventsCopy, this.weekOffset, this.timezoneOffset);\n      return calendarEventsByDay;\n    },\n    /** [SPECIFIC TO GROUPS] Returns an object mapping user ids to their calendar events separated by the day they occur on */\n    groupCalendarEventsByDay() {\n      if (this.event.type !== eventTypes.GROUP) return {};\n      const userIdToEventsByDay = {};\n      for (const userId in this.event.responses) {\n        if (userId === this.authUser._id) {\n          userIdToEventsByDay[userId] = this.calendarEventsByDay;\n        } else if (userId in this.calendarAvailabilities) {\n          userIdToEventsByDay[userId] = splitTimeBlocksByDay(this.event, this.calendarAvailabilities[userId], this.weekOffset, this.timezoneOffset);\n        }\n      }\n      return userIdToEventsByDay;\n    },\n    curRespondentsSet() {\n      return new Set(this.curRespondents);\n    },\n    // -----------------------------------\n    //#region Sign up form\n    // -----------------------------------\n\n    /** Returns the name of the new sign up block being dragged */\n    newSignUpBlockName() {\n      return `Slot #${this.signUpBlocksByDay.flat().length + this.signUpBlocksToAddByDay.flat().length + 1}`;\n    },\n    /** Returns the max allowable drag */\n    maxSignUpBlockRowSize() {\n      if (!this.dragStart || !this.isSignUp) return null;\n      const selectedDay = this.signUpBlocksByDay[this.dragStart.col];\n      const selectedDayToAdd = this.signUpBlocksToAddByDay[this.dragStart.col];\n      if (selectedDay.length === 0 && selectedDayToAdd.length === 0) return null;\n      let maxSize = Infinity;\n      for (const block of [...selectedDay, ...selectedDayToAdd]) {\n        if (block.hoursOffset * 4 > this.dragStart.row) {\n          maxSize = Math.min(maxSize, block.hoursOffset * 4 - this.dragStart.row);\n        }\n      }\n      return maxSize;\n    },\n    /** Whether the current user has already responded to the sign up form */\n    alreadyRespondedToSignUpForm() {\n      if (!this.authUser || !this.signUpBlocksByDay) return false;\n      return this.signUpBlocksByDay.some(dayBlocks => dayBlocks.some(block => block.responses?.some(response => response.userId === this.authUser._id)));\n    },\n    //#endregion\n\n    /** Returns the max number of people in the curRespondents array available at any given time */\n    curRespondentsMax() {\n      let max = 0;\n      if (this.event.daysOnly) {\n        for (const day of this.allDays) {\n          const num = [...(this.responsesFormatted.get(day.dateObject.getTime()) ?? new Set())].filter(r => this.curRespondentsSet.has(r)).length;\n          if (num > max) max = num;\n        }\n      } else {\n        for (let i = 0; i < this.event.dates.length; i++) {\n          const date = new Date(this.event.dates[i]);\n          for (const time of this.times) {\n            const num = [...this.getRespondentsForHoursOffset(date, time.hoursOffset)].filter(r => this.curRespondentsSet.has(r)).length;\n            if (num > max) max = num;\n          }\n        }\n      }\n      return max;\n    },\n    /** Returns the day offset caused by the timezone offset. If the timezone offset changes the date, dayOffset != 0 */\n    dayOffset() {\n      return Math.floor((this.event.startTime - this.timezoneOffset / 60) / 24);\n    },\n    /** Returns all the days that are encompassed by startDate and endDate */\n    allDays() {\n      const days = [];\n      const datesSoFar = new Set();\n      const getDateString = date => {\n        let dateString = \"\";\n        let dayString = \"\";\n        const offsetDate = new Date(date);\n        if (this.isSpecificTimes) {\n          offsetDate.setTime(offsetDate.getTime() - this.timezoneOffset * 60 * 1000);\n        } else {\n          offsetDate.setDate(offsetDate.getDate() + this.dayOffset);\n        }\n        // 使用 dayjs 格式化为中文日期\n        dateString = dayjs(offsetDate).format('M月D日');\n        dayString = this.daysOfWeek[offsetDate.getUTCDay()];\n        return {\n          dateString,\n          dayString\n        };\n      };\n      if (this.isSpecificTimes && (this.state === this.states.SET_SPECIFIC_TIMES || this.event.times?.length === 0)) {\n        let prevDate = null; // Stores the prevDate to check if the current date is consecutive to the previous date\n        for (let i = 0; i < this.event.dates.length; ++i) {\n          const date = new Date(this.event.dates[i]);\n          const localDate = new Date(date.getTime() - this.timezoneOffset * 60 * 1000);\n          localDate.setUTCHours(0, 0, 0, 0);\n          localDate.setTime(localDate.getTime() + this.timezoneOffset * 60 * 1000);\n          if (!datesSoFar.has(localDate.getTime())) {\n            datesSoFar.add(localDate.getTime());\n            let isConsecutive = true;\n            if (prevDate) {\n              isConsecutive = prevDate.getTime() === localDate.getTime() - 24 * 60 * 60 * 1000;\n            }\n            const {\n              dayString,\n              dateString\n            } = getDateString(localDate);\n            days.push({\n              dayText: dayString,\n              dateString,\n              dateObject: localDate,\n              isConsecutive\n            });\n            prevDate = new Date(localDate);\n          }\n        }\n        return days;\n      }\n      for (let i = 0; i < this.event.dates.length; ++i) {\n        const date = new Date(this.event.dates[i]);\n        datesSoFar.add(date.getTime());\n        const {\n          dayString,\n          dateString\n        } = getDateString(date);\n        days.push({\n          dayText: dayString,\n          dateString,\n          dateObject: date\n        });\n      }\n      let dayIndex = 0;\n      for (let i = 0; i < this.event.dates.length; ++i) {\n        const date = new Date(this.event.dates[i]);\n        // See if the date goes into the next day\n        const localStart = new Date(date.getTime() - this.timezoneOffset * 60 * 1000);\n        const localEnd = new Date(date.getTime() + this.event.duration * 60 * 60 * 1000 - this.timezoneOffset * 60 * 1000);\n        const localEndIsMidnight = localEnd.getUTCHours() === 0 && localEnd.getUTCMinutes() === 0;\n        if (localStart.getUTCDate() !== localEnd.getUTCDate() && !localEndIsMidnight) {\n          // The date goes into the next day. Split the date into two dates\n          let nextDate = new Date(date);\n          nextDate.setUTCDate(nextDate.getUTCDate() + 1);\n          if (!datesSoFar.has(nextDate.getTime())) {\n            datesSoFar.add(nextDate.getTime());\n            const {\n              dayString,\n              dateString\n            } = getDateString(nextDate);\n            days.splice(dayIndex + 1, 0, {\n              dayText: dayString,\n              dateString,\n              dateObject: nextDate,\n              excludeTimes: true\n            });\n            dayIndex++;\n          }\n        }\n        dayIndex++;\n      }\n      let prevDate = null; // Stores the prevDate to check if the current date is consecutive to the previous date\n      for (let i = 0; i < days.length; ++i) {\n        let isConsecutive = true;\n        if (prevDate) {\n          isConsecutive = prevDate.getTime() === days[i].dateObject.getTime() - 24 * 60 * 60 * 1000;\n        }\n        days[i].isConsecutive = isConsecutive;\n        prevDate = new Date(days[i].dateObject);\n      }\n      return days;\n    },\n    /** Returns a subset of all days based on the page number */\n    days() {\n      const slice = this.allDays.slice(this.page * this.maxDaysPerPage, (this.page + 1) * this.maxDaysPerPage);\n      slice[0] = {\n        ...slice[0],\n        isConsecutive: true\n      };\n      return slice;\n    },\n    /** Returns all the days of the month */\n    monthDays() {\n      const monthDays = [];\n      const allDaysSet = new Set(this.allDays.map(d => d.dateObject.getTime()));\n\n      // Calculate monthIndex and year from event start date and page num\n      const date = new Date(this.event.dates[0]);\n      const monthIndex = date.getUTCMonth() + this.page;\n      const year = date.getUTCFullYear();\n      const lastDayOfPrevMonth = new Date(Date.UTC(year, monthIndex, 0));\n      const lastDayOfCurMonth = new Date(Date.UTC(year, monthIndex + 1, 0));\n\n      // Calculate num days from prev month, cur month, and next month to show\n      const curDate = new Date(lastDayOfPrevMonth);\n      let numDaysFromPrevMonth = 0;\n      const numDaysInCurMonth = lastDayOfCurMonth.getUTCDate();\n      const numDaysFromNextMonth = 6 - lastDayOfCurMonth.getUTCDay();\n      const hasDaysFromPrevMonth = !this.startCalendarOnMonday ? lastDayOfPrevMonth.getUTCDay() < 6 : lastDayOfPrevMonth.getUTCDay() != 0;\n      if (hasDaysFromPrevMonth) {\n        curDate.setUTCDate(curDate.getUTCDate() - (lastDayOfPrevMonth.getUTCDay() - (this.startCalendarOnMonday ? 1 : 0)));\n        numDaysFromPrevMonth = lastDayOfPrevMonth.getUTCDay() + 1;\n      } else {\n        curDate.setUTCDate(curDate.getUTCDate() + 1);\n      }\n      curDate.setUTCHours(this.event.startTime);\n\n      // Add all days from prev month, cur month, and next month\n      const totalDays = numDaysFromPrevMonth + numDaysInCurMonth + numDaysFromNextMonth;\n      for (let i = 0; i < totalDays; ++i) {\n        // Only include days from the current month\n        if (curDate.getUTCMonth() === lastDayOfCurMonth.getUTCMonth()) {\n          monthDays.push({\n            date: curDate.getUTCDate(),\n            time: curDate.getTime(),\n            dateObject: new Date(curDate),\n            included: allDaysSet.has(curDate.getTime())\n          });\n        } else {\n          monthDays.push({\n            date: \"\",\n            time: curDate.getTime(),\n            dateObject: new Date(curDate),\n            included: false\n          });\n        }\n        curDate.setUTCDate(curDate.getUTCDate() + 1);\n      }\n      return monthDays;\n    },\n    /** Map from datetime to whether that month day is included  */\n    monthDayIncluded() {\n      const includedMap = new Map();\n      for (const monthDay of this.monthDays) {\n        includedMap.set(monthDay.dateObject.getTime(), monthDay.included);\n      }\n      return includedMap;\n    },\n    /** Returns the text to show for the current month */\n    curMonthText() {\n      // 使用 dayjs 格式化为中文月份（如 7月）\n      const date = dayjs(this.event.dates[0]).add(this.page, 'month');\n      return date.format('M月');\n    },\n    defaultState() {\n      // Either the heatmap or the best_times state, depending on the toggle\n      return this.showBestTimes ? this.states.BEST_TIMES : this.states.HEATMAP;\n    },\n    editing() {\n      // Returns whether currently in the editing state\n      return this.state === this.states.EDIT_AVAILABILITY || this.state === this.states.EDIT_SIGN_UP_BLOCKS;\n    },\n    scheduling() {\n      // Returns whether currently in the scheduling state\n      return this.state === this.states.SCHEDULE_EVENT;\n    },\n    isPhone() {\n      return isPhone(this.$vuetify);\n    },\n    isOwner() {\n      return this.authUser?._id === this.event.ownerId;\n    },\n    isSpecificDates() {\n      return this.event.type === eventTypes.SPECIFIC_DATES || !this.event.type;\n    },\n    isWeekly() {\n      return this.event.type === eventTypes.DOW;\n    },\n    isGroup() {\n      return this.event.type === eventTypes.GROUP;\n    },\n    isSignUp() {\n      return this.event.isSignUpForm;\n    },\n    isSpecificTimes() {\n      return this.event.hasSpecificTimes;\n    },\n    respondents() {\n      return Object.values(this.parsedResponses).map(r => r.user).filter(Boolean);\n    },\n    selectedGuestRespondent() {\n      if (this.guestAddedAvailability) return this.guestName;\n      if (this.curRespondents.length !== 1) return \"\";\n      const user = this.parsedResponses[this.curRespondents[0]].user;\n      return this.isGuest(user) ? user._id : \"\";\n    },\n    scheduledEventStyle() {\n      const style = {};\n      let top, height, isSecondSplit;\n      if (this.dragging) {\n        top = this.dragStart.row;\n        height = this.dragCur.row - this.dragStart.row + 1;\n        isSecondSplit = this.dragStart.row >= this.splitTimes[0].length;\n      } else {\n        top = this.curScheduledEvent.row;\n        height = this.curScheduledEvent.numRows;\n        isSecondSplit = this.curScheduledEvent.row >= this.splitTimes[0].length;\n      }\n      if (isSecondSplit) {\n        style.top = `calc(${top} * ${this.timeslotHeight}px + ${this.SPLIT_GAP_HEIGHT}px)`;\n      } else {\n        style.top = `calc(${top} * ${this.timeslotHeight}px)`;\n      }\n      style.height = `calc(${height} * ${this.timeslotHeight}px)`;\n      return style;\n    },\n    signUpBlockBeingDraggedStyle() {\n      const style = {};\n      let top = 0,\n        height = 0;\n      if (this.dragging) {\n        top = this.dragStart.row;\n        height = this.dragCur.row - this.dragStart.row + 1;\n      }\n      style.top = `calc(${top} * 1rem)`;\n      style.height = `calc(${height} * 1rem)`;\n      return style;\n    },\n    /** Parses the responses to the Schej, makes necessary changes based on the type of event, and returns it */\n    parsedResponses() {\n      const parsed = {};\n\n      // Return calendar availability if group\n      if (this.event.type === eventTypes.GROUP) {\n        for (const userId in this.event.responses) {\n          const calendarEventsByDay = this.groupCalendarEventsByDay[userId];\n          if (calendarEventsByDay) {\n            // Get manual availability and convert to DOW dates\n            const fetchedManualAvailability = this.getManualAvailabilityDow(this.fetchedResponses[userId]?.manualAvailability);\n            const curManualAvailability = userId === this.authUser._id ? this.getManualAvailabilityDow(this.manualAvailability) : {};\n\n            // Get availability from calendar events and use manual availability on the\n            // \"touched\" days\n            const availability = this.getAvailabilityFromCalendarEvents({\n              calendarEventsByDay,\n              includeTouchedAvailability: true,\n              fetchedManualAvailability: fetchedManualAvailability ?? {},\n              curManualAvailability: curManualAvailability ?? {},\n              calendarOptions: userId === this.authUser._id ? {\n                bufferTime: this.bufferTime,\n                workingHours: this.workingHours\n              } : this.fetchedResponses[userId]?.calendarOptions ?? undefined\n            });\n            parsed[userId] = {\n              ...this.event.responses[userId],\n              availability: availability\n            };\n          } else {\n            parsed[userId] = {\n              ...this.event.responses[userId],\n              availability: new Set()\n            };\n          }\n        }\n        return parsed;\n      }\n\n      // Return only current user availability if using blind availabilities and user is not owner\n      if (this.event.blindAvailabilityEnabled && !this.isOwner) {\n        const guestName = localStorage[this.guestNameKey];\n        const userId = this.authUser?._id ?? guestName;\n        if (userId in this.event.responses) {\n          const user = {\n            ...this.event.responses[userId].user,\n            _id: userId\n          };\n          parsed[userId] = {\n            ...this.event.responses[userId],\n            availability: new Set(this.fetchedResponses[userId]?.availability?.map(a => new Date(a).getTime())),\n            ifNeeded: new Set(this.fetchedResponses[userId]?.ifNeeded?.map(a => new Date(a).getTime())),\n            user: user\n          };\n        }\n        return parsed;\n      }\n\n      // Otherwise, parse responses so that if _id is null (i.e. guest user), then it is set to the guest user's name\n      for (const k of Object.keys(this.event.responses)) {\n        const newUser = {\n          ...this.event.responses[k].user,\n          _id: k\n        };\n        parsed[k] = {\n          ...this.event.responses[k],\n          availability: new Set(this.fetchedResponses[k]?.availability?.map(a => new Date(a).getTime())),\n          ifNeeded: new Set(this.fetchedResponses[k]?.ifNeeded?.map(a => new Date(a).getTime())),\n          user: newUser\n        };\n      }\n      return parsed;\n    },\n    max() {\n      let max = 0;\n      for (const [dateTime, availability] of this.responsesFormatted) {\n        if (availability.size > max) {\n          max = availability.size;\n        }\n      }\n      return max;\n    },\n    /** Returns a set containing the times for the event if it has specific times */\n    specificTimesSet() {\n      return new Set(this.event.times?.map(t => new Date(t).getTime()) ?? []);\n    },\n    /**\n     * Returns a two dimensional array of times\n     * IF endTime < startTime:\n     * the first element is an array of times between 12am and end time and the second element is an array of times between start time and 12am\n     * ELSE:\n     * the first element is an array of times between start time and end time. the second element is an empty array\n     * */\n    splitTimes() {\n      const splitTimes = [[], []];\n      const utcStartTime = this.event.startTime;\n      const utcEndTime = this.event.startTime + this.event.duration;\n      const localStartTime = utcTimeToLocalTime(utcStartTime, this.timezoneOffset);\n      const localEndTime = utcTimeToLocalTime(utcEndTime, this.timezoneOffset);\n\n      // Weird timezones are timezones that are not a multiple of 60 minutes (e.g. GMT-2:30)\n      const isWeirdTimezone = this.timezoneOffset % 60 !== 0;\n      const startTimeIsWeird = utcStartTime % 1 !== 0;\n      let timeOffset = 0;\n      if (isWeirdTimezone !== startTimeIsWeird) {\n        timeOffset = -0.5;\n      }\n      const getExtraTimes = hoursOffset => {\n        if (this.timeslotDuration === timeslotDurations.FIFTEEN_MINUTES) {\n          return [{\n            hoursOffset: hoursOffset + 0.25\n          }, {\n            hoursOffset: hoursOffset + 0.5\n          }, {\n            hoursOffset: hoursOffset + 0.75\n          }];\n        } else if (this.timeslotDuration === timeslotDurations.THIRTY_MINUTES) {\n          return [{\n            hoursOffset: hoursOffset + 0.5\n          }];\n        }\n        return [];\n      };\n      if (this.state === this.states.SET_SPECIFIC_TIMES) {\n        // Hours offset for specific times starts from minHours\n        for (let i = 0; i <= 23; ++i) {\n          const hoursOffset = i;\n          if (i === 9) {\n            // add an id so we can scroll to it\n            splitTimes[0].push({\n              id: \"time-9\",\n              hoursOffset,\n              text: timeNumToTimeText(i, this.timeType === timeTypes.HOUR12)\n            });\n          } else {\n            splitTimes[0].push({\n              hoursOffset,\n              text: timeNumToTimeText(i, this.timeType === timeTypes.HOUR12)\n            });\n          }\n          splitTimes[0].push(...getExtraTimes(hoursOffset));\n        }\n        return splitTimes;\n      }\n      if (localEndTime <= localStartTime && localEndTime !== 0) {\n        for (let i = 0; i < localEndTime; ++i) {\n          splitTimes[0].push({\n            hoursOffset: this.event.duration - (localEndTime - i),\n            text: timeNumToTimeText(i, this.timeType === timeTypes.HOUR12)\n          });\n          splitTimes[0].push(...getExtraTimes(this.event.duration - (localEndTime - i)));\n        }\n        for (let i = 0; i < 24 - localStartTime; ++i) {\n          const adjustedI = i + timeOffset;\n          splitTimes[1].push({\n            hoursOffset: adjustedI,\n            text: timeNumToTimeText(localStartTime + adjustedI, this.timeType === timeTypes.HOUR12)\n          });\n          splitTimes[1].push(...getExtraTimes(adjustedI));\n        }\n      } else {\n        for (let i = 0; i < this.event.duration; ++i) {\n          const adjustedI = i + timeOffset;\n          const utcTimeNum = this.event.startTime + adjustedI;\n          const localTimeNum = utcTimeToLocalTime(utcTimeNum, this.timezoneOffset);\n          splitTimes[0].push({\n            hoursOffset: adjustedI,\n            text: timeNumToTimeText(localTimeNum, this.timeType === timeTypes.HOUR12)\n          });\n          splitTimes[0].push(...getExtraTimes(adjustedI));\n        }\n        if (timeOffset !== 0) {\n          const localTimeNum = utcTimeToLocalTime(this.event.startTime + this.event.duration - 0.5, this.timezoneOffset);\n          splitTimes[0].push({\n            hoursOffset: this.event.duration - 0.5,\n            text: timeNumToTimeText(localTimeNum, this.timeType === timeTypes.HOUR12)\n          });\n          splitTimes[0].push(...getExtraTimes(this.event.duration - 0.5));\n        }\n        splitTimes[1] = [];\n      }\n      return splitTimes;\n    },\n    /** Returns the times that are encompassed by startTime and endTime */\n    times() {\n      return [...this.splitTimes[1], ...this.splitTimes[0]];\n    },\n    timeslotDuration() {\n      return this.event.timeIncrement ?? timeslotDurations.FIFTEEN_MINUTES;\n    },\n    timeslotHeight() {\n      if (this.timeslotDuration === timeslotDurations.FIFTEEN_MINUTES) {\n        return Math.floor(this.HOUR_HEIGHT / 4);\n      } else if (this.timeslotDuration === timeslotDurations.THIRTY_MINUTES) {\n        return Math.floor(this.HOUR_HEIGHT / 2);\n      } else if (this.timeslotDuration === timeslotDurations.ONE_HOUR) {\n        return this.HOUR_HEIGHT;\n      }\n      return Math.floor(this.HOUR_HEIGHT / 4);\n    },\n    timezoneOffset() {\n      if (!(\"offset\" in this.curTimezone)) {\n        return new Date().getTimezoneOffset();\n      }\n      if (this.event.type === eventTypes.DOW) {\n        return this.curTimezone.offset * -1;\n      }\n\n      // Can't just get the offset directly from curTimezone because it doesn't account for dates in the future\n      // when daylight savings might be in or out of effect, so instead, we get the timezone for the first date\n      // of the event\n      return dayjs(this.event.dates[0]).tz(this.curTimezone.value).utcOffset() * -1 // Multiply by -1 because offset is flipped\n      ;\n    },\n    userHasResponded() {\n      return this.authUser && this.authUser._id in this.parsedResponses;\n    },\n    showLeftZigZag() {\n      return this.calendarScrollLeft > 0;\n    },\n    showRightZigZag() {\n      return Math.ceil(this.calendarScrollLeft) < this.calendarMaxScroll;\n    },\n    maxDaysPerPage() {\n      return this.isPhone ? this.mobileNumDays : 7;\n    },\n    hasNextPage() {\n      if (this.event.daysOnly) {\n        const lastDay = new Date(this.event.dates[this.event.dates.length - 1]);\n        const curDate = new Date(this.event.dates[0]);\n        const monthIndex = curDate.getUTCMonth() + this.page;\n        const year = curDate.getUTCFullYear();\n        const lastDayOfCurMonth = new Date(Date.UTC(year, monthIndex + 1, 0));\n        return lastDayOfCurMonth.getTime() < lastDay.getTime();\n      }\n      return this.allDays.length - (this.page + 1) * this.maxDaysPerPage > 0 || this.event.type === eventTypes.GROUP;\n    },\n    hasPrevPage() {\n      return this.page > 0 || this.event.type === eventTypes.GROUP;\n    },\n    /** Returns whether the event has more than one page */\n    hasPages() {\n      return this.hasNextPage || this.hasPrevPage;\n    },\n    showStickyRespondents() {\n      return this.isPhone && !this.scrolledToRespondents && (this.curTimeslot.row !== -1 || this.curRespondent.length > 0 || this.curRespondents.length > 0);\n    },\n    // Hint stuff\n    hintText() {\n      if (this.isPhone) {\n        switch (this.state) {\n          case this.isGroup && this.states.EDIT_AVAILABILITY:\n            return \"Toggle which calendars are used. Tap and drag to edit your availability.\";\n          case this.states.EDIT_AVAILABILITY:\n            const daysOrTimes = this.event.daysOnly ? \"days\" : \"times\";\n            if (this.availabilityType === availabilityTypes.IF_NEEDED) {\n              return `Tap and drag to add your \"if needed\" ${daysOrTimes} in yellow.`;\n            }\n            return `Tap and drag to add your \"available\" ${daysOrTimes} in green.`;\n          case this.states.SCHEDULE_EVENT:\n            return \"Tap and drag on the calendar to schedule a Google Calendar event during those times.\";\n          default:\n            return \"\";\n        }\n      }\n      switch (this.state) {\n        case this.isGroup && this.states.EDIT_AVAILABILITY:\n          return \"Toggle which calendars are used. Click and drag to edit your availability.\";\n        case this.states.EDIT_AVAILABILITY:\n          const daysOrTimes = this.event.daysOnly ? \"days\" : \"times\";\n          if (this.availabilityType === availabilityTypes.IF_NEEDED) {\n            return `Click and drag to add your \"if needed\" ${daysOrTimes} in yellow.`;\n          }\n          return `Click and drag to add your \"available\" ${daysOrTimes} in green.`;\n        case this.states.SCHEDULE_EVENT:\n          return \"Click and drag on the calendar to schedule a Google Calendar event during those times.\";\n        default:\n          return \"\";\n      }\n    },\n    hintClosed() {\n      return !this.hintState || localStorage[this.hintStateLocalStorageKey];\n    },\n    hintStateLocalStorageKey() {\n      return `closedHintText${this.state}` + (\"&isGroup\" ? this.isGroup : \"\");\n    },\n    hintTextShown() {\n      return this.showHintText && this.hintText != \"\" && !this.hintClosed;\n    },\n    timeslotClassStyle() {\n      const classStyles = [];\n      for (let d = 0; d < this.days.length; ++d) {\n        const day = this.days[d];\n        for (let t = 0; t < this.splitTimes[0].length; ++t) {\n          const time = this.splitTimes[0][t];\n          classStyles.push(this.getTimeTimeslotClassStyle(day, time, d, t));\n        }\n        for (let t = 0; t < this.splitTimes[1].length; ++t) {\n          const time = this.splitTimes[1][t];\n          classStyles.push(this.getTimeTimeslotClassStyle(day, time, d, t + this.splitTimes[0].length));\n        }\n      }\n      return classStyles;\n    },\n    dayTimeslotClassStyle() {\n      const classStyles = [];\n      for (let i = 0; i < this.monthDays.length; ++i) {\n        classStyles.push(this.getDayTimeslotClassStyle(this.monthDays[i].dateObject, i));\n      }\n      return classStyles;\n    },\n    timeslotVon() {\n      const vons = [];\n      for (let d = 0; d < this.days.length; ++d) {\n        for (let t = 0; t < this.times.length; ++t) {\n          vons.push(this.getTimeslotVon(t, d));\n        }\n      }\n      return vons;\n    },\n    dayTimeslotVon() {\n      const vons = [];\n      for (let i = 0; i < this.monthDays.length; ++i) {\n        const row = Math.floor(i / 7);\n        const col = i % 7;\n        vons.push(this.getTimeslotVon(row, col));\n      }\n      return vons;\n    },\n    /** Whether to show spinner on top of availability grid */\n    showLoader() {\n      return (\n        // Loading calendar events\n        (this.isGroup || this.alwaysShowCalendarEvents || this.editing) && this.loadingCalendarEvents ||\n        // Loading responses\n        this.loadingResponses.loading\n      );\n    },\n    /** Localstorage key containing the guest's name */\n    guestNameKey() {\n      return `${this.event._id}.guestName`;\n    },\n    /** The guest name stored in localstorage */\n    guestName() {\n      return localStorage[this.guestNameKey];\n    },\n    /** Whether a guest has added their availability (saved in localstorage) */\n    guestAddedAvailability() {\n      return this.guestName?.length > 0 && this.guestName in this.parsedResponses;\n    },\n    /** Returns an array of time blocks representing the current user's availability\n     * (used for displaying current user's availability on top of everybody else's availability)\n     */\n    overlaidAvailability() {\n      const overlaidAvailability = [];\n      this.days.forEach((day, d) => {\n        overlaidAvailability.push([]);\n        let curBlockIndex = 0;\n        const addOverlaidAvailabilityBlocks = (time, t) => {\n          const date = this.getDateFromRowCol(t, d);\n          if (!date) return;\n          const dragAdd = this.dragging && this.inDragRange(t, d) && this.dragType === this.DRAG_TYPES.ADD;\n          const dragRemove = this.dragging && this.inDragRange(t, d) && this.dragType === this.DRAG_TYPES.REMOVE;\n\n          // Check if timeslot is available or if needed or in the drag region\n          if (dragAdd || !dragRemove && (this.availability.has(date.getTime()) || this.ifNeeded.has(date.getTime()))) {\n            // Determine whether to render as available or if needed block\n            let type = availabilityTypes.AVAILABLE;\n            if (dragAdd) {\n              type = this.availabilityType;\n            } else {\n              type = this.availability.has(date.getTime()) ? availabilityTypes.AVAILABLE : availabilityTypes.IF_NEEDED;\n            }\n            if (curBlockIndex in overlaidAvailability[d]) {\n              if (overlaidAvailability[d][curBlockIndex].type === type) {\n                // Increase block length if matching type and curBlockIndex exists\n                overlaidAvailability[d][curBlockIndex].hoursLength += 0.25;\n              } else {\n                // Add a new block because type is different\n                overlaidAvailability[d].push({\n                  hoursOffset: time.hoursOffset,\n                  hoursLength: 0.25,\n                  type\n                });\n                curBlockIndex++;\n              }\n            } else {\n              // Add a new block because block doesn't exist for current index\n              overlaidAvailability[d].push({\n                hoursOffset: time.hoursOffset,\n                hoursLength: 0.25,\n                type\n              });\n            }\n          } else if (curBlockIndex in overlaidAvailability[d]) {\n            // Only increment cur block index if block already exists at the current index\n            curBlockIndex++;\n          }\n        };\n        for (let t = 0; t < this.splitTimes[0].length; ++t) {\n          addOverlaidAvailabilityBlocks(this.splitTimes[0][t], t);\n        }\n        if (curBlockIndex in overlaidAvailability[d]) {\n          curBlockIndex++;\n        }\n        for (let t = 0; t < this.splitTimes[1].length; ++t) {\n          addOverlaidAvailabilityBlocks(this.splitTimes[1][t], t + this.splitTimes[0].length);\n        }\n      });\n      return overlaidAvailability;\n    },\n    // Options\n    showOverlayAvailabilityToggle() {\n      return this.respondents.length > 0 && this.overlayAvailabilitiesEnabled;\n    },\n    showCalendarOptions() {\n      return !this.addingAvailabilityAsGuest && this.calendarPermissionGranted && (this.isGroup || !this.isGroup && !this.userHasResponded);\n    },\n    /** Returns an array of the x-offsets of the columns, taking into account the split gaps from non-consecutive days */\n    columnOffsets() {\n      const offsets = [];\n      let accumulatedOffset = 0;\n      for (let i = 0; i < this.days.length; ++i) {\n        offsets.push(accumulatedOffset);\n        if (!this.days[i].isConsecutive) {\n          accumulatedOffset += this.SPLIT_GAP_WIDTH;\n        }\n        accumulatedOffset += this.timeslot.width;\n      }\n      return offsets;\n    }\n  },\n  methods: {\n    ...mapMutations([\"setAuthUser\"]),\n    ...mapActions([\"showInfo\", \"showError\", \"showUpgradeDialog\"]),\n    // -----------------------------------\n    //#region Date\n    // -----------------------------------\n\n    /** Returns a date object from the dayindex and hoursoffset given */\n    getDateFromDayHoursOffset(dayIndex, hoursOffset) {\n      return getDateHoursOffset(this.days[dayIndex].dateObject, hoursOffset);\n    },\n    /** Returns a date object from the row and column given on the current page */\n    getDateFromRowCol(row, col) {\n      if (this.event.daysOnly) {\n        const dateObject = this.monthDays[row * 7 + col]?.dateObject;\n        if (!dateObject) return null;\n        return new Date(dateObject);\n      } else {\n        return this.getDateFromDayTimeIndex(this.maxDaysPerPage * this.page + col, row);\n      }\n    },\n    isColConsecutive(col) {\n      return Boolean(this.days[col]?.isConsecutive);\n    },\n    /** Returns a date object from the day index and time index given */\n    getDateFromDayTimeIndex(dayIndex, timeIndex) {\n      const hasSecondSplit = this.splitTimes[1].length > 0;\n      const isFirstSplit = timeIndex < this.splitTimes[0].length;\n      const time = isFirstSplit ? this.splitTimes[0][timeIndex] : this.splitTimes[1][timeIndex - this.splitTimes[0].length];\n      let adjustedDayIndex = dayIndex;\n      if (hasSecondSplit) {\n        if (isFirstSplit) {\n          adjustedDayIndex = dayIndex - 1;\n        } else if (dayIndex === this.allDays.length - 1) {\n          return null;\n        }\n      }\n      const day = this.allDays[adjustedDayIndex];\n      if (!day || !time) return null;\n      if (day.excludeTimes) {\n        return null;\n      }\n      const date = getDateHoursOffset(day.dateObject, time.hoursOffset);\n      if (this.isSpecificTimes) {\n        // TODO: see if we need to do anything for 0.5 timezones\n        if (this.state !== this.states.SET_SPECIFIC_TIMES && this.event.times?.length > 0) {\n          if (!this.specificTimesSet.has(date.getTime())) {\n            return null;\n          }\n        }\n      } else {\n        // Return null for times outside of the correct range\n        if (time.hoursOffset < 0 || time.hoursOffset >= this.event.duration) {\n          return null;\n        }\n      }\n      return date;\n    },\n    //#endregion\n\n    // -----------------------------------\n    //#region Respondent\n    // -----------------------------------\n    mouseOverRespondent(e, id) {\n      if (this.curRespondents.length === 0) {\n        if (this.state === this.defaultState) {\n          this.state = this.states.SINGLE_AVAILABILITY;\n        }\n        this.curRespondent = id;\n      }\n    },\n    mouseLeaveRespondent(e) {\n      if (this.curRespondents.length === 0) {\n        if (this.state === this.states.SINGLE_AVAILABILITY) {\n          this.state = this.defaultState;\n        }\n        this.curRespondent = \"\";\n      }\n    },\n    clickRespondent(e, id) {\n      this.state = this.states.SUBSET_AVAILABILITY;\n      this.curRespondent = \"\";\n      if (this.curRespondentsSet.has(id)) {\n        // Remove id\n        this.curRespondents = this.curRespondents.filter(r => r != id);\n\n        // Go back to default state if all users deselected\n        if (this.curRespondents.length === 0) {\n          this.state = this.defaultState;\n        }\n      } else {\n        // Add id\n        this.curRespondents.push(id);\n      }\n      e.stopPropagation();\n    },\n    deselectRespondents(e) {\n      // Don't deselect respondents if toggled best times\n      // or if this was fired by clicking on a timeslot\n      if (e?.target?.previousElementSibling?.id === \"show-best-times-toggle\" || e?.target?.firstChild?.firstChild?.id === \"show-best-times-toggle\" || e?.target?.classList?.contains(\"timeslot\") //&& this.isPhone)\n      ) return;\n      if (this.state === this.states.SUBSET_AVAILABILITY) {\n        this.state = this.defaultState;\n      }\n      this.curRespondents = [];\n\n      // Stop persisting timeslot\n      this.timeslotSelected = false;\n      this.resetCurTimeslot();\n    },\n    isGuest(user) {\n      return user._id == user.firstName;\n    },\n    //#endregion\n\n    // -----------------------------------\n    //#region Aggregate user availability\n    // -----------------------------------\n\n    /** Fetches responses from server */\n    fetchResponses() {\n      if (this.calendarOnly) {\n        this.fetchedResponses = this.event.responses;\n        return;\n      }\n      let timeMin, timeMax;\n      if (this.event.type === eventTypes.GROUP) {\n        if (this.event.dates.length > 0) {\n          // Fetch the date range for the current week\n          timeMin = new Date(this.event.dates[0]);\n          timeMax = new Date(this.event.dates[this.event.dates.length - 1]);\n          timeMax.setDate(timeMax.getDate() + 1);\n\n          // Convert dow dates to discrete dates\n          timeMin = dateToDowDate(this.event.dates, timeMin, this.weekOffset, true);\n          timeMax = dateToDowDate(this.event.dates, timeMax, this.weekOffset, true);\n        }\n      } else {\n        if (this.allDays.length > 0) {\n          // Fetch the entire time range of availabilities\n          timeMin = new Date(this.allDays[0].dateObject);\n          timeMax = new Date(this.allDays[this.allDays.length - 1].dateObject);\n          timeMax.setDate(timeMax.getDate() + 1);\n        }\n      }\n      if (!timeMin || !timeMax) return;\n\n      // Fetch responses between timeMin and timeMax\n      const url = `/events/${this.event._id}/responses?timeMin=${timeMin.toISOString()}&timeMax=${timeMax.toISOString()}`;\n      get(url).then(responses => {\n        this.fetchedResponses = responses;\n        this.getResponsesFormatted();\n      }).catch(err => {\n        this.showError(\"There was an error fetching availability! Please refresh the page.\");\n      });\n    },\n    /** Formats the responses in a map where date/time is mapped to the people that are available then */\n    getResponsesFormatted() {\n      const lastFetched = new Date().getTime();\n      this.loadingResponses.loading = true;\n      this.loadingResponses.lastFetched = lastFetched;\n      this.$worker.run((days, times, parsedResponses, daysOnly, hideIfNeeded) => {\n        // Define functions locally because we can't import functions\n        const splitTimeNum = timeNum => {\n          const hours = Math.floor(timeNum);\n          const minutes = Math.floor((timeNum - hours) * 60);\n          return {\n            hours,\n            minutes\n          };\n        };\n        const getDateHoursOffset = (date, hoursOffset) => {\n          const {\n            hours,\n            minutes\n          } = splitTimeNum(hoursOffset);\n          const newDate = new Date(date);\n          newDate.setHours(newDate.getHours() + hours);\n          newDate.setMinutes(newDate.getMinutes() + minutes);\n          return newDate;\n        };\n\n        // Create array of all dates in the event\n        const dates = [];\n        if (daysOnly) {\n          for (const day of days) {\n            dates.push(day.dateObject);\n          }\n        } else {\n          for (const day of days) {\n            for (const time of times) {\n              // Iterate through all the times\n              const date = getDateHoursOffset(day.dateObject, time.hoursOffset);\n              dates.push(date);\n            }\n          }\n        }\n\n        // Create a map mapping time to the respondents available during that time\n        const formatted = new Map();\n        for (const date of dates) {\n          formatted.set(date.getTime(), new Set());\n\n          // Check every response and see if they are available for the given time\n          for (const response of Object.values(parsedResponses)) {\n            // Check availability array\n            if (response.availability?.has(date.getTime()) || response.ifNeeded?.has(date.getTime()) && !hideIfNeeded) {\n              formatted.get(date.getTime()).add(response.user._id);\n              continue;\n            }\n          }\n        }\n        return formatted;\n      }, [this.allDays, this.times, this.parsedResponses, this.event.daysOnly, this.hideIfNeeded]).then(formatted => {\n        // Only set responses formatted for the latest request\n        if (lastFetched >= this.loadingResponses.lastFetched) {\n          this.responsesFormatted = formatted;\n        }\n      }).finally(() => {\n        if (this.loadingResponses.lastFetched === lastFetched) {\n          this.loadingResponses.loading = false;\n        }\n      });\n    },\n    /** Returns a set of respondents for the given date/time */\n    getRespondentsForHoursOffset(date, hoursOffset) {\n      const d = getDateHoursOffset(date, hoursOffset);\n      return this.responsesFormatted.get(d.getTime()) ?? new Set();\n    },\n    showAvailability(row, col) {\n      if (this.state === this.states.EDIT_AVAILABILITY && this.isPhone) {\n        // Don't show currently selected timeslot when on phone and editing\n        return;\n      }\n\n      // Update current timeslot (the timeslot that has a dotted border around it)\n      this.curTimeslot = {\n        row,\n        col\n      };\n      if (this.state === this.states.EDIT_AVAILABILITY || this.curRespondent) {\n        // Don't show availability when editing or when respondent is selected\n        return;\n      }\n      const date = this.getDateFromRowCol(row, col);\n      if (!date) return;\n\n      // Update current timeslot availability to show who is available for the given timeslot\n      const available = this.responsesFormatted.get(date.getTime()) ?? new Set();\n      for (const respondent of this.respondents) {\n        if (available.has(respondent._id)) {\n          this.curTimeslotAvailability[respondent._id] = true;\n        } else {\n          this.curTimeslotAvailability[respondent._id] = false;\n        }\n      }\n    },\n    //#endregion\n\n    // -----------------------------------\n    //#region Current user availability\n    // -----------------------------------\n    async refreshAuthUser() {\n      this.hasRefreshedAuthUser = true;\n      await get(\"/user/profile\").then(authUser => {\n        this.setAuthUser(authUser);\n      });\n    },\n    /** resets cur user availability to the response stored on the server */\n    resetCurUserAvailability() {\n      if (this.event.type === eventTypes.GROUP) {\n        this.initSharedCalendarAccounts();\n        this.manualAvailability = {};\n      }\n      this.availability = new Set();\n      this.ifNeeded = new Set();\n      if (this.userHasResponded) {\n        this.populateUserAvailability(this.authUser._id);\n      }\n    },\n    /** Populates the availability set for the auth user from the responses object stored on the server */\n    populateUserAvailability(id) {\n      this.availability = new Set(this.parsedResponses[id]?.availability) ?? new Set();\n      this.ifNeeded = new Set(this.parsedResponses[id]?.ifNeeded) ?? new Set();\n      this.$nextTick(() => this.unsavedChanges = false);\n    },\n    /** Returns true if the calendar event is in the first split */\n    getIsTimeBlockInFirstSplit(timeBlock) {\n      return timeBlock.hoursOffset >= this.splitTimes[0][0].hoursOffset && timeBlock.hoursOffset <= this.splitTimes[0][this.splitTimes[0].length - 1].hoursOffset;\n    },\n    /** Returns the style for the calendar event block */\n    getTimeBlockStyle(timeBlock) {\n      const style = {};\n      const hasSecondSplit = this.splitTimes[1].length > 0;\n      if (!hasSecondSplit || this.getIsTimeBlockInFirstSplit(timeBlock)) {\n        style.top = `calc(${timeBlock.hoursOffset - this.splitTimes[0][0].hoursOffset} * ${this.HOUR_HEIGHT}px)`;\n        style.height = `calc(${timeBlock.hoursLength} * ${this.HOUR_HEIGHT}px)`;\n      } else {\n        style.top = `calc(${this.splitTimes[0].length} * ${this.timeslotHeight}px + ${this.SPLIT_GAP_HEIGHT}px + ${timeBlock.hoursOffset - this.splitTimes[1][0].hoursOffset} * ${this.HOUR_HEIGHT}px)`;\n        style.height = `calc(${timeBlock.hoursLength} * ${this.HOUR_HEIGHT}px)`;\n      }\n      return style;\n    },\n    /** Returns a set containing the available times based on the given calendar events object */\n    getAvailabilityFromCalendarEvents({\n      calendarEventsByDay = [],\n      includeTouchedAvailability = false,\n      // Whether to include manual availability for touched days\n      fetchedManualAvailability = {},\n      // Object mapping unix timestamp to array of manual availability (fetched from server)\n      curManualAvailability = {},\n      // Manual availability with edits (takes precedence over fetchedManualAvailability)\n      calendarOptions = calendarOptionsDefaults // User id of the user we are getting availability for\n    }) {\n      const availability = new Set();\n      for (let i = 0; i < this.allDays.length; ++i) {\n        const day = this.allDays[i];\n        const date = day.dateObject;\n        if (includeTouchedAvailability) {\n          const endDate = getDateHoursOffset(date, this.times.length * (this.timeslotDuration / 60));\n\n          // Check if manual availability has been added for the current date\n          let manualAvailabilityAdded = false;\n          for (const time in curManualAvailability) {\n            if (date.getTime() <= time && time <= endDate.getTime()) {\n              curManualAvailability[time].forEach(a => {\n                availability.add(new Date(a).getTime());\n              });\n              delete curManualAvailability[time];\n              manualAvailabilityAdded = true;\n              break;\n            }\n          }\n          if (manualAvailabilityAdded) continue;\n          for (const time in fetchedManualAvailability) {\n            if (date.getTime() <= time && time <= endDate.getTime()) {\n              fetchedManualAvailability[time].forEach(a => {\n                availability.add(new Date(a).getTime());\n              });\n              delete fetchedManualAvailability[time];\n              manualAvailabilityAdded = true;\n              break;\n            }\n          }\n          if (manualAvailabilityAdded) continue;\n        }\n\n        // Calculate buffer time\n        const bufferTimeInMS = calendarOptions.bufferTime.enabled ? calendarOptions.bufferTime.time * 1000 * 60 : 0;\n\n        // Calculate working hours\n        const startTimeString = timeNumToTimeString(calendarOptions.workingHours.startTime);\n        const isoDateString = getISODateString(getDateWithTimezone(date), true);\n        const workingHoursStartDate = dayjs.tz(`${isoDateString} ${startTimeString}`, this.curTimezone.value).toDate();\n        let duration = calendarOptions.workingHours.endTime - calendarOptions.workingHours.startTime;\n        if (duration <= 0) duration += 24;\n        const workingHoursEndDate = getDateHoursOffset(workingHoursStartDate, duration);\n        for (let j = 0; j < this.times.length; ++j) {\n          const startDate = this.getDateFromDayTimeIndex(i, j);\n          if (!startDate) continue;\n          const endDate = getDateHoursOffset(startDate, this.timeslotDuration / 60);\n\n          // Working hours\n          if (calendarOptions.workingHours.enabled) {\n            if (endDate.getTime() <= workingHoursStartDate.getTime() || startDate.getTime() >= workingHoursEndDate.getTime()) {\n              continue;\n            }\n          }\n\n          // Check if there exists a calendar event that overlaps [startDate, endDate]\n          const index = calendarEventsByDay[i]?.findIndex(e => {\n            const startDateBuffered = new Date(e.startDate.getTime() - bufferTimeInMS);\n            const endDateBuffered = new Date(e.endDate.getTime() + bufferTimeInMS);\n            const notIntersect = dateCompare(endDate, startDateBuffered) <= 0 || dateCompare(startDate, endDateBuffered) >= 0;\n            return !notIntersect && !e.free;\n          });\n          if (index === -1) {\n            availability.add(startDate.getTime());\n          }\n        }\n      }\n      return availability;\n    },\n    /** Constructs the availability array using calendarEvents array */\n    setAvailabilityAutomatically() {\n      // This is not a computed property because we should be able to change it manually from what it automatically fills in\n      this.availability = new Set();\n      const tmpAvailability = this.getAvailabilityFromCalendarEvents({\n        calendarEventsByDay: this.calendarEventsByDay,\n        calendarOptions: {\n          bufferTime: this.bufferTime,\n          workingHours: this.workingHours\n        }\n      });\n      const pageStartDate = getDateDayOffset(new Date(this.event.dates[0]), this.page * this.maxDaysPerPage);\n      const pageEndDate = getDateDayOffset(pageStartDate, this.maxDaysPerPage);\n      this.animateAvailability(tmpAvailability, pageStartDate, pageEndDate);\n    },\n    /** Animate the filling out of availability using setTimeout, between startDate and endDate */\n    animateAvailability(availability, startDate, endDate) {\n      this.availabilityAnimEnabled = true;\n      this.availabilityAnimTimeouts = [];\n      let msPerGroup = 25;\n      let blocksPerGroup = 2;\n      if (availability.size / blocksPerGroup * msPerGroup > this.maxAnimTime) {\n        blocksPerGroup = availability.size * msPerGroup / this.maxAnimTime;\n      }\n      let availabilityArray = [...availability];\n      availabilityArray = availabilityArray.filter(a => isDateBetween(a, startDate, endDate));\n      for (let i = 0; i < availabilityArray.length / blocksPerGroup + 1; ++i) {\n        const timeout = setTimeout(() => {\n          for (const a of availabilityArray.slice(i * blocksPerGroup, i * blocksPerGroup + blocksPerGroup)) {\n            this.availability.add(a);\n          }\n          this.availability = new Set(this.availability);\n          if (i >= availabilityArray.length / blocksPerGroup) {\n            // Make sure the entire availability has been added (will not be guaranteed when only animating a portion of availability)\n            this.availability = new Set(availability);\n            this.availabilityAnimTimeouts.push(setTimeout(() => {\n              this.availabilityAnimEnabled = false;\n              if (this.showSnackbar) {\n                this.showInfo(\"Your availability has been autofilled!\");\n              }\n              this.unsavedChanges = false;\n            }, 500));\n          }\n        }, i * msPerGroup);\n        this.availabilityAnimTimeouts.push(timeout);\n      }\n    },\n    stopAvailabilityAnim() {\n      for (const timeout of this.availabilityAnimTimeouts) {\n        clearTimeout(timeout);\n      }\n      this.availabilityAnimEnabled = false;\n    },\n    async submitAvailability(guestPayload = {\n      name: \"\",\n      email: \"\"\n    }) {\n      let payload = {};\n      let type = \"\";\n      // If this is a group submit enabled calendars, otherwise submit availability\n      if (this.isGroup) {\n        type = \"group availability and calendars\";\n        payload = generateEnabledCalendarsPayload(this.sharedCalendarAccounts);\n        payload.manualAvailability = {};\n        for (const day of Object.keys(this.manualAvailability)) {\n          payload.manualAvailability[day] = [...this.manualAvailability[day]].map(a => new Date(a));\n        }\n        payload.calendarOptions = {\n          bufferTime: this.bufferTime,\n          workingHours: this.workingHours\n        };\n      } else {\n        type = \"availability\";\n        payload.availability = this.availabilityArray;\n        payload.ifNeeded = this.ifNeededArray;\n        if (this.authUser && !this.addingAvailabilityAsGuest) {\n          payload.guest = false;\n        } else {\n          payload.guest = true;\n          payload.name = guestPayload.name;\n          payload.email = guestPayload.email;\n          localStorage[this.guestNameKey] = guestPayload.name;\n        }\n      }\n      await post(`/events/${this.event._id}/response`, payload);\n\n      // Update analytics\n      const addedIfNeededTimes = this.ifNeededArray.length > 0;\n      if (this.authUser) {\n        if (this.authUser._id in this.parsedResponses) {\n          this.$posthog?.capture(`Edited ${type}`, {\n            eventId: this.event._id,\n            addedIfNeededTimes\n          });\n        } else {\n          this.$posthog?.capture(`Added ${type}`, {\n            eventId: this.event._id,\n            addedIfNeededTimes,\n            // bufferTime: this.bufferTime,\n            bufferTime: this.bufferTime.time,\n            bufferTimeActive: this.bufferTime.enabled,\n            workingHoursEnabled: this.workingHours.enabled,\n            workingHoursStartTime: this.workingHours.startTime,\n            workingHoursEndTime: this.workingHours.endTime\n          });\n        }\n      } else {\n        if (guestPayload.name in this.parsedResponses) {\n          this.$posthog?.capture(`Edited ${type} as guest`, {\n            eventId: this.event._id,\n            addedIfNeededTimes\n          });\n        } else {\n          this.$posthog?.capture(`Added ${type} as guest`, {\n            eventId: this.event._id,\n            addedIfNeededTimes\n          });\n        }\n      }\n      this.refreshEvent();\n      this.unsavedChanges = false;\n    },\n    async submitNewSignUpBlocks() {\n      if (this.signUpBlocksToAddByDay.flat().length + this.signUpBlocksByDay.flat().length === 0) {\n        this.showError(\"Please add at least one sign-up block!\");\n        return false;\n      }\n      for (let i = 0; i < this.signUpBlocksToAddByDay.length; ++i) {\n        this.signUpBlocksByDay[i] = this.signUpBlocksByDay[i].concat(this.signUpBlocksToAddByDay[i]);\n        this.signUpBlocksToAddByDay[i] = [];\n      }\n      const payload = {\n        name: this.event.name,\n        duration: this.event.duration,\n        dates: this.event.dates,\n        type: this.event.type,\n        signUpBlocks: this.signUpBlocksByDay.flat().map(block => {\n          return {\n            _id: block._id,\n            name: block.name,\n            capacity: block.capacity,\n            startDate: block.startDate,\n            endDate: block.endDate\n          };\n        })\n      };\n      put(`/events/${this.event._id}`, payload).then(() => {\n        // window.location.reload()\n      }).catch(err => {\n        console.error(err);\n        this.showError(\"There was a problem editing this event! Please try again later.\");\n      });\n      return true;\n    },\n    async deleteAvailability(name = \"\") {\n      const payload = {};\n      if (this.authUser && !this.addingAvailabilityAsGuest) {\n        payload.guest = false;\n        payload.userId = this.authUser._id;\n        this.$posthog?.capture(\"Deleted availability\", {\n          eventId: this.event._id\n        });\n      } else {\n        payload.guest = true;\n        payload.name = name;\n        this.$posthog?.capture(\"Deleted availability as guest\", {\n          eventId: this.event._id,\n          name\n        });\n      }\n      await _delete(`/events/${this.event._id}/response`, payload);\n      this.availability = new Set();\n      if (this.isGroup) this.$router.replace({\n        name: \"home\"\n      });else this.refreshEvent();\n    },\n    //#endregion\n\n    // -----------------------------------\n    //#region Timeslot\n    // -----------------------------------\n    setTimeslotSize() {\n      /* Gets the dimensions of each timeslot and assigns it to the timeslot variable */\n      const timeslotEl = document.querySelector(\".timeslot\");\n      if (timeslotEl) {\n        ;\n        ({\n          width: this.timeslot.width,\n          height: this.timeslot.height\n        } = timeslotEl.getBoundingClientRect());\n      }\n    },\n    /** Returns a class string and style object for the given time timeslot div */\n    getTimeTimeslotClassStyle(day, time, d, t) {\n      const row = t;\n      const col = d;\n      const date = this.getDateFromRowCol(row, col);\n      const classStyle = this.getTimeslotClassStyle(date, row, col);\n\n      // Add time timeslot specific stuff\n      const isFirstSplit = t < this.splitTimes[0].length;\n      const isDisabled = !date;\n\n      // Animation\n      if (this.animateTimeslotAlways || this.availabilityAnimEnabled) {\n        classStyle.class += \"animate-bg-color \";\n      }\n\n      // Height\n      classStyle.style.height = `${this.timeslotHeight}px`;\n\n      // Border style\n      if ((this.respondents.length > 0 || this.editing || this.state === this.states.SET_SPECIFIC_TIMES) && this.curTimeslot.row === row && this.curTimeslot.col === col && !isDisabled) {\n        // Dashed border for currently selected timeslot\n        classStyle.class += \"tw-border tw-border-dashed tw-border-black tw-z-10 \";\n      } else {\n        // Normal border\n        if (date) {\n          const localDate = new Date(date.getTime() - this.timezoneOffset * 60 * 1000);\n          const fractionalTime = localDate.getMinutes();\n          if (fractionalTime === 0) {\n            classStyle.class += \"tw-border-t \";\n          } else if (fractionalTime === 30) {\n            classStyle.class += \"tw-border-t \";\n            classStyle.style.borderTopStyle = \"dashed\";\n          }\n        }\n        classStyle.class += \"tw-border-r \";\n        if (col === 0 || !this.isColConsecutive(col)) classStyle.class += \"tw-border-l tw-border-l-gray \";\n        if (col === this.days.length - 1 || !this.isColConsecutive(col + 1)) classStyle.class += \"tw-border-r-gray \";\n        if (isFirstSplit && row === 0) classStyle.class += \"tw-border-t tw-border-t-gray \";\n        if (!isFirstSplit && row === this.splitTimes[0].length) classStyle.class += \"tw-border-t tw-border-t-gray \";\n        if (isFirstSplit && row === this.splitTimes[0].length - 1) classStyle.class += \"tw-border-b tw-border-b-gray \";\n        if (!isFirstSplit && row === this.splitTimes[0].length + this.splitTimes[1].length - 1) classStyle.class += \"tw-border-b tw-border-b-gray \";\n        const totalRespondents = this.state === this.states.SUBSET_AVAILABILITY ? this.curRespondents.length : this.respondents.length;\n        if (this.state === this.states.EDIT_AVAILABILITY || this.state === this.states.SINGLE_AVAILABILITY || totalRespondents === 1) {\n          classStyle.class += \"tw-border-[#999999] \";\n        } else {\n          classStyle.class += \"tw-border-[#DDDDDD99] \";\n        }\n      }\n\n      // Edit fill color and border color if day is not interactable\n      if (isDisabled) {\n        classStyle.class += \"tw-bg-light-gray-stroke tw-border-light-gray-stroke \";\n      }\n\n      // Change default red:\n      if (classStyle.style.backgroundColor === \"#E523230D\") {\n        classStyle.style.backgroundColor = \"#E5232333\";\n      }\n      return classStyle;\n    },\n    /** Returns the shared class string and style object for the given timeslot (either time timeslot or day timeslot) */\n    getTimeslotClassStyle(date, row, col) {\n      let c = \"\";\n      const s = {};\n      if (!date) return {\n        class: c,\n        style: s\n      };\n      const timeslotRespondents = this.responsesFormatted.get(date.getTime()) ?? new Set();\n\n      // Fill style\n\n      if (this.isSignUp) {\n        c += \"tw-bg-light-gray \";\n        return {\n          class: c,\n          style: s\n        };\n      }\n      if (!this.overlayAvailability && this.state === this.states.EDIT_AVAILABILITY || this.state === this.states.SET_SPECIFIC_TIMES) {\n        // Set default background color to red (unavailable)\n        s.backgroundColor = \"#E523230D\";\n\n        // Show only current user availability\n        const inDragRange = this.inDragRange(row, col);\n        if (inDragRange) {\n          // Set style if drag range goes over the current timeslot\n          if (this.dragType === this.DRAG_TYPES.ADD) {\n            if (this.state === this.states.SET_SPECIFIC_TIMES) {\n              c += \"tw-bg-white \";\n            } else {\n              if (this.availabilityType === availabilityTypes.AVAILABLE) {\n                s.backgroundColor = \"#00994C77\";\n              } else if (this.availabilityType === availabilityTypes.IF_NEEDED) {\n                c += \"tw-bg-yellow \";\n              }\n            }\n          } else if (this.dragType === this.DRAG_TYPES.REMOVE) {\n            if (this.state === this.states.SET_SPECIFIC_TIMES) {\n              c += \"tw-bg-gray \";\n            }\n          }\n        } else {\n          // Otherwise just show the current availability\n          // Show current availability from availability set\n          if (this.state === this.states.SET_SPECIFIC_TIMES) {\n            if (this.tempTimes.has(date.getTime())) {\n              c += \"tw-bg-white \";\n            } else {\n              c += \"tw-bg-gray \";\n            }\n          } else {\n            if (this.availability.has(date.getTime())) {\n              s.backgroundColor = \"#00994C77\";\n            } else if (this.ifNeeded.has(date.getTime())) {\n              c += \"tw-bg-yellow \";\n            }\n          }\n        }\n      }\n      if (this.state === this.states.SINGLE_AVAILABILITY) {\n        // Show only the currently selected respondent's availability\n        const respondent = this.curRespondent;\n        if (timeslotRespondents.has(respondent)) {\n          if (this.parsedResponses[respondent]?.ifNeeded?.has(date.getTime())) {\n            c += \"tw-bg-yellow \";\n          } else {\n            s.backgroundColor = \"#00994C77\";\n          }\n        } else {\n          s.backgroundColor = \"#E523230D\";\n        }\n        return {\n          class: c,\n          style: s\n        };\n      }\n      if (this.overlayAvailability || this.state === this.states.BEST_TIMES || this.state === this.states.HEATMAP || this.state === this.states.SCHEDULE_EVENT || this.state === this.states.SUBSET_AVAILABILITY) {\n        let numRespondents;\n        let max;\n        if (this.state === this.states.BEST_TIMES || this.state === this.states.HEATMAP || this.state === this.states.SCHEDULE_EVENT) {\n          numRespondents = timeslotRespondents.size;\n          max = this.max;\n        } else if (this.state === this.states.SUBSET_AVAILABILITY) {\n          numRespondents = [...timeslotRespondents].filter(r => this.curRespondentsSet.has(r)).length;\n          max = this.curRespondentsMax;\n        } else if (this.overlayAvailability) {\n          if ((this.userHasResponded || this.curGuestId?.length > 0) && timeslotRespondents.has(this.authUser?._id ?? this.curGuestId)) {\n            // Subtract 1 because we do not want to include current user's availability\n            numRespondents = timeslotRespondents.size - 1;\n            max = this.max;\n          } else {\n            numRespondents = timeslotRespondents.size;\n            max = this.max;\n          }\n        }\n        const totalRespondents = this.state === this.states.SUBSET_AVAILABILITY ? this.curRespondents.length : this.respondents.length;\n        if (this.defaultState === this.states.BEST_TIMES) {\n          if (max > 0 && numRespondents === max) {\n            // Only set timeslot to green for the times that most people are available\n            if (totalRespondents === 1 || this.overlayAvailability) {\n              // Make single responses less saturated\n              const green = \"#00994C88\";\n              s.backgroundColor = green;\n            } else {\n              const green = \"#00994C\";\n              s.backgroundColor = green;\n            }\n          }\n        } else if (this.defaultState === this.states.HEATMAP) {\n          if (numRespondents > 0) {\n            if (totalRespondents === 1) {\n              const respondentId = this.state === this.states.SUBSET_AVAILABILITY ? this.curRespondents[0] : this.respondents[0]._id;\n              if (this.parsedResponses[respondentId]?.ifNeeded?.has(date.getTime())) {\n                c += \"tw-bg-yellow \";\n              } else {\n                const green = \"#00994C88\";\n                s.backgroundColor = green;\n              }\n            } else {\n              // Determine color of timeslot based on number of people available\n              const frac = numRespondents / max;\n              const green = \"#00994C\";\n              let alpha;\n              if (!this.overlayAvailability) {\n                alpha = Math.floor(frac * (255 - 30)).toString(16).toUpperCase().substring(0, 2).padStart(2, \"0\");\n                if (frac == 1 && (this.curRespondents.length > 0 && max === this.curRespondents.length || this.curRespondents.length === 0 && max === this.respondents.length)) {\n                  alpha = \"FF\";\n                }\n              } else {\n                alpha = Math.floor(frac * (255 - 85)).toString(16).toUpperCase().substring(0, 2).padStart(2, \"0\");\n              }\n              s.backgroundColor = green + alpha;\n            }\n          } else if (totalRespondents === 1) {\n            const red = \"#E523230D\";\n            s.backgroundColor = red;\n          }\n        }\n      }\n      return {\n        class: c,\n        style: s\n      };\n    },\n    getDayTimeslotClassStyle(date, i) {\n      const row = Math.floor(i / 7);\n      const col = i % 7;\n      let classStyle;\n      // Only compute class style for days that are included\n      if (this.monthDayIncluded.get(date.getTime())) {\n        classStyle = this.getTimeslotClassStyle(date, row, col);\n        if (this.state === this.states.EDIT_AVAILABILITY) {\n          classStyle.class += \"tw-cursor-pointer \";\n        }\n        const backgroundColor = classStyle.style.backgroundColor;\n        if (backgroundColor && lightOrDark(removeTransparencyFromHex(backgroundColor)) === \"dark\") {\n          classStyle.class += \"tw-text-white \";\n        }\n      } else {\n        classStyle = {\n          class: \"tw-bg-off-white tw-text-gray \",\n          style: {}\n        };\n      }\n\n      // Change default red:\n      if (classStyle.style.backgroundColor === \"#E523230D\") {\n        classStyle.style.backgroundColor = \"#E523233B\";\n      }\n\n      // Change edit green\n      // if (classStyle.style.backgroundColor === \"#00994C88\") {\n      //   classStyle.style.backgroundColor = \"#29BC6880\"\n      // }\n\n      // Border style\n      if ((this.respondents.length > 0 || this.state === this.states.EDIT_AVAILABILITY) && this.curTimeslot.row === row && this.curTimeslot.col === col && this.monthDayIncluded.get(date.getTime())) {\n        // Dashed border for currently selected timeslot\n        classStyle.class += \"tw-outline-2 tw-outline-dashed tw-outline-black tw-z-10 \";\n      } else {\n        // Normal border\n        if (col === 0) classStyle.class += \"tw-border-l tw-border-l-gray \";\n        classStyle.class += \"tw-border-r tw-border-r-gray \";\n        if (col !== 7 - 1) {\n          classStyle.style.borderRightStyle = \"dashed\";\n        }\n        if (row === 0) classStyle.class += \"tw-border-t tw-border-t-gray \";\n        classStyle.class += \"tw-border-b tw-border-b-gray \";\n        if (row !== Math.floor(this.monthDays.length / 7) - 1) {\n          classStyle.style.borderBottomStyle = \"dashed\";\n        }\n      }\n      return classStyle;\n    },\n    getTimeslotVon(row, col) {\n      if (this.interactable) {\n        return {\n          click: () => {\n            if (this.timeslotSelected) {\n              // Get rid of persistent timeslot selection if clicked on the same timeslot that is currently being persisted\n              if (row === this.curTimeslot.row && col === this.curTimeslot.col) {\n                this.timeslotSelected = false;\n              }\n            } else if (this.state !== this.states.EDIT_AVAILABILITY && (this.userHasResponded || this.guestAddedAvailability)) {\n              // Persist timeslot selection if user has already responded\n              this.timeslotSelected = true;\n            }\n            this.showAvailability(row, col);\n          },\n          mousedown: () => {\n            // Highlight availability button\n            if (this.state === this.defaultState && (!this.isPhone && !(this.userHasResponded || this.guestAddedAvailability) || this.respondents.length == 0)) this.highlightAvailabilityBtn();\n          },\n          mouseover: () => {\n            // Only show availability on hover if timeslot is not being persisted\n            if (!this.timeslotSelected) {\n              this.showAvailability(row, col);\n              if (!this.event.daysOnly) {\n                const date = this.getDateFromRowCol(row, col);\n                if (date) {\n                  date.setTime(date.getTime() - this.timezoneOffset * 60 * 1000);\n                  const startDate = dayjs(date).utc();\n                  const endDate = dayjs(date).utc().add(this.timeslotDuration, \"minutes\");\n                  const timeFormat = this.timeType === timeTypes.HOUR12 ? \"h:mm A\" : \"HH:mm\";\n                  let dateFormat;\n                  if (this.isSpecificDates) {\n                    dateFormat = \"ddd, MMM D, YYYY\";\n                  } else {\n                    dateFormat = \"ddd\";\n                  }\n                  this.tooltipContent = `${startDate.format(dateFormat)} ${startDate.format(timeFormat)} to ${endDate.format(timeFormat)}`;\n                }\n              }\n            }\n          },\n          mouseleave: () => {\n            this.tooltipContent = \"\";\n          }\n        };\n      }\n      return {};\n    },\n    resetCurTimeslot() {\n      // Only reset cur timeslot if it isn't being persisted\n      if (this.timeslotSelected) return;\n      this.curTimeslotAvailability = {};\n      for (const respondent of this.respondents) {\n        this.curTimeslotAvailability[respondent._id] = true;\n      }\n      this.curTimeslot = {\n        row: -1,\n        col: -1\n      };\n\n      // End drag if mouse left time grid\n      this.endDrag();\n    },\n    //#endregion\n\n    // -----------------------------------\n    //#region Editing\n    // -----------------------------------\n    startEditing() {\n      this.state = this.isSignUp ? this.states.EDIT_SIGN_UP_BLOCKS : this.states.EDIT_AVAILABILITY;\n      this.availabilityType = availabilityTypes.AVAILABLE;\n      this.availability = new Set();\n      this.ifNeeded = new Set();\n      if (this.authUser && !this.addingAvailabilityAsGuest) {\n        this.resetCurUserAvailability();\n      }\n      this.$nextTick(() => this.unsavedChanges = false);\n      this.pageHasChanged = false;\n    },\n    stopEditing() {\n      this.state = this.defaultState;\n      this.stopAvailabilityAnim();\n\n      // Reset options\n      this.availabilityType = availabilityTypes.AVAILABLE;\n      this.overlayAvailability = false;\n    },\n    highlightAvailabilityBtn() {\n      this.$emit(\"highlightAvailabilityBtn\");\n    },\n    editGuestAvailability(id) {\n      if (this.authUser) {\n        this.$emit(\"addAvailabilityAsGuest\");\n      } else {\n        this.startEditing();\n      }\n      this.$nextTick(() => {\n        this.populateUserAvailability(id);\n        this.$emit(\"setCurGuestId\", id);\n      });\n    },\n    refreshEvent() {\n      this.$emit(\"refreshEvent\");\n    },\n    //#endregion\n\n    // -----------------------------------\n    //#region Schedule event\n    // -----------------------------------\n    scheduleEvent() {\n      this.state = this.states.SCHEDULE_EVENT;\n      this.$posthog?.capture(\"schedule_event_button_clicked\");\n    },\n    cancelScheduleEvent() {\n      this.state = this.defaultState;\n    },\n    /** Redirect user to Google Calendar to finish the creation of the event */\n    confirmScheduleEvent(googleCalendar = true) {\n      if (!this.curScheduledEvent) return;\n      // if (!isPremiumUser(this.authUser)) {\n      //   this.showUpgradeDialog({\n      //     type: upgradeDialogTypes.SCHEDULE_EVENT,\n      //     data: {\n      //       scheduledEvent: this.curScheduledEvent,\n      //     },\n      //   })\n      //   return\n      // }\n\n      this.$posthog?.capture(\"schedule_event_confirmed\");\n      // Get start date, and end date from the area that the user has dragged out\n      const {\n        col,\n        row,\n        numRows\n      } = this.curScheduledEvent;\n      let startDate = this.getDateFromRowCol(row, col);\n      let endDate = new Date(startDate);\n      endDate.setMinutes(startDate.getMinutes() + this.timeslotDuration * numRows);\n      if (this.isWeekly || this.isGroup) {\n        // Determine offset based on current day of the week.\n        // People expect the event to be scheduled in the future, not the past, which is why this check exists\n        let offset = 0;\n        if (this.isGroup) {\n          offset = this.weekOffset;\n        } else if (this.isWeekly) {\n          if (new Date().getDay() > startDate.getDay()) {\n            offset = 1;\n          }\n        }\n\n        // Transform startDate and endDate to be the current week offset\n        startDate = dateToDowDate(this.event.dates, startDate, offset, true);\n        endDate = dateToDowDate(this.event.dates, endDate, offset, true);\n      }\n\n      // Format email string separated by commas\n      const emails = this.respondents.map(r => {\n        // Return email if they are not a guest, otherwise return their name\n        if (r.email.length > 0) {\n          return r.email;\n        } else {\n          // return `${r.firstName} (no email)`\n          return null;\n        }\n      });\n      const emailsString = encodeURIComponent(emails.filter(Boolean).join(\",\"));\n      const eventId = this.event.shortId ?? this.event._id;\n      let url = \"\";\n      if (googleCalendar) {\n        // Format start and end date to be in the format required by gcal (remove -, :, and .000)\n        const start = startDate.toISOString().replace(/([-:]|\\.000)/g, \"\");\n        const end = endDate.toISOString().replace(/([-:]|\\.000)/g, \"\");\n\n        // Construct Google Calendar event creation template url\n        url = `https://calendar.google.com/calendar/render?action=TEMPLATE&text=${encodeURIComponent(this.event.name)}&dates=${start}/${end}&details=${encodeURIComponent(\"\\n\\nThis event was scheduled with schej: https://schej.it/e/\")}${eventId}&ctz=${this.curTimezone.value}&add=${emailsString}`;\n      } else {\n        url = `https://outlook.live.com/calendar/0/deeplink/compose?subject=${encodeURIComponent(this.event.name)}&body=${encodeURIComponent(\"\\n\\nThis event was scheduled with schej: https://schej.it/e/\" + eventId)}&startdt=${startDate.toISOString()}&enddt=${endDate.toISOString()}&location=${encodeURIComponent(this.event.location || \"\")}&path=/calendar/action/compose&timezone=${this.curTimezone.value}`;\n      }\n\n      // Navigate to url and reset state\n      window.open(url, \"_blank\");\n      this.state = this.defaultState;\n    },\n    //#endregion\n\n    // -----------------------------------\n    //#region Drag Stuff\n    // -----------------------------------\n    normalizeXY(e) {\n      /* Normalize the touch event to be relative to element */\n      let pageX, pageY;\n      if (\"touches\" in e) {\n        // is a touch event\n        ;\n        ({\n          pageX,\n          pageY\n        } = e.touches[0]);\n      } else {\n        // is a mouse event\n        ;\n        ({\n          pageX,\n          pageY\n        } = e);\n      }\n      const {\n        left,\n        top\n      } = e.currentTarget.getBoundingClientRect();\n      const x = pageX - left;\n      const y = pageY - top - window.scrollY;\n      return {\n        x,\n        y\n      };\n    },\n    clampRow(row) {\n      if (this.event.daysOnly) {\n        row = clamp(row, 0, Math.floor(this.monthDays.length / 7) - 1);\n      } else {\n        row = clamp(row, 0, this.times.length - 1);\n      }\n      return row;\n    },\n    clampCol(col) {\n      if (this.event.daysOnly) {\n        col = clamp(col, 0, 7 - 1);\n      } else {\n        col = clamp(col, 0, this.days.length - 1);\n      }\n      return col;\n    },\n    /** Returns row, col for the timeslot we are currently hovering over given the x and y position */\n    getRowColFromXY(x, y) {\n      const {\n        width,\n        height\n      } = this.timeslot;\n      let col = Math.floor(x / width);\n      if (!this.event.daysOnly) {\n        col = this.columnOffsets.length;\n        for (let i = 0; i < this.columnOffsets.length; ++i) {\n          if (x < this.columnOffsets[i]) {\n            col = i - 1;\n            break;\n          }\n        }\n      }\n      let row = Math.floor(y / height);\n\n      // Account for split gap\n      if (!this.event.daysOnly && row > this.splitTimes[0].length) {\n        const adjustedRow = Math.floor((y - this.SPLIT_GAP_HEIGHT) / height);\n        if (adjustedRow >= this.splitTimes[0].length) {\n          // Make sure we don't go to a lesser index\n          row = adjustedRow;\n        }\n      }\n      row = this.clampRow(row);\n      col = this.clampCol(col);\n      return {\n        row,\n        col\n      };\n    },\n    endDrag() {\n      if (!this.allowDrag) return;\n      if (!this.dragStart || !this.dragCur) return;\n\n      // Update availability set based on drag region\n      if (this.state === this.states.EDIT_AVAILABILITY || this.state === this.states.SET_SPECIFIC_TIMES) {\n        // Determine colInc and rowInc\n        let colInc = (this.dragCur.col - this.dragStart.col) / Math.abs(this.dragCur.col - this.dragStart.col);\n        let rowInc = (this.dragCur.row - this.dragStart.row) / Math.abs(this.dragCur.row - this.dragStart.row);\n        if (isNaN(colInc)) colInc = 1;\n        if (isNaN(rowInc)) rowInc = 1;\n\n        // Determine iteration variables\n        let rowStart = this.dragStart.row;\n        let rowMax = this.dragCur.row + rowInc;\n        let colStart = this.dragStart.col;\n        let colMax = this.dragCur.col + colInc;\n\n        // Correct iteration variables if days only\n        if (this.event.daysOnly) {\n          colStart = 0;\n          colMax = 7;\n          colInc = 1;\n        }\n\n        // Iterate all selected time slots and either add or remove them\n        for (let r = rowStart; r != rowMax; r += rowInc) {\n          for (let c = colStart; c != colMax; c += colInc) {\n            const date = this.getDateFromRowCol(r, c);\n            if (!date) continue;\n            if (this.event.daysOnly) {\n              // Don't add to availability set if month day is not included\n              const isMonthDayIncluded = this.monthDayIncluded.get(date.getTime()) && this.inDragRange(r, c);\n              if (!isMonthDayIncluded) continue;\n            }\n            if (this.dragType === this.DRAG_TYPES.ADD) {\n              if (this.state === this.states.SET_SPECIFIC_TIMES) {\n                this.tempTimes.add(date.getTime());\n              } else {\n                // Add / remove time from availability set\n                if (this.availabilityType === availabilityTypes.AVAILABLE) {\n                  this.availability.add(date.getTime());\n                  this.ifNeeded.delete(date.getTime());\n                } else if (this.availabilityType === availabilityTypes.IF_NEEDED) {\n                  this.ifNeeded.add(date.getTime());\n                  this.availability.delete(date.getTime());\n                }\n              }\n            } else if (this.dragType === this.DRAG_TYPES.REMOVE) {\n              if (this.state === this.states.SET_SPECIFIC_TIMES) {\n                this.tempTimes.delete(date.getTime());\n              } else {\n                // Add / remove time from availability set\n                this.availability.delete(date.getTime());\n                this.ifNeeded.delete(date.getTime());\n              }\n            }\n\n            // Edit manualAvailability set if event is a GROUP\n            if (this.event.type === eventTypes.GROUP) {\n              const discreteDate = dateToDowDate(this.event.dates, date, this.weekOffset, true);\n              const startDateOfDay = dateToDowDate(this.event.dates, this.days[c].dateObject, this.weekOffset, true);\n\n              // If date not touched, then add all of the existing calendar availabilities and mark it as touched\n              if (!(startDateOfDay.getTime() in this.manualAvailability)) {\n                // Create new set\n                this.manualAvailability[startDateOfDay.getTime()] = new Set();\n\n                // Add the existing calendar availabilities\n                const existingAvailability = this.getAvailabilityForColumn(c);\n                for (const a of existingAvailability) {\n                  const convertedDate = dateToDowDate(this.event.dates, new Date(a), this.weekOffset, true);\n                  this.manualAvailability[startDateOfDay.getTime()].add(convertedDate.getTime());\n                }\n              }\n\n              // Add / remove time from manual availability set\n              if (this.dragType === this.DRAG_TYPES.ADD) {\n                this.manualAvailability[startDateOfDay.getTime()].add(discreteDate.getTime());\n              } else if (this.dragType === this.DRAG_TYPES.REMOVE) {\n                this.manualAvailability[startDateOfDay.getTime()].delete(discreteDate.getTime());\n              }\n            }\n          }\n        }\n        this.availability = new Set(this.availability);\n      } else if (this.state === this.states.SCHEDULE_EVENT) {\n        // Update scheduled event\n        const col = this.dragStart.col;\n        const row = this.dragStart.row;\n        const numRows = this.dragCur.row - this.dragStart.row + 1;\n        if (numRows > 0) {\n          this.curScheduledEvent = {\n            col,\n            row,\n            numRows\n          };\n        } else {\n          this.curScheduledEvent = null;\n        }\n      } else if (this.state === this.states.EDIT_SIGN_UP_BLOCKS) {\n        // Update sign up blocks\n        const dayIndex = this.dragStart.col;\n        const hoursOffset = this.dragStart.row / 4;\n        const hoursLength = (this.dragCur.row - this.dragStart.row + 1) / 4;\n        if (hoursLength > 0) {\n          this.signUpBlocksToAddByDay[dayIndex].push(this.createSignUpBlock(dayIndex, hoursOffset, hoursLength));\n        }\n      }\n\n      // Set dragging defaults\n      this.dragging = false;\n      this.dragStart = null;\n      this.dragCur = null;\n    },\n    inDragRange(row, col) {\n      /* Returns whether the given row and col is within the drag range */\n      if (this.dragging) {\n        if (this.event.daysOnly) {\n          if (isBetween(row, this.dragStart.row, this.dragCur.row) || isBetween(row, this.dragCur.row, this.dragStart.row)) {\n            if (this.dragCur.row < this.dragStart.row) {\n              return this.dragCur.row === row && this.dragCur.col <= col || this.dragStart.row === row && this.dragStart.col >= col || this.dragStart.row !== row && this.dragCur.row !== row;\n            } else if (this.dragCur.row > this.dragStart.row) {\n              return this.dragCur.row === row && this.dragCur.col >= col || this.dragStart.row === row && this.dragStart.col <= col || this.dragStart.row !== row && this.dragCur.row !== row;\n            } else {\n              // cur row == start row\n              return isBetween(col, this.dragStart.col, this.dragCur.col) || isBetween(col, this.dragCur.col, this.dragStart.col);\n            }\n          }\n          return false;\n        }\n        return (isBetween(row, this.dragStart.row, this.dragCur.row) || isBetween(row, this.dragCur.row, this.dragStart.row)) && (isBetween(col, this.dragStart.col, this.dragCur.col) || isBetween(col, this.dragCur.col, this.dragStart.col));\n      }\n      return false;\n    },\n    moveDrag(e) {\n      if (!this.allowDrag) return;\n      if (e.touches?.length > 1) return; // If dragging with more than one finger\n      if (!this.dragStart) return;\n      e.preventDefault();\n      let {\n        row,\n        col\n      } = this.getRowColFromXY(...Object.values(this.normalizeXY(e)));\n      if (this.maxSignUpBlockRowSize && row >= this.dragStart.row + this.maxSignUpBlockRowSize) {\n        row = this.dragStart.row + this.maxSignUpBlockRowSize - 1;\n      } else if (this.state === this.states.SCHEDULE_EVENT) {\n        const isFirstSplit = this.dragStart.row < this.splitTimes[0].length;\n        if (isFirstSplit) {\n          row = Math.min(row, this.splitTimes[0].length - 1);\n        }\n      }\n      this.dragCur = {\n        row,\n        col\n      };\n    },\n    startDrag(e) {\n      const {\n        row,\n        col\n      } = this.getRowColFromXY(...Object.values(this.normalizeXY(e)));\n\n      // If sign up form, check if trying to drag in a block\n      if (this.isSignUp) {\n        for (const block of this.signUpBlocksByDay[col].concat(this.signUpBlocksToAddByDay[col])) {\n          if (isBetween(row, block.hoursOffset * 4, (block.hoursOffset + block.hoursLength) * 4 - 1)) {\n            this.$refs.signUpBlocksList.scrollToSignUpBlock(block._id);\n            return;\n          }\n        }\n      }\n      if (!this.allowDrag) return;\n      if (e.touches?.length > 1) return; // If dragging with more than one finger\n\n      const date = this.getDateFromRowCol(row, col);\n      if (!date) return;\n\n      // Dont start dragging if day not included in daysonly event\n      if (this.event.daysOnly && !this.monthDayIncluded.get(date.getTime())) {\n        return;\n      }\n      this.dragging = true;\n      this.dragStart = {\n        row,\n        col\n      };\n      this.dragCur = {\n        row,\n        col\n      };\n\n      // Prevent scroll\n      e.preventDefault();\n\n      // Set drag type\n      if (this.isSignUp) {\n        this.dragType = this.DRAG_TYPES.ADD;\n      } else if (this.state === this.states.SET_SPECIFIC_TIMES && this.tempTimes.has(date.getTime()) || this.availabilityType === availabilityTypes.AVAILABLE && this.availability.has(date.getTime()) || this.availabilityType === availabilityTypes.IF_NEEDED && this.ifNeeded.has(date.getTime())) {\n        this.dragType = this.DRAG_TYPES.REMOVE;\n      } else {\n        this.dragType = this.DRAG_TYPES.ADD;\n      }\n    },\n    //#endregion\n\n    // -----------------------------------\n    //#region Options\n    // -----------------------------------\n    getLocalTimezone() {\n      const split = new Date(this.event.dates[0]).toLocaleTimeString(\"en-us\", {\n        timeZoneName: \"short\"\n      }).split(\" \");\n      const localTimezone = split[split.length - 1];\n      return localTimezone;\n    },\n    onShowBestTimesChange() {\n      localStorage[\"showBestTimes\"] = this.showBestTimes;\n      if (this.state == this.states.BEST_TIMES || this.state == this.states.HEATMAP) this.state = this.defaultState;\n    },\n    toggleShowEditOptions() {\n      this.showEditOptions = !this.showEditOptions;\n      localStorage[\"showEditOptions\"] = this.showEditOptions;\n    },\n    toggleShowEventOptions() {\n      this.showEventOptions = !this.showEventOptions;\n      localStorage[\"showEventOptions\"] = this.showEventOptions;\n    },\n    updateOverlayAvailability(val) {\n      this.overlayAvailability = !!val;\n      this.$posthog?.capture(\"overlay_availability_toggled\", {\n        enabled: !!val\n      });\n    },\n    //#endregion\n\n    // -----------------------------------\n    //#region Scroll\n    // -----------------------------------\n    onCalendarScroll(e) {\n      this.calendarMaxScroll = e.target.scrollWidth - e.target.offsetWidth;\n      this.calendarScrollLeft = e.target.scrollLeft;\n    },\n    onScroll(e) {\n      this.checkElementsVisible();\n    },\n    /** Checks whether certain elements are visible and sets variables accoringly */\n    checkElementsVisible() {\n      const optionsSectionEl = this.$refs.optionsSection;\n      if (optionsSectionEl) {\n        this.optionsVisible = isElementInViewport(optionsSectionEl, {\n          bottomOffset: -64\n        });\n      }\n      const respondentsListEl = this.$refs.respondentsList?.$el;\n      if (respondentsListEl) {\n        this.scrolledToRespondents = isElementInViewport(respondentsListEl, {\n          bottomOffset: -64\n        });\n      }\n    },\n    //#endregion\n\n    // -----------------------------------\n    //#region Pagination\n    // -----------------------------------\n    nextPage(e) {\n      e.stopImmediatePropagation();\n      if (this.event.type === eventTypes.GROUP) {\n        // Go to next page if there are still more days left to see\n        // Otherwise, update week offset\n        if ((this.page + 1) * this.maxDaysPerPage < this.allDays.length) {\n          this.page++;\n        } else {\n          this.page = 0;\n          this.$emit(\"update:weekOffset\", this.weekOffset + 1);\n        }\n      } else {\n        this.page++;\n      }\n      this.pageHasChanged = true;\n    },\n    prevPage(e) {\n      e.stopImmediatePropagation();\n      if (this.event.type === eventTypes.GROUP) {\n        // Go to prev page if there is a prev page\n        // Otherwise, update week offset\n        if (this.page > 0) {\n          this.page--;\n        } else {\n          this.page = Math.ceil(this.allDays.length / this.maxDaysPerPage) - 1;\n          this.$emit(\"update:weekOffset\", this.weekOffset - 1);\n        }\n      } else {\n        this.page--;\n      }\n      this.pageHasChanged = true;\n    },\n    //#endregion\n\n    // -----------------------------------\n    //#region Resize\n    // -----------------------------------\n    onResize() {\n      this.setTimeslotSize();\n    },\n    //#endregion\n\n    // -----------------------------------\n    //#region hint\n    // -----------------------------------\n    closeHint() {\n      this.hintState = false;\n      localStorage[this.hintStateLocalStorageKey] = true;\n    },\n    //#endregion\n\n    // -----------------------------------\n    //#region Group\n    // -----------------------------------\n\n    /** Toggles calendar account - in groups to enable/disable calendars */\n    toggleCalendarAccount(payload) {\n      this.sharedCalendarAccounts[getCalendarAccountKey(payload.email, payload.calendarType)].enabled = payload.enabled;\n      this.sharedCalendarAccounts = JSON.parse(JSON.stringify(this.sharedCalendarAccounts));\n    },\n    /** Toggles sub calendar account - in groups to enable/disable sub calendars */\n    toggleSubCalendarAccount(payload) {\n      this.sharedCalendarAccounts[getCalendarAccountKey(payload.email, payload.calendarType)].subCalendars[payload.subCalendarId].enabled = payload.enabled;\n      this.sharedCalendarAccounts = JSON.parse(JSON.stringify(this.sharedCalendarAccounts));\n    },\n    /** Sets the initial sharedCalendarAccounts object */\n    initSharedCalendarAccounts() {\n      if (!this.authUser) return;\n\n      // Init shared calendar accounts to current calendar accounts\n      this.sharedCalendarAccounts = JSON.parse(JSON.stringify(this.authUser.calendarAccounts));\n\n      // Disable all calendars\n      for (const id in this.sharedCalendarAccounts) {\n        this.sharedCalendarAccounts[id].enabled = false;\n        if (this.sharedCalendarAccounts[id].subCalendars) {\n          for (const subCalendarId in this.sharedCalendarAccounts[id].subCalendars) {\n            this.sharedCalendarAccounts[id].subCalendars[subCalendarId].enabled = false;\n          }\n        }\n      }\n\n      // Enable calendars based on responses\n      if (this.authUser._id in this.event.responses) {\n        const enabledCalendars = this.event.responses[this.authUser._id].enabledCalendars;\n        for (const id in enabledCalendars) {\n          this.sharedCalendarAccounts[id].enabled = true;\n          enabledCalendars[id].forEach(subCalendarId => {\n            this.sharedCalendarAccounts[id].subCalendars[subCalendarId].enabled = true;\n          });\n        }\n      }\n    },\n    /** Based on the date, determine whether it has been touched */\n    isTouched(date, availability = [...this.availability]) {\n      const start = new Date(date);\n      const end = new Date(date);\n      end.setHours(end.getHours() + this.event.duration);\n      for (const a of availability) {\n        const availableTime = new Date(a).getTime();\n        if (start.getTime() <= availableTime && availableTime <= end.getTime()) {\n          return true;\n        }\n      }\n      return false;\n    },\n    /** Returns a subset of availability for the current date */\n    getAvailabilityForColumn(column, availability = [...this.availability]) {\n      const subset = new Set();\n      const availabilitySet = new Set(availability);\n      for (let r = 0; r < this.splitTimes[0].length + this.splitTimes[1].length; ++r) {\n        const date = this.getDateFromRowCol(r, column);\n        if (!date) continue;\n        if (availabilitySet.has(date.getTime())) {\n          subset.add(date.getTime());\n        }\n      }\n      return subset;\n    },\n    /** Returns a copy of the manual availability, converted to dow dates */\n    getManualAvailabilityDow(manualAvailability = this.manualAvailability) {\n      if (!manualAvailability) return null;\n      const manualAvailabilityDow = {};\n      for (const time in manualAvailability) {\n        const dowTime = dateToDowDate(this.event.dates, new Date(parseInt(time)), this.weekOffset).getTime();\n        manualAvailabilityDow[dowTime] = [...manualAvailability[time]].map(a => dateToDowDate(this.event.dates, new Date(a), this.weekOffset));\n      }\n      return manualAvailabilityDow;\n    },\n    //#endregion\n\n    // -----------------------------------\n    //#region Sign up form\n    // -----------------------------------\n\n    /** Creates a sign up block for the current day and hour offset */\n    createSignUpBlock(dayIndex, hoursOffset, hoursLength) {\n      const timeBlock = getTimeBlock(this.days[dayIndex].dateObject, hoursOffset, hoursLength);\n      return {\n        _id: ObjectID().toString(),\n        capacity: 1,\n        name: this.newSignUpBlockName,\n        ...timeBlock,\n        hoursOffset,\n        hoursLength\n      };\n    },\n    /** Updates the sign up block with the same id */\n    editSignUpBlock(signUpBlock) {\n      this.signUpBlocksByDay.forEach((blocksInDay, dayIndex) => {\n        blocksInDay.forEach((block, blockIndex) => {\n          if (signUpBlock._id === block._id) {\n            this.signUpBlocksByDay[dayIndex][blockIndex] = signUpBlock;\n            this.signUpBlocksByDay = [...this.signUpBlocksByDay];\n            return;\n          }\n        });\n      });\n      this.signUpBlocksToAddByDay.forEach((blocksInDay, dayIndex) => {\n        blocksInDay.forEach((block, blockIndex) => {\n          if (signUpBlock._id === block._id) {\n            this.signUpBlocksToAddByDay[dayIndex][blockIndex] = signUpBlock;\n            this.signUpBlocksToAddByDay = [...this.signUpBlocksToAddByDay];\n            return;\n          }\n        });\n      });\n    },\n    /** Deletes the sign up block with the id */\n    deleteSignUpBlock(signUpBlockId) {\n      this.signUpBlocksByDay.forEach((blocksInDay, dayIndex) => {\n        blocksInDay.forEach((block, blockIndex) => {\n          if (signUpBlockId === block._id) {\n            this.signUpBlocksByDay[dayIndex].splice(blockIndex, 1);\n            return;\n          }\n        });\n      });\n      this.signUpBlocksToAddByDay.forEach((blocksInDay, dayIndex) => {\n        blocksInDay.forEach((block, blockIndex) => {\n          if (signUpBlockId === block._id) {\n            this.signUpBlocksToAddByDay[dayIndex].splice(blockIndex, 1);\n            return;\n          }\n        });\n      });\n    },\n    /** Reloads all the data for the sign up form */\n    resetSignUpForm() {\n      /** Split sign up blocks by day */\n      this.signUpBlocksByDay = splitTimeBlocksByDay(this.event, this.event.signUpBlocks ?? []);\n      this.resetSignUpBlocksToAddByDay();\n\n      /** Populate sign up block responses */\n      for (const userId in this.event.signUpResponses) {\n        const signUpResponse = this.event.signUpResponses[userId];\n        for (const signUpBlockId of signUpResponse.signUpBlockIds) {\n          const signUpBlock = this.signUpBlocksByDay.flat().find(signUpBlock => signUpBlock._id === signUpBlockId);\n          if (!signUpBlock.responses) signUpBlock.responses = [];\n          signUpBlock.responses.push(signUpResponse);\n        }\n      }\n    },\n    /** Initialize sign up blocks to be added array */\n    resetSignUpBlocksToAddByDay() {\n      this.signUpBlocksToAddByDay = [];\n      for (const day of this.signUpBlocksByDay) {\n        this.signUpBlocksToAddByDay.push([]);\n      }\n    },\n    /** Emits sign up for block to parent element */\n    handleSignUpBlockClick(block) {\n      if (!this.alreadyRespondedToSignUpForm && !this.isOwner) this.$emit(\"signUpForBlock\", block);\n    },\n    //#endregion\n\n    // -----------------------------------\n    //#region Specific times for specific days\n    // -----------------------------------\n\n    /** Saves the temporary times to the event */\n    saveTempTimes() {\n      // Set event times\n      this.event.times = [...this.tempTimes].map(t => new Date(t)).sort((a, b) => a.getTime() - b.getTime());\n      const {\n        minHours,\n        maxHours\n      } = this.getMinMaxHoursFromTimes(this.event.times);\n\n      // Set event dates to start at the new times\n      for (let i = 0; i < this.event.dates.length; ++i) {\n        const date = new Date(this.event.dates[i]);\n        date.setTime(date.getTime() - this.timezoneOffset * 60 * 1000);\n        date.setUTCHours(minHours, 0, 0, 0);\n        date.setTime(date.getTime() + this.timezoneOffset * 60 * 1000);\n        this.event.dates[i] = date.toISOString();\n      }\n\n      // Set event duration to the difference between the max and min hours\n      this.event.duration = maxHours - minHours + 1;\n\n      // Update event\n      put(`/events/${this.event._id}`, this.event).then(() => {\n        this.state = this.defaultState;\n      }).catch(err => {\n        this.showError(err);\n      });\n    },\n    /** Returns the min and max hours from the times */\n    getMinMaxHoursFromTimes(times) {\n      let minHours = 24;\n      let maxHours = 0;\n      for (const time of times) {\n        const timeDate = new Date(time);\n        const date = new Date(timeDate.getTime() - this.timezoneOffset * 60 * 1000);\n        const localHours = date.getUTCHours();\n        if (localHours < minHours) {\n          minHours = localHours;\n        } else if (localHours > maxHours) {\n          maxHours = localHours;\n        }\n      }\n      return {\n        minHours,\n        maxHours\n      };\n    },\n    //#endregion\n\n    /** Recalculate availability the calendar based on calendar events */\n    reanimateAvailability() {\n      if (this.state === this.states.EDIT_AVAILABILITY && this.authUser && !(this.authUser?._id in this.event.responses) &&\n      // User hasn't responded yet\n      !this.loadingCalendarEvents && (!this.unsavedChanges || this.availabilityAnimEnabled)) {\n        for (const timeout of this.availabilityAnimTimeouts) {\n          clearTimeout(timeout);\n        }\n        this.setAvailabilityAutomatically();\n      }\n    }\n  },\n  watch: {\n    availability() {\n      if (this.state === this.states.EDIT_AVAILABILITY) {\n        this.unsavedChanges = true;\n      }\n    },\n    event: {\n      immediate: true,\n      handler() {\n        this.initSharedCalendarAccounts();\n        this.fetchResponses();\n      }\n    },\n    state(nextState, prevState) {\n      this.$nextTick(() => this.checkElementsVisible());\n\n      // Reset scheduled event when exiting schedule event state\n      if (prevState === this.states.SCHEDULE_EVENT) {\n        this.curScheduledEvent = null;\n      } else if (prevState === this.states.EDIT_AVAILABILITY) {\n        this.unsavedChanges = false;\n      }\n      if (nextState === this.states.SET_SPECIFIC_TIMES) {\n        this.$nextTick(() => {\n          const time9 = document.getElementById(\"time-9\");\n          if (time9) {\n            const yOffset = -150;\n            const y = time9.getBoundingClientRect().top + window.scrollY + yOffset;\n            window.scrollTo({\n              top: y,\n              behavior: \"smooth\"\n            });\n          }\n        });\n      }\n    },\n    respondents: {\n      immediate: true,\n      handler() {\n        this.curTimeslotAvailability = {};\n        for (const respondent of this.respondents) {\n          this.curTimeslotAvailability[respondent._id] = true;\n        }\n      }\n    },\n    calendarEventsByDay(val, oldVal) {\n      if (JSON.stringify(val) !== JSON.stringify(oldVal)) {\n        this.reanimateAvailability();\n      }\n    },\n    page() {\n      this.$nextTick(() => {\n        this.setTimeslotSize();\n      });\n    },\n    allDays() {\n      this.$nextTick(() => {\n        this.setTimeslotSize();\n      });\n    },\n    showStickyRespondents: {\n      immediate: true,\n      handler(cur) {\n        clearTimeout(this.delayedShowStickyRespondentsTimeout);\n        this.delayedShowStickyRespondentsTimeout = setTimeout(() => {\n          this.delayedShowStickyRespondents = cur;\n        }, 100);\n      }\n    },\n    maxDaysPerPage() {\n      // Set page to 0 if user switches from portrait to landscape orientation and we're on an invalid page number,\n      // i.e. we're on a page that displays 0 days\n      if (this.page * this.maxDaysPerPage >= this.allDays.length) {\n        this.page = 0;\n      }\n    },\n    mobileNumDays() {\n      // Save mobile num days in localstorage\n      localStorage[\"mobileNumDays\"] = this.mobileNumDays;\n\n      // Set timeslot size because it has changed\n      this.$nextTick(() => {\n        this.setTimeslotSize();\n      });\n    },\n    weekOffset() {\n      if (this.event.type === eventTypes.GROUP) {\n        this.fetchResponses();\n      }\n    },\n    hideIfNeeded() {\n      this.getResponsesFormatted();\n    },\n    parsedResponses() {\n      // Theoretically, parsed responses should only be changing for groups\n      this.getResponsesFormatted();\n\n      // Repopulate user availability when editing availability (this happens when switching weeks in a group)\n      if (this.event.type === eventTypes.GROUP && this.state === this.states.EDIT_AVAILABILITY && this.authUser) {\n        this.availability = new Set();\n        this.populateUserAvailability(this.authUser._id);\n      }\n    },\n    showBestTimes() {\n      this.onShowBestTimesChange();\n    },\n    startCalendarOnMonday() {\n      localStorage[\"startCalendarOnMonday\"] = this.startCalendarOnMonday;\n    },\n    bufferTime(cur, prev) {\n      if (cur.enabled !== prev.enabled || cur.enabled) {\n        this.reanimateAvailability();\n      }\n    },\n    workingHours(cur, prev) {\n      if (cur.enabled !== prev.enabled || cur.enabled) {\n        this.reanimateAvailability();\n      }\n    },\n    timeType() {\n      localStorage[\"timeType\"] = this.timeType;\n    },\n    fromEditEvent() {\n      if (this.fromEditEvent && this.isSpecificTimes) {\n        this.tempTimes = new Set(this.event.times.map(t => new Date(t).getTime()));\n        this.state = this.states.SET_SPECIFIC_TIMES;\n      }\n    }\n  },\n  created() {\n    this.resetCurUserAvailability();\n    addEventListener(\"click\", this.deselectRespondents);\n  },\n  mounted() {\n    // Get query parameters from URL\n    const urlParams = new URLSearchParams(window.location.search);\n\n    // Set initial state\n    if (this.event.hasSpecificTimes && (this.fromEditEvent || !this.event.times || this.event.times.length === 0)) {\n      this.state = this.states.SET_SPECIFIC_TIMES;\n    } else if (urlParams.get(\"scheduled_event\")) {\n      const scheduledEvent = JSON.parse(urlParams.get(\"scheduled_event\"));\n      this.curScheduledEvent = scheduledEvent;\n      this.state = this.states.SCHEDULE_EVENT;\n\n      // Remove the scheduled_event parameter from URL to avoid reloading the same state\n      const newUrl = new URL(window.location.href);\n      newUrl.searchParams.delete(\"scheduled_event\");\n      window.history.replaceState({}, document.title, newUrl.toString());\n    } else if (this.showBestTimes) {\n      this.state = \"best_times\";\n    } else {\n      this.state = \"heatmap\";\n    }\n\n    // Set calendar options defaults\n    if (this.authUser) {\n      this.bufferTime = this.authUser?.calendarOptions?.bufferTime ?? calendarOptionsDefaults.bufferTime;\n      this.workingHours = this.authUser?.calendarOptions?.workingHours ?? calendarOptionsDefaults.workingHours;\n      if (this.isGroup) {\n        if (this.event.responses[this.authUser._id]?.calendarOptions) {\n          // Update calendar options if user has changed them for this specific group\n          const {\n            bufferTime,\n            workingHours\n          } = this.event.responses[this.authUser._id]?.calendarOptions;\n          if (bufferTime) this.bufferTime = bufferTime;\n          if (workingHours) this.workingHours = workingHours;\n        } else {\n          this.bufferTime = calendarOptionsDefaults.bufferTime;\n          this.workingHours = calendarOptionsDefaults.workingHours;\n        }\n      }\n    }\n\n    // Set initial calendar max scroll\n    // this.calendarMaxScroll =\n    //   this.$refs.calendar.scrollWidth - this.$refs.calendar.offsetWidth\n\n    // Get timeslot size\n    this.setTimeslotSize();\n    addEventListener(\"resize\", this.onResize);\n    addEventListener(\"scroll\", this.onScroll);\n    if (!this.calendarOnly) {\n      const timesEl = document.getElementById(\"drag-section\");\n      if (isTouchEnabled()) {\n        timesEl.addEventListener(\"touchstart\", this.startDrag);\n        timesEl.addEventListener(\"touchmove\", this.moveDrag);\n        timesEl.addEventListener(\"touchend\", this.endDrag);\n        timesEl.addEventListener(\"touchcancel\", this.endDrag);\n      }\n      timesEl.addEventListener(\"mousedown\", this.startDrag);\n      timesEl.addEventListener(\"mousemove\", this.moveDrag);\n      timesEl.addEventListener(\"mouseup\", this.endDrag);\n    }\n\n    // Parse sign up blocks and responses\n    this.resetSignUpForm();\n  },\n  beforeDestroy() {\n    removeEventListener(\"click\", this.deselectRespondents);\n    removeEventListener(\"resize\", this.onResize);\n    removeEventListener(\"scroll\", this.onScroll);\n  },\n  components: {\n    AlertText,\n    AvailabilityTypeToggle,\n    ExpandableSection,\n    BufferTimeSwitch,\n    UserAvatarContent,\n    ZigZag,\n    ConfirmDetailsDialog,\n    ToolRow,\n    CalendarAccounts,\n    RespondentsList,\n    Advertisement,\n    GCalWeekSelector,\n    WorkingHoursToggle,\n    SignUpBlock,\n    SignUpCalendarBlock,\n    SignUpBlocksList,\n    CalendarEventBlock,\n    // Added component registration\n    SpecificTimesInstructions,\n    // Added component registration\n    Tooltip\n  }\n};","map":{"version":3,"names":["timeNumToTimeText","dateCompare","getDateHoursOffset","post","put","isBetween","clamp","isPhone","utcTimeToLocalTime","splitTimeBlocksByDay","getTimeBlock","dateToDowDate","_delete","get","getDateDayOffset","isDateBetween","generateEnabledCalendarsPayload","isTouchEnabled","isElementInViewport","lightOrDark","removeTransparencyFromHex","userPrefers12h","getCalendarAccountKey","getISODateString","getDateWithTimezone","timeNumToTimeString","isPremiumUser","availabilityTypes","calendarOptionsDefaults","eventTypes","timeTypes","timeslotDurations","upgradeDialogTypes","mapMutations","mapActions","mapState","UserAvatarContent","CalendarAccounts","Advertisement","SignUpBlock","SignUpCalendarBlock","SignUpBlocksList","ZigZag","ConfirmDetailsDialog","ToolRow","RespondentsList","GCalWeekSelector","ExpandableSection","WorkingHoursToggle","AlertText","Tooltip","dayjs","locale","ObjectID","utcPlugin","timezonePlugin","AvailabilityTypeToggle","BufferTimeSwitch","CalendarEventBlock","SpecificTimesInstructions","extend","name","props","event","type","Object","required","fromEditEvent","Boolean","default","loadingCalendarEvents","calendarEventsMap","sampleCalendarEventsByDay","Array","calendarPermissionGranted","weekOffset","Number","alwaysShowCalendarEvents","noEventNames","calendarOnly","interactable","showSnackbar","animateTimeslotAlways","showHintText","curGuestId","String","addingAvailabilityAsGuest","initialTimezone","calendarAvailabilities","data","states","HEATMAP","SINGLE_AVAILABILITY","SUBSET_AVAILABILITY","BEST_TIMES","EDIT_AVAILABILITY","EDIT_SIGN_UP_BLOCKS","SCHEDULE_EVENT","SET_SPECIFIC_TIMES","state","availability","Set","ifNeeded","tempTimes","availabilityAnimTimeouts","availabilityAnimEnabled","maxAnimTime","unsavedChanges","curTimeslot","row","col","timeslotSelected","curTimeslotAvailability","curRespondent","curRespondents","sharedCalendarAccounts","fetchedResponses","loadingResponses","loading","lastFetched","Date","getTime","responsesFormatted","Map","tooltipContent","signUpBlocksByDay","signUpBlocksToAddByDay","showEditOptions","localStorage","undefined","availabilityType","AVAILABLE","overlayAvailability","bufferTime","workingHours","showEventOptions","showBestTimes","hideIfNeeded","DRAG_TYPES","ADD","REMOVE","SPLIT_GAP_HEIGHT","SPLIT_GAP_WIDTH","HOUR_HEIGHT","timeslot","width","height","dragging","dragType","dragStart","dragCur","curTimezone","curScheduledEvent","timeType","HOUR12","HOUR24","showCalendarEvents","startCalendarOnMonday","deleteAvailabilityDialog","calendarOptionsDialog","optionsVisible","calendarScrollLeft","calendarMaxScroll","scrolledToRespondents","delayedShowStickyRespondents","delayedShowStickyRespondentsTimeout","page","mobileNumDays","parseInt","pageHasChanged","hasRefreshedAuthUser","hintState","manualAvailability","months","computed","rightSideWidth","isSignUp","daysOfWeek","allowScheduleEvent","availabilityArray","map","item","ifNeededArray","allowDrag","calendarEventsByDay","authUser","events","calendarAccounts","isGroup","id","enabled","hasOwnProperty","index","calendarEvents","subCalendars","calendarId","push","refreshAuthUser","eventsCopy","JSON","parse","stringify","timezoneOffset","groupCalendarEventsByDay","GROUP","userIdToEventsByDay","userId","responses","_id","curRespondentsSet","newSignUpBlockName","flat","length","maxSignUpBlockRowSize","selectedDay","selectedDayToAdd","maxSize","Infinity","block","hoursOffset","Math","min","alreadyRespondedToSignUpForm","some","dayBlocks","response","curRespondentsMax","max","daysOnly","day","allDays","num","dateObject","filter","r","has","i","dates","date","time","times","getRespondentsForHoursOffset","dayOffset","floor","startTime","days","datesSoFar","getDateString","dateString","dayString","offsetDate","isSpecificTimes","setTime","setDate","getDate","format","getUTCDay","prevDate","localDate","setUTCHours","add","isConsecutive","dayText","dayIndex","localStart","localEnd","duration","localEndIsMidnight","getUTCHours","getUTCMinutes","getUTCDate","nextDate","setUTCDate","splice","excludeTimes","slice","maxDaysPerPage","monthDays","allDaysSet","d","monthIndex","getUTCMonth","year","getUTCFullYear","lastDayOfPrevMonth","UTC","lastDayOfCurMonth","curDate","numDaysFromPrevMonth","numDaysInCurMonth","numDaysFromNextMonth","hasDaysFromPrevMonth","totalDays","included","monthDayIncluded","includedMap","monthDay","set","curMonthText","defaultState","editing","scheduling","$vuetify","isOwner","ownerId","isSpecificDates","SPECIFIC_DATES","isWeekly","DOW","isSignUpForm","hasSpecificTimes","respondents","values","parsedResponses","user","selectedGuestRespondent","guestAddedAvailability","guestName","isGuest","scheduledEventStyle","style","top","isSecondSplit","splitTimes","numRows","timeslotHeight","signUpBlockBeingDraggedStyle","parsed","fetchedManualAvailability","getManualAvailabilityDow","curManualAvailability","getAvailabilityFromCalendarEvents","includeTouchedAvailability","calendarOptions","blindAvailabilityEnabled","guestNameKey","a","k","keys","newUser","dateTime","size","specificTimesSet","t","utcStartTime","utcEndTime","localStartTime","localEndTime","isWeirdTimezone","startTimeIsWeird","timeOffset","getExtraTimes","timeslotDuration","FIFTEEN_MINUTES","THIRTY_MINUTES","text","adjustedI","utcTimeNum","localTimeNum","timeIncrement","ONE_HOUR","getTimezoneOffset","offset","tz","value","utcOffset","userHasResponded","showLeftZigZag","showRightZigZag","ceil","hasNextPage","lastDay","hasPrevPage","hasPages","showStickyRespondents","hintText","daysOrTimes","IF_NEEDED","hintClosed","hintStateLocalStorageKey","hintTextShown","timeslotClassStyle","classStyles","getTimeTimeslotClassStyle","dayTimeslotClassStyle","getDayTimeslotClassStyle","timeslotVon","vons","getTimeslotVon","dayTimeslotVon","showLoader","overlaidAvailability","forEach","curBlockIndex","addOverlaidAvailabilityBlocks","getDateFromRowCol","dragAdd","inDragRange","dragRemove","hoursLength","showOverlayAvailabilityToggle","overlayAvailabilitiesEnabled","showCalendarOptions","columnOffsets","offsets","accumulatedOffset","methods","getDateFromDayHoursOffset","getDateFromDayTimeIndex","isColConsecutive","timeIndex","hasSecondSplit","isFirstSplit","adjustedDayIndex","mouseOverRespondent","e","mouseLeaveRespondent","clickRespondent","stopPropagation","deselectRespondents","target","previousElementSibling","firstChild","classList","contains","resetCurTimeslot","firstName","fetchResponses","timeMin","timeMax","url","toISOString","then","getResponsesFormatted","catch","err","showError","$worker","run","splitTimeNum","timeNum","hours","minutes","newDate","setHours","getHours","setMinutes","getMinutes","formatted","finally","showAvailability","available","respondent","setAuthUser","resetCurUserAvailability","initSharedCalendarAccounts","populateUserAvailability","$nextTick","getIsTimeBlockInFirstSplit","timeBlock","getTimeBlockStyle","endDate","manualAvailabilityAdded","bufferTimeInMS","startTimeString","isoDateString","workingHoursStartDate","toDate","endTime","workingHoursEndDate","j","startDate","findIndex","startDateBuffered","endDateBuffered","notIntersect","free","setAvailabilityAutomatically","tmpAvailability","pageStartDate","pageEndDate","animateAvailability","msPerGroup","blocksPerGroup","timeout","setTimeout","showInfo","stopAvailabilityAnim","clearTimeout","submitAvailability","guestPayload","email","payload","guest","addedIfNeededTimes","$posthog","capture","eventId","bufferTimeActive","workingHoursEnabled","workingHoursStartTime","workingHoursEndTime","refreshEvent","submitNewSignUpBlocks","concat","signUpBlocks","capacity","console","error","deleteAvailability","$router","replace","setTimeslotSize","timeslotEl","document","querySelector","getBoundingClientRect","classStyle","getTimeslotClassStyle","isDisabled","class","fractionalTime","borderTopStyle","totalRespondents","backgroundColor","c","s","timeslotRespondents","numRespondents","green","respondentId","frac","alpha","toString","toUpperCase","substring","padStart","red","borderRightStyle","borderBottomStyle","click","mousedown","highlightAvailabilityBtn","mouseover","utc","timeFormat","dateFormat","mouseleave","endDrag","startEditing","stopEditing","$emit","editGuestAvailability","scheduleEvent","cancelScheduleEvent","confirmScheduleEvent","googleCalendar","getDay","emails","emailsString","encodeURIComponent","join","shortId","start","end","location","window","open","normalizeXY","pageX","pageY","touches","left","currentTarget","x","y","scrollY","clampRow","clampCol","getRowColFromXY","adjustedRow","colInc","abs","rowInc","isNaN","rowStart","rowMax","colStart","colMax","isMonthDayIncluded","delete","discreteDate","startDateOfDay","existingAvailability","getAvailabilityForColumn","convertedDate","createSignUpBlock","moveDrag","preventDefault","startDrag","$refs","signUpBlocksList","scrollToSignUpBlock","getLocalTimezone","split","toLocaleTimeString","timeZoneName","localTimezone","onShowBestTimesChange","toggleShowEditOptions","toggleShowEventOptions","updateOverlayAvailability","val","onCalendarScroll","scrollWidth","offsetWidth","scrollLeft","onScroll","checkElementsVisible","optionsSectionEl","optionsSection","bottomOffset","respondentsListEl","respondentsList","$el","nextPage","stopImmediatePropagation","prevPage","onResize","closeHint","toggleCalendarAccount","calendarType","toggleSubCalendarAccount","subCalendarId","enabledCalendars","isTouched","availableTime","column","subset","availabilitySet","manualAvailabilityDow","dowTime","editSignUpBlock","signUpBlock","blocksInDay","blockIndex","deleteSignUpBlock","signUpBlockId","resetSignUpForm","resetSignUpBlocksToAddByDay","signUpResponses","signUpResponse","signUpBlockIds","find","handleSignUpBlockClick","saveTempTimes","sort","b","minHours","maxHours","getMinMaxHoursFromTimes","timeDate","localHours","reanimateAvailability","watch","immediate","handler","nextState","prevState","time9","getElementById","yOffset","scrollTo","behavior","oldVal","cur","prev","created","addEventListener","mounted","urlParams","URLSearchParams","search","scheduledEvent","newUrl","URL","href","searchParams","history","replaceState","title","timesEl","beforeDestroy","removeEventListener","components"],"sources":["src/components/schedule_overlap/ScheduleOverlap.vue"],"sourcesContent":["<template>\n  <span>\n    <Tooltip :content=\"tooltipContent\">\n      <div class=\"tw-select-none tw-py-4\" style=\"-webkit-touch-callout: none\">\n        <div class=\"tw-flex tw-flex-col sm:tw-flex-row\">\n          <div\n            class=\"tw-flex tw-grow tw-pl-4\"\n            :class=\"isSignUp ? '' : 'tw-pr-4'\"\n          >\n            <template v-if=\"event.daysOnly\">\n              <div class=\"tw-grow\">\n                <div class=\"tw-flex tw-items-center tw-justify-between\">\n                  <v-btn\n                    :class=\"hasPrevPage ? 'tw-visible' : 'tw-invisible'\"\n                    class=\"tw-border-gray\"\n                    outlined\n                    icon\n                    @click=\"prevPage\"\n                    ><v-icon>mdi-chevron-left</v-icon></v-btn\n                  >\n                  <div\n                    class=\"tw-text-lg tw-font-medium tw-capitalize sm:tw-text-xl\"\n                  >\n                    {{ curMonthText }}\n                  </div>\n                  <v-btn\n                    :class=\"hasNextPage ? 'tw-visible' : 'tw-invisible'\"\n                    class=\"tw-border-gray\"\n                    outlined\n                    icon\n                    @click=\"nextPage\"\n                    ><v-icon>mdi-chevron-right</v-icon></v-btn\n                  >\n                </div>\n                <!-- Header -->\n                <div class=\"tw-flex tw-w-full\">\n                  <div\n                    v-for=\"day in daysOfWeek\"\n                    class=\"tw-flex-1 tw-p-2 tw-text-center tw-text-base tw-capitalize tw-text-dark-gray\"\n                  >\n                    {{ day }}\n                  </div>\n                </div>\n                <!-- Days grid -->\n                <div\n                  id=\"drag-section\"\n                  class=\"tw-grid tw-grid-cols-7\"\n                  @mouseleave=\"resetCurTimeslot\"\n                >\n                  <div\n                    v-for=\"(day, i) in monthDays\"\n                    :key=\"day.time\"\n                    class=\"timeslot tw-aspect-square tw-p-2 tw-text-sm sm:tw-text-base\"\n                    :class=\"dayTimeslotClassStyle[i].class\"\n                    :style=\"dayTimeslotClassStyle[i].style\"\n                    v-on=\"dayTimeslotVon[i]\"\n                  >\n                    {{ dayjs(day.time).format('M月D日') }}\n                  </div>\n                </div>\n\n                <v-expand-transition>\n                  <div\n                    :key=\"hintText\"\n                    v-if=\"!isPhone && hintTextShown\"\n                    class=\"tw-sticky tw-bottom-4 tw-z-10 tw-flex\"\n                  >\n                    <div\n                      class=\"tw-mt-2 tw-flex tw-w-full tw-items-center tw-justify-between tw-gap-1 tw-rounded-md tw-bg-off-white tw-p-2 tw-px-[7px] tw-text-sm tw-text-very-dark-gray\"\n                    >\n                      <div class=\"tw-flex tw-items-center tw-gap-1\">\n                        <v-icon small>mdi-information-outline</v-icon>\n                        {{ hintText }}\n                      </div>\n                      <v-icon small @click=\"closeHint\">mdi-close</v-icon>\n                    </div>\n                  </div>\n                </v-expand-transition>\n\n                <ToolRow\n                  v-if=\"!isPhone && !calendarOnly\"\n                  :event=\"event\"\n                  :state=\"state\"\n                  :states=\"states\"\n                  :cur-timezone.sync=\"curTimezone\"\n                  :show-best-times.sync=\"showBestTimes\"\n                  :hide-if-needed.sync=\"hideIfNeeded\"\n                  :is-weekly=\"isWeekly\"\n                  :calendar-permission-granted=\"calendarPermissionGranted\"\n                  :week-offset=\"weekOffset\"\n                  :num-responses=\"respondents.length\"\n                  :mobile-num-days.sync=\"mobileNumDays\"\n                  :allow-schedule-event=\"allowScheduleEvent\"\n                  :show-event-options=\"showEventOptions\"\n                  :time-type.sync=\"timeType\"\n                  @toggleShowEventOptions=\"toggleShowEventOptions\"\n                  @update:weekOffset=\"(val) => $emit('update:weekOffset', val)\"\n                  @scheduleEvent=\"scheduleEvent\"\n                  @cancelScheduleEvent=\"cancelScheduleEvent\"\n                  @confirmScheduleEvent=\"confirmScheduleEvent\"\n                />\n              </div>\n            </template>\n            <template v-else>\n              <!-- Times -->\n              <div\n                :class=\"calendarOnly ? 'tw-w-12' : ''\"\n                class=\"tw-w-8 tw-flex-none sm:tw-w-12\"\n              >\n                <div\n                  :class=\"calendarOnly ? 'tw-invisible' : 'tw-visible'\"\n                  class=\"tw-sticky tw-top-14 tw-z-10 -tw-ml-3 tw-mb-3 tw-h-11 tw-bg-white sm:tw-top-16 sm:tw-ml-0\"\n                >\n                  <div\n                    :class=\"hasPrevPage ? 'tw-visible' : 'tw-invisible'\"\n                    class=\"tw-sticky tw-top-14 tw-ml-0.5 tw-self-start tw-pt-1.5 sm:tw-top-16 sm:-tw-ml-2\"\n                  >\n                    <v-btn\n                      class=\"tw-border-gray\"\n                      outlined\n                      icon\n                      @click=\"prevPage\"\n                      ><v-icon>mdi-chevron-left</v-icon></v-btn\n                    >\n                  </div>\n                </div>\n\n                <div\n                  :class=\"calendarOnly ? '' : '-tw-ml-3'\"\n                  class=\"-tw-mt-[8px] sm:tw-ml-0\"\n                >\n                  <div\n                    v-for=\"(time, i) in splitTimes[0]\"\n                    :key=\"i\"\n                    :id=\"time.id\"\n                    class=\"tw-pr-1 tw-text-right tw-text-xs tw-font-light tw-uppercase sm:tw-pr-2\"\n                    :style=\"{ height: `${timeslotHeight}px` }\"\n                  >\n                    {{ time.text }}\n                  </div>\n                </div>\n\n                <template v-if=\"splitTimes[1].length > 0\">\n                  <div\n                    :style=\"{\n                      height: `${SPLIT_GAP_HEIGHT}px`,\n                    }\"\n                  ></div>\n                  <div\n                    v-if=\"splitTimes[1].length > 0\"\n                    :class=\"calendarOnly ? '' : '-tw-ml-3'\"\n                    class=\"sm:tw-ml-0\"\n                  >\n                    <div\n                      v-for=\"(time, i) in splitTimes[1]\"\n                      :key=\"i\"\n                      :id=\"time.id\"\n                      class=\"tw-pr-1 tw-text-right tw-text-xs tw-font-light tw-uppercase sm:tw-pr-2\"\n                      :style=\"{ height: `${timeslotHeight}px` }\"\n                    >\n                      {{ time.text }}\n                    </div>\n                  </div>\n                </template>\n              </div>\n\n              <!-- Middle section -->\n              <div class=\"tw-grow\">\n                <div\n                  ref=\"calendar\"\n                  @scroll=\"onCalendarScroll\"\n                  class=\"tw-relative tw-flex tw-flex-col\"\n                >\n                  <!-- Days -->\n                  <div\n                    :class=\"\n                      sampleCalendarEventsByDay\n                        ? undefined\n                        : 'tw-sticky tw-top-14'\n                    \"\n                    class=\"tw-z-10 tw-flex tw-h-14 tw-items-center tw-bg-white sm:tw-top-16\"\n                  >\n                    <template v-for=\"(day, i) in days\">\n                      <div\n                        v-if=\"!day.isConsecutive\"\n                        :style=\"{ width: `${SPLIT_GAP_WIDTH}px` }\"\n                        :key=\"`${i}-gap`\"\n                      ></div>\n                      <div :key=\"i\" class=\"tw-flex-1 tw-bg-white\">\n                        <div class=\"tw-text-center\">\n                          <div\n                            v-if=\"isSpecificDates || isGroup\"\n                            class=\"tw-text-[12px] tw-font-light tw-capitalize tw-text-very-dark-gray sm:tw-text-xs\"\n                          >\n                            {{ day.dateString }}\n                          </div>\n                          <div class=\"tw-text-base tw-capitalize sm:tw-text-lg\">\n                            {{ day.dayText }}\n                          </div>\n                        </div>\n                      </div>\n                    </template>\n                  </div>\n\n                  <!-- Calendar -->\n                  <div class=\"tw-flex tw-flex-col\">\n                    <div class=\"tw-flex-1\">\n                      <div\n                        id=\"drag-section\"\n                        data-long-press-delay=\"500\"\n                        class=\"tw-relative tw-flex\"\n                        @mouseleave=\"resetCurTimeslot\"\n                      >\n                        <!-- Loader -->\n                        <div\n                          v-if=\"showLoader\"\n                          class=\"tw-absolute tw-z-10 tw-grid tw-h-full tw-w-full tw-place-content-center\"\n                        >\n                          <v-progress-circular\n                            class=\"tw-text-green\"\n                            indeterminate\n                          />\n                        </div>\n\n                        <template v-for=\"(day, d) in days\">\n                          <div\n                            v-if=\"!day.isConsecutive\"\n                            :style=\"{ width: `${SPLIT_GAP_WIDTH}px` }\"\n                            :key=\"`${d}-gap`\"\n                          ></div>\n                          <div\n                            :key=\"d\"\n                            class=\"tw-relative tw-flex-1\"\n                            :class=\"\n                              ((isGroup && loadingCalendarEvents) ||\n                                loadingResponses.loading) &&\n                              'tw-opacity-50'\n                            \"\n                          >\n                            <!-- Timeslots -->\n                            <div\n                              v-for=\"(_, t) in splitTimes[0]\"\n                              :key=\"`${d}-${t}-0`\"\n                              class=\"tw-w-full\"\n                            >\n                              <div\n                                class=\"timeslot\"\n                                :class=\"\n                                  timeslotClassStyle[d * times.length + t]\n                                    ?.class\n                                \"\n                                :style=\"\n                                  timeslotClassStyle[d * times.length + t]\n                                    ?.style\n                                \"\n                                v-on=\"timeslotVon[d * times.length + t]\"\n                              ></div>\n                            </div>\n\n                            <template v-if=\"splitTimes[1].length > 0\">\n                              <div\n                                :style=\"{\n                                  height: `${SPLIT_GAP_HEIGHT}px`,\n                                }\"\n                              ></div>\n                              <div\n                                v-for=\"(_, t) in splitTimes[1]\"\n                                :key=\"`${d}-${t}-1`\"\n                                class=\"tw-w-full\"\n                              >\n                                <div\n                                  class=\"timeslot\"\n                                  :class=\"\n                                    timeslotClassStyle[\n                                      d * times.length +\n                                        t +\n                                        splitTimes[0].length\n                                    ]?.class\n                                  \"\n                                  :style=\"\n                                    timeslotClassStyle[\n                                      d * times.length +\n                                        t +\n                                        splitTimes[0].length\n                                    ]?.style\n                                  \"\n                                  v-on=\"\n                                    timeslotVon[\n                                      d * times.length +\n                                        t +\n                                        splitTimes[0].length\n                                    ]\n                                  \"\n                                ></div>\n                              </div>\n                            </template>\n\n                            <!-- Calendar events -->\n                            <template\n                              v-if=\"\n                                !loadingCalendarEvents &&\n                                (editing ||\n                                  alwaysShowCalendarEvents ||\n                                  showCalendarEvents)\n                              \"\n                              v-for=\"calendarEvent in calendarEventsByDay[\n                                d + page * maxDaysPerPage\n                              ]\"\n                            >\n                              <CalendarEventBlock\n                                :blockStyle=\"getTimeBlockStyle(calendarEvent)\"\n                                :key=\"calendarEvent.id\"\n                                :calendarEvent=\"calendarEvent\"\n                                :isGroup=\"isGroup\"\n                                :isEditingAvailability=\"\n                                  state === states.EDIT_AVAILABILITY\n                                \"\n                                :noEventNames=\"noEventNames\"\n                                :transitionName=\"\n                                  isGroup ? '' : 'fade-transition'\n                                \"\n                              />\n                            </template>\n\n                            <!-- Scheduled event -->\n                            <div v-if=\"state === states.SCHEDULE_EVENT\">\n                              <div\n                                v-if=\"\n                                  (dragStart && dragStart.col === d) ||\n                                  (!dragStart &&\n                                    curScheduledEvent &&\n                                    curScheduledEvent.col === d)\n                                \"\n                                class=\"tw-absolute tw-w-full tw-select-none tw-p-px\"\n                                :style=\"scheduledEventStyle\"\n                                style=\"pointer-events: none\"\n                              >\n                                <div\n                                  class=\"tw-h-full tw-w-full tw-overflow-hidden tw-text-ellipsis tw-rounded tw-border tw-border-solid tw-border-blue tw-bg-blue tw-p-px tw-text-xs\"\n                                >\n                                  <div class=\"tw-font-medium tw-text-white\">\n                                    {{ event.name }}\n                                  </div>\n                                </div>\n                              </div>\n                            </div>\n\n                            <!-- Sign up block being dragged -->\n                            <div v-if=\"state === states.EDIT_SIGN_UP_BLOCKS\">\n                              <div\n                                v-if=\"dragStart && dragStart.col === d\"\n                                class=\"tw-absolute tw-w-full tw-select-none tw-p-px\"\n                                :style=\"signUpBlockBeingDraggedStyle\"\n                                style=\"pointer-events: none\"\n                              >\n                                <SignUpCalendarBlock\n                                  :title=\"newSignUpBlockName\"\n                                  titleOnly\n                                  unsaved\n                                />\n                              </div>\n                            </div>\n\n                            <div v-if=\"isSignUp\">\n                              <!-- Sign up blocks -->\n                              <div\n                                v-for=\"block in signUpBlocksByDay[\n                                  d + page * maxDaysPerPage\n                                ]\"\n                                :key=\"block._id\"\n                              >\n                                <div\n                                  class=\"tw-absolute tw-w-full tw-select-none tw-p-px\"\n                                  :style=\"{\n                                    top: `calc(${block.hoursOffset} * 4 * 1rem)`,\n                                    height: `calc(${block.hoursLength} * 4 * 1rem)`,\n                                  }\"\n                                  @click=\"handleSignUpBlockClick(block)\"\n                                >\n                                  <SignUpCalendarBlock :signUpBlock=\"block\" />\n                                </div>\n                              </div>\n\n                              <!-- Sign up blocks to be added after hitting 'save' -->\n                              <div\n                                v-for=\"block in signUpBlocksToAddByDay[\n                                  d + page * maxDaysPerPage\n                                ]\"\n                                :key=\"block._id\"\n                              >\n                                <div\n                                  class=\"tw-absolute tw-w-full tw-select-none tw-p-px\"\n                                  :style=\"{\n                                    top: `calc(${block.hoursOffset} * 4 * 1rem)`,\n                                    height: `calc(${block.hoursLength} * 4 * 1rem)`,\n                                  }\"\n                                >\n                                  <SignUpCalendarBlock\n                                    :title=\"block.name\"\n                                    titleOnly\n                                    unsaved\n                                  />\n                                </div>\n                              </div>\n                            </div>\n\n                            <!-- Overlaid availabilities -->\n                            <div v-if=\"overlayAvailability\">\n                              <div\n                                v-for=\"(timeBlock, tb) in overlaidAvailability[\n                                  d\n                                ]\"\n                                :key=\"tb\"\n                                class=\"tw-absolute tw-w-full tw-select-none tw-p-px\"\n                                :style=\"getTimeBlockStyle(timeBlock)\"\n                                style=\"pointer-events: none\"\n                              >\n                                <div\n                                  class=\"tw-h-full tw-w-full tw-border-2\"\n                                  :class=\"\n                                    timeBlock.type === 'available'\n                                      ? 'overlay-avail-shadow-green tw-border-[#00994CB3] tw-bg-[#00994C66]'\n                                      : 'overlay-avail-shadow-yellow tw-border-[#997700CC] tw-bg-[#FFE8B8B3]'\n                                  \"\n                                ></div>\n                              </div>\n                            </div>\n                          </div>\n                        </template>\n                      </div>\n                    </div>\n                  </div>\n\n                  <ZigZag\n                    v-if=\"hasPrevPage\"\n                    left\n                    class=\"tw-absolute tw-left-0 tw-top-0 tw-h-full tw-w-3\"\n                  />\n                  <ZigZag\n                    v-if=\"hasNextPage\"\n                    right\n                    class=\"tw-absolute tw-right-0 tw-top-0 tw-h-full tw-w-3\"\n                  />\n                </div>\n\n                <!-- Hint text (desktop) -->\n                <v-expand-transition>\n                  <div\n                    :key=\"hintText\"\n                    v-if=\"!isPhone && hintTextShown\"\n                    class=\"tw-sticky tw-bottom-4 tw-z-10 tw-flex\"\n                  >\n                    <div\n                      class=\"tw-mt-2 tw-flex tw-w-full tw-items-center tw-justify-between tw-gap-1 tw-rounded-md tw-bg-off-white tw-p-2 tw-px-[7px] tw-text-sm tw-text-very-dark-gray\"\n                    >\n                      <div class=\"tw-flex tw-items-center tw-gap-1\">\n                        <v-icon small>mdi-information-outline</v-icon>\n                        {{ hintText }}\n                      </div>\n                      <v-icon small @click=\"closeHint\">mdi-close</v-icon>\n                    </div>\n                  </div>\n                </v-expand-transition>\n\n                <v-expand-transition>\n                  <div\n                    v-if=\"\n                      state !== states.EDIT_AVAILABILITY &&\n                      max !== respondents.length &&\n                      Object.keys(fetchedResponses).length !== 0 &&\n                      !loadingResponses.loading\n                    \"\n                  >\n                    <div class=\"tw-mt-2 tw-text-sm tw-text-dark-gray\">\n                      Note: There's no time when all\n                      {{ respondents.length }} respondents are available.\n                    </div>\n                  </div>\n                </v-expand-transition>\n\n                <ToolRow\n                  v-if=\"!isPhone && !calendarOnly\"\n                  :event=\"event\"\n                  :state=\"state\"\n                  :states=\"states\"\n                  :cur-timezone.sync=\"curTimezone\"\n                  :show-best-times.sync=\"showBestTimes\"\n                  :hide-if-needed.sync=\"hideIfNeeded\"\n                  :is-weekly=\"isWeekly\"\n                  :calendar-permission-granted=\"calendarPermissionGranted\"\n                  :week-offset=\"weekOffset\"\n                  :num-responses=\"respondents.length\"\n                  :mobile-num-days.sync=\"mobileNumDays\"\n                  :allow-schedule-event=\"allowScheduleEvent\"\n                  :show-event-options=\"showEventOptions\"\n                  :time-type.sync=\"timeType\"\n                  @toggleShowEventOptions=\"toggleShowEventOptions\"\n                  @update:weekOffset=\"(val) => $emit('update:weekOffset', val)\"\n                  @scheduleEvent=\"scheduleEvent\"\n                  @cancelScheduleEvent=\"cancelScheduleEvent\"\n                  @confirmScheduleEvent=\"confirmScheduleEvent\"\n                />\n              </div>\n\n              <div\n                v-if=\"!calendarOnly\"\n                :class=\"calendarOnly ? 'tw-invisible' : 'tw-visible'\"\n                class=\"tw-sticky tw-top-14 tw-z-10 tw-mb-4 tw-h-11 tw-bg-white sm:tw-top-16\"\n              >\n                <div\n                  :class=\"hasNextPage ? 'tw-visible' : 'tw-invisible'\"\n                  class=\"tw-sticky tw-top-14 -tw-mr-2 tw-self-start tw-pt-1.5 sm:tw-top-16\"\n                >\n                  <v-btn class=\"tw-border-gray\" outlined icon @click=\"nextPage\"\n                    ><v-icon>mdi-chevron-right</v-icon></v-btn\n                  >\n                </div>\n              </div>\n            </template>\n          </div>\n\n          <!-- Right hand side content -->\n\n          <div\n            v-if=\"!calendarOnly\"\n            class=\"tw-px-4 tw-py-4 sm:tw-sticky sm:tw-top-16 sm:tw-flex-none sm:tw-self-start sm:tw-py-0 sm:tw-pl-0 sm:tw-pr-0 sm:tw-pt-14\"\n            :style=\"{ width: rightSideWidth }\"\n          >\n            <!-- Show section on the right depending on some if conditions -->\n            <template v-if=\"isSignUp\">\n              <div class=\"tw-mb-2 tw-text-lg tw-text-black\">Slots</div>\n              <div v-if=\"!isOwner\" class=\"tw-mb-3 tw-flex tw-flex-col\">\n                <div\n                  class=\"tw-flex tw-flex-col tw-gap-1 tw-rounded-md tw-bg-light-gray tw-p-3 tw-text-xs tw-italic tw-text-dark-gray\"\n                >\n                  <div v-if=\"!authUser || alreadyRespondedToSignUpForm\">\n                    <a class=\"tw-underline\" :href=\"`mailto:${event.ownerId}`\"\n                      >Contact sign up creator</a\n                    >\n                    to edit your slot\n                  </div>\n                  <div v-if=\"event.blindAvailabilityEnabled\">\n                    Responses are only visible to creator\n                  </div>\n                </div>\n              </div>\n              <SignUpBlocksList\n                ref=\"signUpBlocksList\"\n                :signUpBlocks=\"signUpBlocksByDay.flat()\"\n                :signUpBlocksToAdd=\"signUpBlocksToAddByDay.flat()\"\n                :isEditing=\"state == states.EDIT_SIGN_UP_BLOCKS\"\n                :isOwner=\"isOwner\"\n                :alreadyResponded=\"alreadyRespondedToSignUpForm\"\n                :anonymous=\"event.blindAvailabilityEnabled\"\n                @update:signUpBlock=\"editSignUpBlock\"\n                @delete:signUpBlock=\"deleteSignUpBlock\"\n                @signUpForBlock=\"$emit('signUpForBlock', $event)\"\n              />\n            </template>\n            <template v-else-if=\"state === states.SET_SPECIFIC_TIMES\">\n              <SpecificTimesInstructions\n                v-if=\"!isPhone\"\n                :numTempTimes=\"tempTimes.size\"\n                @saveTempTimes=\"saveTempTimes\"\n              />\n            </template>\n            <template v-else>\n              <div\n                class=\"tw-flex tw-flex-col tw-gap-5\"\n                v-if=\"state == states.EDIT_AVAILABILITY\"\n              >\n                <div\n                  v-if=\"\n                    !(\n                      calendarPermissionGranted &&\n                      !event.daysOnly &&\n                      !addingAvailabilityAsGuest\n                    )\n                  \"\n                  class=\"tw-text-sm tw-italic tw-text-dark-gray\"\n                >\n                  {{\n                    (userHasResponded && !addingAvailabilityAsGuest) ||\n                    curGuestId\n                      ? \"Editing\"\n                      : \"Adding\"\n                  }}\n                  availability as\n                  {{\n                    authUser && !addingAvailabilityAsGuest\n                      ? `${authUser.firstName} ${authUser.lastName}`\n                      : curGuestId?.length > 0\n                      ? curGuestId\n                      : \"a guest\"\n                  }}\n                </div>\n                <AvailabilityTypeToggle\n                  v-if=\"!isGroup && !isPhone\"\n                  class=\"tw-w-full\"\n                  v-model=\"availabilityType\"\n                />\n                <!-- User's calendar accounts -->\n                <CalendarAccounts\n                  v-if=\"\n                    calendarPermissionGranted &&\n                    !event.daysOnly &&\n                    !addingAvailabilityAsGuest\n                  \"\n                  :toggleState=\"true\"\n                  :eventId=\"event._id\"\n                  :calendar-events-map=\"calendarEventsMap\"\n                  :syncWithBackend=\"!isGroup\"\n                  :allowAddCalendarAccount=\"!isGroup\"\n                  @toggleCalendarAccount=\"toggleCalendarAccount\"\n                  @toggleSubCalendarAccount=\"toggleSubCalendarAccount\"\n                  :initialCalendarAccountsData=\"\n                    isGroup ? sharedCalendarAccounts : authUser.calendarAccounts\n                  \"\n                ></CalendarAccounts>\n\n                <div v-if=\"showOverlayAvailabilityToggle\">\n                  <v-switch\n                    id=\"overlay-availabilities-toggle\"\n                    inset\n                    :input-value=\"overlayAvailability\"\n                    @change=\"updateOverlayAvailability\"\n                    hide-details\n                  >\n                    <template v-slot:label>\n                      <div class=\"tw-text-sm tw-text-black\">\n                        Overlay availabilities\n                      </div>\n                    </template>\n                  </v-switch>\n\n                  <div class=\"tw-mt-2 tw-text-xs tw-text-dark-gray\">\n                    View everyone's availability while inputting your own\n                  </div>\n                </div>\n\n                <!-- Options section removed by request: 'Option' feature and all its content are now commented out.\n                <div\n                  v-if=\"!event.daysOnly && showCalendarOptions\"\n                  ref=\"optionsSection\"\n                >\n                  <ExpandableSection\n                    label=\"Options\"\n                    :value=\"showEditOptions\"\n                    @input=\"toggleShowEditOptions\"\n                  >\n                    <div class=\"tw-flex tw-flex-col tw-gap-5 tw-pt-2.5\">\n                      <v-dialog\n                        v-if=\"showCalendarOptions\"\n                        v-model=\"calendarOptionsDialog\"\n                        width=\"500\"\n                      >\n                        <template v-slot:activator=\"{ on, attrs }\">\n                          <v-btn\n                            outlined\n                            class=\"tw-border-gray tw-text-sm\"\n                            v-on=\"on\"\n                            v-bind=\"attrs\"\n                          >\n                            Calendar options...\n                          </v-btn>\n                        </template>\n\n                        <v-card>\n                          <v-card-title class=\"tw-flex\">\n                            <div>Calendar options</div>\n                            <v-spacer />\n                            <v-btn icon @click=\"calendarOptionsDialog = false\">\n                              <v-icon>mdi-close</v-icon>\n                            </v-btn>\n                          </v-card-title>\n                          <v-card-text\n                            class=\"tw-flex tw-flex-col tw-gap-6 tw-pb-8 tw-pt-2\"\n                          >\n                            <AlertText v-if=\"isGroup\" class=\"-tw-mb-4\">\n                              Calendar options will only updated for the current\n                              group\n                            </AlertText>\n\n                            <BufferTimeSwitch\n                              :bufferTime.sync=\"bufferTime\"\n                              :syncWithBackend=\"!isGroup\"\n                            />\n\n                            <WorkingHoursToggle\n                              :workingHours.sync=\"workingHours\"\n                              :timezone=\"curTimezone\"\n                              :syncWithBackend=\"!isGroup\"\n                            />\n                          </v-card-text>\n                        </v-card>\n                      </v-dialog>\n                    </div>\n                  </ExpandableSection>\n                </div>\n                -->\n\n                <!-- Delete availability button -->\n                <div\n                  v-if=\"\n                    (!addingAvailabilityAsGuest && userHasResponded) ||\n                    curGuestId\n                  \"\n                >\n                  <v-dialog\n                    v-model=\"deleteAvailabilityDialog\"\n                    width=\"500\"\n                    persistent\n                  >\n                    <template v-slot:activator=\"{ on, attrs }\">\n                      <span\n                        v-bind=\"attrs\"\n                        v-on=\"on\"\n                        class=\"tw-cursor-pointer tw-text-sm tw-text-red\"\n                      >\n                        {{ !isGroup ? \"Delete availability\" : \"Leave group\" }}\n                      </span>\n                    </template>\n\n                    <v-card>\n                      <v-card-title>Are you sure?</v-card-title>\n                      <v-card-text class=\"tw-text-sm tw-text-dark-gray\"\n                        >Are you sure you want to\n                        {{\n                          !isGroup\n                            ? \"delete your availability from this event?\"\n                            : \"leave this group?\"\n                        }}</v-card-text\n                      >\n                      <v-card-actions>\n                        <v-spacer />\n                        <v-btn text @click=\"deleteAvailabilityDialog = false\"\n                          >Cancel</v-btn\n                        >\n                        <v-btn\n                          text\n                          color=\"error\"\n                          @click=\"\n                            $emit('deleteAvailability')\n                            deleteAvailabilityDialog = false\n                          \"\n                          >{{ !isGroup ? \"Delete\" : \"Leave\" }}</v-btn\n                        >\n                      </v-card-actions>\n                    </v-card>\n                  </v-dialog>\n                </div>\n              </div>\n              <template v-else>\n                <RespondentsList\n                  ref=\"respondentsList\"\n                  :event=\"event\"\n                  :eventId=\"event._id\"\n                  :days=\"allDays\"\n                  :times=\"times\"\n                  :curDate=\"getDateFromRowCol(curTimeslot.row, curTimeslot.col)\"\n                  :curRespondent=\"curRespondent\"\n                  :curRespondents=\"curRespondents\"\n                  :curTimeslot=\"curTimeslot\"\n                  :curTimeslotAvailability=\"curTimeslotAvailability\"\n                  :respondents=\"respondents\"\n                  :parsedResponses=\"parsedResponses\"\n                  :isOwner=\"isOwner\"\n                  :isGroup=\"isGroup\"\n                  :attendees=\"event.attendees\"\n                  :showCalendarEvents.sync=\"showCalendarEvents\"\n                  :responsesFormatted=\"responsesFormatted\"\n                  :timezone=\"curTimezone\"\n                  :show-best-times.sync=\"showBestTimes\"\n                  :hide-if-needed.sync=\"hideIfNeeded\"\n                  :start-calendar-on-monday.sync=\"startCalendarOnMonday\"\n                  :show-event-options=\"showEventOptions\"\n                  :guestAddedAvailability=\"guestAddedAvailability\"\n                  :addingAvailabilityAsGuest=\"addingAvailabilityAsGuest\"\n                  @toggleShowEventOptions=\"toggleShowEventOptions\"\n                  @addAvailability=\"$emit('addAvailability')\"\n                  @addAvailabilityAsGuest=\"$emit('addAvailabilityAsGuest')\"\n                  @mouseOverRespondent=\"mouseOverRespondent\"\n                  @mouseLeaveRespondent=\"mouseLeaveRespondent\"\n                  @clickRespondent=\"clickRespondent\"\n                  @editGuestAvailability=\"editGuestAvailability\"\n                  @refreshEvent=\"refreshEvent\"\n                />\n              </template>\n            </template>\n          </div>\n        </div>\n\n        <ToolRow\n          v-if=\"isPhone && !calendarOnly\"\n          class=\"tw-px-4\"\n          :event=\"event\"\n          :state=\"state\"\n          :states=\"states\"\n          :cur-timezone.sync=\"curTimezone\"\n          :show-best-times.sync=\"showBestTimes\"\n          :hide-if-needed.sync=\"hideIfNeeded\"\n          :start-calendar-on-monday.sync=\"startCalendarOnMonday\"\n          :is-weekly=\"isWeekly\"\n          :calendar-permission-granted=\"calendarPermissionGranted\"\n          :week-offset=\"weekOffset\"\n          :num-responses=\"respondents.length\"\n          :mobile-num-days.sync=\"mobileNumDays\"\n          :allow-schedule-event=\"allowScheduleEvent\"\n          :show-event-options=\"showEventOptions\"\n          :time-type.sync=\"timeType\"\n          @toggleShowEventOptions=\"toggleShowEventOptions\"\n          @update:weekOffset=\"(val) => $emit('update:weekOffset', val)\"\n          @scheduleEvent=\"scheduleEvent\"\n          @cancelScheduleEvent=\"cancelScheduleEvent\"\n          @confirmScheduleEvent=\"confirmScheduleEvent\"\n        />\n\n        <!-- Fixed bottom section for mobile -->\n        <div\n          v-if=\"isPhone && !calendarOnly\"\n          class=\"tw-fixed tw-bottom-16 tw-z-20 tw-w-full\"\n        >\n          <!-- Hint text (mobile) -->\n          <v-expand-transition>\n            <template v-if=\"hintTextShown\">\n              <div :key=\"hintText\">\n                <div\n                  :class=\"`tw-flex tw-w-full tw-items-center tw-justify-between tw-gap-1 tw-bg-light-gray tw-px-2 tw-py-2 tw-text-sm tw-text-very-dark-gray`\"\n                >\n                  <div\n                    :class=\"`tw-flex tw-gap-${hintText.length > 60 ? 2 : 1}`\"\n                  >\n                    <v-icon small>mdi-information-outline</v-icon>\n                    <div>\n                      {{ hintText }}\n                    </div>\n                  </div>\n                  <v-icon small @click=\"closeHint\">mdi-close</v-icon>\n                </div>\n              </div>\n            </template>\n          </v-expand-transition>\n\n          <!-- Fixed pos availability toggle (mobile) -->\n          <v-expand-transition>\n            <div v-if=\"!isGroup && editing && !isSignUp\">\n              <div class=\"tw-bg-white tw-p-4\">\n                <AvailabilityTypeToggle\n                  class=\"tw-w-full\"\n                  v-model=\"availabilityType\"\n                />\n              </div>\n            </div>\n          </v-expand-transition>\n\n          <!-- GCal week selector -->\n          <v-expand-transition>\n            <div v-if=\"isWeekly && editing && calendarPermissionGranted\">\n              <div class=\"tw-h-16 tw-text-sm\">\n                <GCalWeekSelector\n                  :week-offset=\"weekOffset\"\n                  :event=\"event\"\n                  @update:weekOffset=\"(val) => $emit('update:weekOffset', val)\"\n                  :start-on-monday=\"event.startOnMonday\"\n                />\n              </div>\n            </div>\n          </v-expand-transition>\n\n          <!-- Respondents list -->\n          <v-expand-transition>\n            <div v-if=\"delayedShowStickyRespondents\">\n              <div class=\"tw-bg-white tw-p-4\">\n                <RespondentsList\n                  :max-height=\"100\"\n                  :event=\"event\"\n                  :eventId=\"event._id\"\n                  :days=\"allDays\"\n                  :times=\"times\"\n                  :curDate=\"getDateFromRowCol(curTimeslot.row, curTimeslot.col)\"\n                  :curRespondent=\"curRespondent\"\n                  :curRespondents=\"curRespondents\"\n                  :curTimeslot=\"curTimeslot\"\n                  :curTimeslotAvailability=\"curTimeslotAvailability\"\n                  :respondents=\"respondents\"\n                  :parsedResponses=\"parsedResponses\"\n                  :isOwner=\"isOwner\"\n                  :isGroup=\"isGroup\"\n                  :attendees=\"event.attendees\"\n                  :showCalendarEvents.sync=\"showCalendarEvents\"\n                  :responsesFormatted=\"responsesFormatted\"\n                  :timezone=\"curTimezone\"\n                  :show-best-times.sync=\"showBestTimes\"\n                  :hide-if-needed.sync=\"hideIfNeeded\"\n                  :show-event-options=\"showEventOptions\"\n                  :guestAddedAvailability=\"guestAddedAvailability\"\n                  :addingAvailabilityAsGuest=\"addingAvailabilityAsGuest\"\n                  @toggleShowEventOptions=\"toggleShowEventOptions\"\n                  @addAvailability=\"$emit('addAvailability')\"\n                  @addAvailabilityAsGuest=\"$emit('addAvailabilityAsGuest')\"\n                  @mouseOverRespondent=\"mouseOverRespondent\"\n                  @mouseLeaveRespondent=\"mouseLeaveRespondent\"\n                  @clickRespondent=\"clickRespondent\"\n                  @editGuestAvailability=\"editGuestAvailability\"\n                  @refreshEvent=\"refreshEvent\"\n                />\n              </div>\n            </div>\n          </v-expand-transition>\n\n          <!-- Specific times instructions -->\n          <v-expand-transition>\n            <div\n              v-if=\"state === states.SET_SPECIFIC_TIMES\"\n              class=\"-tw-mb-16 tw-bg-white tw-p-4\"\n            >\n              <SpecificTimesInstructions\n                :numTempTimes=\"tempTimes.size\"\n                @saveTempTimes=\"saveTempTimes\"\n              />\n            </div>\n          </v-expand-transition>\n        </div>\n      </div>\n    </Tooltip>\n  </span>\n</template>\n\n<style scoped>\n.animate-bg-color {\n  transition: background-color 0.25s ease-in-out;\n}\n\n.break {\n  flex-basis: 100%;\n  height: 0;\n}\n</style>\n\n<style>\n/* Make timezone select element the same width as content */\n#timezone-select {\n  width: 5px;\n}\n</style>\n\n<script>\nimport {\n  timeNumToTimeText,\n  dateCompare,\n  getDateHoursOffset,\n  post,\n  put,\n  isBetween,\n  clamp,\n  isPhone,\n  utcTimeToLocalTime,\n  splitTimeBlocksByDay,\n  getTimeBlock,\n  dateToDowDate,\n  _delete,\n  get,\n  getDateDayOffset,\n  isDateBetween,\n  generateEnabledCalendarsPayload,\n  isTouchEnabled,\n  isElementInViewport,\n  lightOrDark,\n  removeTransparencyFromHex,\n  userPrefers12h,\n  getCalendarAccountKey,\n  getISODateString,\n  getDateWithTimezone,\n  timeNumToTimeString,\n  isPremiumUser,\n} from \"@/utils\"\nimport {\n  availabilityTypes,\n  calendarOptionsDefaults,\n  eventTypes,\n  timeTypes,\n  timeslotDurations,\n  upgradeDialogTypes,\n} from \"@/constants\"\nimport { mapMutations, mapActions, mapState } from \"vuex\"\nimport UserAvatarContent from \"@/components/UserAvatarContent.vue\"\nimport CalendarAccounts from \"@/components/settings/CalendarAccounts.vue\"\nimport Advertisement from \"@/components/event/Advertisement.vue\"\nimport SignUpBlock from \"@/components/sign_up_form/SignUpBlock.vue\"\nimport SignUpCalendarBlock from \"@/components/sign_up_form/SignUpCalendarBlock.vue\"\nimport SignUpBlocksList from \"@/components/sign_up_form/SignUpBlocksList.vue\"\nimport ZigZag from \"./ZigZag.vue\"\nimport ConfirmDetailsDialog from \"./ConfirmDetailsDialog.vue\"\nimport ToolRow from \"./ToolRow.vue\"\nimport RespondentsList from \"./RespondentsList.vue\"\nimport GCalWeekSelector from \"./GCalWeekSelector.vue\"\nimport ExpandableSection from \"../ExpandableSection.vue\"\nimport WorkingHoursToggle from \"./WorkingHoursToggle.vue\"\nimport AlertText from \"../AlertText.vue\"\nimport Tooltip from \"../Tooltip.vue\"\n\nimport dayjs from \"dayjs\"\nimport \"dayjs/locale/zh-cn\"\ndayjs.locale(\"zh-cn\")\nimport ObjectID from \"bson-objectid\"\nimport utcPlugin from \"dayjs/plugin/utc\"\nimport timezonePlugin from \"dayjs/plugin/timezone\"\nimport AvailabilityTypeToggle from \"./AvailabilityTypeToggle.vue\"\nimport BufferTimeSwitch from \"./BufferTimeSwitch.vue\"\nimport CalendarEventBlock from \"./CalendarEventBlock.vue\" // Added import\nimport SpecificTimesInstructions from \"./SpecificTimesInstructions.vue\"\ndayjs.extend(utcPlugin)\ndayjs.extend(timezonePlugin)\n\nexport default {\n  name: \"ScheduleOverlap\",\n  props: {\n    event: { type: Object, required: true },\n    fromEditEvent: { type: Boolean, default: false },\n\n    loadingCalendarEvents: { type: Boolean, default: false }, // Whether we are currently loading the calendar events\n    calendarEventsMap: { type: Object, default: () => {} }, // Object of different users' calendar events\n    sampleCalendarEventsByDay: { type: Array, required: false }, // Sample calendar events to use for example calendars\n    calendarPermissionGranted: { type: Boolean, default: false }, // Whether user has granted google calendar permissions\n\n    weekOffset: { type: Number, default: 0 }, // Week offset used for displaying calendar events on weekly schejs\n\n    alwaysShowCalendarEvents: { type: Boolean, default: false }, // Whether to show calendar events all the time\n    noEventNames: { type: Boolean, default: false }, // Whether to show \"busy\" instead of the event name\n    calendarOnly: { type: Boolean, default: false }, // Whether to only show calendar and not respondents or any other controls\n    interactable: { type: Boolean, default: true }, // Whether to allow user to interact with component\n    showSnackbar: { type: Boolean, default: true }, // Whether to show snackbar when availability is automatically filled in\n    animateTimeslotAlways: { type: Boolean, default: false }, // Whether to animate timeslots all the time\n    showHintText: { type: Boolean, default: true }, // Whether to show the hint text telling user what to do\n\n    curGuestId: { type: String, default: \"\" }, // Id of the current guest being edited\n    addingAvailabilityAsGuest: { type: Boolean, default: false }, // Whether the signed in user is adding availability as a guest\n\n    initialTimezone: { type: Object, default: () => ({}) },\n\n    // Availability Groups\n    calendarAvailabilities: { type: Object, default: () => ({}) },\n  },\n  data() {\n    return {\n      states: {\n        HEATMAP: \"heatmap\", // Display heatmap of availabilities\n        SINGLE_AVAILABILITY: \"single_availability\", // Show one person's availability\n        SUBSET_AVAILABILITY: \"subset_availability\", // Show availability for a subset of people\n        BEST_TIMES: \"best_times\", // Show only the times that work for most people\n        EDIT_AVAILABILITY: \"edit_availability\", // Edit current user's availability\n        EDIT_SIGN_UP_BLOCKS: \"edit_sign_up_blocks\", // Edit the slots on a sign up form\n        SCHEDULE_EVENT: \"schedule_event\", // Schedule event on gcal\n        SET_SPECIFIC_TIMES: \"set_specific_times\", // Set specific times for the event\n      },\n      state: \"best_times\",\n\n      availability: new Set(), // The current user's availability\n      ifNeeded: new Set(), // The current user's \"if needed\" availability\n      tempTimes: new Set(), // The specific times that the user has selected for the event (pending save)\n      availabilityAnimTimeouts: [], // Timeouts for availability animation\n      availabilityAnimEnabled: false, // Whether to animate timeslots changing colors\n      maxAnimTime: 1200, // Max amount of time for availability animation\n      unsavedChanges: false, // If there are unsaved availability changes\n      curTimeslot: { row: -1, col: -1 }, // The currently highlighted timeslot\n      timeslotSelected: false, // Whether a timeslot is selected (used to persist selection on desktop)\n      curTimeslotAvailability: {}, // The users available for the current timeslot\n      curRespondent: \"\", // Id of the active respondent (set on hover)\n      curRespondents: [], // Id of currently selected respondents (set on click)\n      sharedCalendarAccounts: {}, // The user's calendar accounts for changing calendar options for groups\n      fetchedResponses: {}, // Responses fetched from the server for the dates currently shown\n      loadingResponses: { loading: false, lastFetched: new Date().getTime() }, // Whether we're currently fetching the responses\n      responsesFormatted: new Map(), // Map where date/time is mapped to the people that are available then\n      tooltipContent: \"\", // The content of the tooltip\n\n      /* Sign up form */\n      signUpBlocksByDay: [], // The current event's sign up blocks by day\n      signUpBlocksToAddByDay: [], // The sign up blocks to be added after hitting 'save'\n\n      /* Edit options */\n      showEditOptions:\n        localStorage[\"showEditOptions\"] == undefined\n          ? false\n          : localStorage[\"showEditOptions\"] == \"true\",\n      availabilityType: availabilityTypes.AVAILABLE, // The current availability type\n      overlayAvailability: false, // Whether to overlay everyone's availability when editing\n      bufferTime: calendarOptionsDefaults.bufferTime, // Set in mounted()\n      workingHours: calendarOptionsDefaults.workingHours, // Set in mounted()\n\n      /* Event Options */\n      showEventOptions:\n        localStorage[\"showEventOptions\"] == undefined\n          ? false\n          : localStorage[\"showEventOptions\"] == \"true\",\n      showBestTimes:\n        localStorage[\"showBestTimes\"] == undefined\n          ? false\n          : localStorage[\"showBestTimes\"] == \"true\",\n      hideIfNeeded: false,\n\n      /* Variables for drag stuff */\n      DRAG_TYPES: {\n        ADD: \"add\",\n        REMOVE: \"remove\",\n      },\n      SPLIT_GAP_HEIGHT: 40,\n      SPLIT_GAP_WIDTH: 20,\n      HOUR_HEIGHT: 60,\n      timeslot: {\n        width: 0,\n        height: 0,\n      },\n      dragging: false,\n      dragType: \"add\",\n      dragStart: null,\n      dragCur: null,\n\n      /* Variables for options */\n      curTimezone: this.initialTimezone,\n      curScheduledEvent: null, // The scheduled event represented in the form {hoursOffset, hoursLength, dayIndex}\n      timeType:\n        localStorage[\"timeType\"] ??\n        (userPrefers12h() ? timeTypes.HOUR12 : timeTypes.HOUR24), // Whether 12-hour or 24-hour\n      showCalendarEvents: false,\n      startCalendarOnMonday: false,\n      // localStorage[\"startCalendarOnMonday\"] == undefined\n      //   ? false\n      //   : localStorage[\"startCalendarOnMonday\"] == \"true\",\n\n      /* Dialogs */\n      deleteAvailabilityDialog: false,\n      calendarOptionsDialog: false,\n\n      /* Variables for scrolling */\n      optionsVisible: false,\n      calendarScrollLeft: 0, // The current scroll position of the calendar\n      calendarMaxScroll: 0, // The maximum scroll amount of the calendar, scrolling to this point means we have scrolled to the end\n      scrolledToRespondents: false, // whether we have scrolled to the respondents section\n      delayedShowStickyRespondents: false, // showStickyRespondents variable but changes 100ms after the actual variable changes (to add some delay)\n      delayedShowStickyRespondentsTimeout: null, // Timeout that sets delayedShowStickyRespondents\n\n      /* Variables for pagination */\n      page: 0,\n      mobileNumDays: localStorage[\"mobileNumDays\"]\n        ? parseInt(localStorage[\"mobileNumDays\"])\n        : 3, // The number of days to show at a time on mobile\n      pageHasChanged: false,\n\n      hasRefreshedAuthUser: false,\n\n      /* Variables for hint */\n      hintState: true,\n\n      /** Groups */\n      manualAvailability: {},\n\n      /** Constants */\n      months: [\n        \"jan\",\n        \"feb\",\n        \"mar\",\n        \"apr\",\n        \"may\",\n        \"jun\",\n        \"jul\",\n        \"aug\",\n        \"sep\",\n        \"oct\",\n        \"nov\",\n        \"dec\",\n      ],\n    }\n  },\n  computed: {\n    ...mapState([\"authUser\", \"overlayAvailabilitiesEnabled\"]),\n    /** Returns the width of the right side of the calendar */\n    rightSideWidth() {\n      if (this.isPhone) return \"100%\"\n      return this.isSignUp ? \"18rem\" : \"13rem\"\n    },\n    /** Returns the days of the week in the correct order */\n    daysOfWeek() {\n      // 返回带“周”的中文星期标题\n      return !this.startCalendarOnMonday\n        ? [\"周日\", \"周一\", \"周二\", \"周三\", \"周四\", \"周五\", \"周六\"]\n        : [\"周一\", \"周二\", \"周三\", \"周四\", \"周五\", \"周六\", \"周日\"]\n    },\n    /** Only allow scheduling when a curScheduledEvent exists */\n    allowScheduleEvent() {\n      return !!this.curScheduledEvent\n    },\n    /** Returns the availability as an array */\n    availabilityArray() {\n      return [...this.availability].map((item) => new Date(item))\n    },\n    /** Returns the if needed availability as an array */\n    ifNeededArray() {\n      return [...this.ifNeeded].map((item) => new Date(item))\n    },\n    allowDrag() {\n      return (\n        this.state === this.states.EDIT_AVAILABILITY ||\n        this.state === this.states.EDIT_SIGN_UP_BLOCKS ||\n        this.state === this.states.SCHEDULE_EVENT ||\n        this.state === this.states.SET_SPECIFIC_TIMES\n      )\n    },\n    /** Returns an array of calendar events for all of the authUser's enabled calendars, separated by the day they occur on */\n    calendarEventsByDay() {\n      // If this is an example calendar\n      if (this.sampleCalendarEventsByDay) return this.sampleCalendarEventsByDay\n\n      // If the user isn't logged in or is adding availability as a guest\n      if (!this.authUser || this.addingAvailabilityAsGuest) return []\n\n      let events = []\n      let event\n\n      const calendarAccounts = this.isGroup\n        ? this.sharedCalendarAccounts\n        : this.authUser.calendarAccounts\n\n      // Adds events from calendar accounts that are enabled\n      for (const id in calendarAccounts) {\n        if (!calendarAccounts[id].enabled) continue\n\n        if (this.calendarEventsMap.hasOwnProperty(id)) {\n          for (const index in this.calendarEventsMap[id].calendarEvents) {\n            event = this.calendarEventsMap[id].calendarEvents[index]\n\n            // Check if we need to update authUser (to get latest subcalendars)\n            const subCalendars = calendarAccounts[id].subCalendars\n            if (!subCalendars || !(event.calendarId in subCalendars)) {\n              // authUser doesn't contain the subCalendar, so push event to events without checking if subcalendar is enabled\n              // and queue the authUser to be refreshed\n              events.push(event)\n              if (!this.hasRefreshedAuthUser && !this.isGroup) {\n                this.refreshAuthUser()\n              }\n              continue\n            }\n\n            // Push event to events if subcalendar is enabled\n            if (subCalendars[event.calendarId].enabled) {\n              events.push(event)\n            }\n          }\n        }\n      }\n\n      const eventsCopy = JSON.parse(JSON.stringify(events))\n\n      const calendarEventsByDay = splitTimeBlocksByDay(\n        this.event,\n        eventsCopy,\n        this.weekOffset,\n        this.timezoneOffset\n      )\n\n      return calendarEventsByDay\n    },\n    /** [SPECIFIC TO GROUPS] Returns an object mapping user ids to their calendar events separated by the day they occur on */\n    groupCalendarEventsByDay() {\n      if (this.event.type !== eventTypes.GROUP) return {}\n\n      const userIdToEventsByDay = {}\n      for (const userId in this.event.responses) {\n        if (userId === this.authUser._id) {\n          userIdToEventsByDay[userId] = this.calendarEventsByDay\n        } else if (userId in this.calendarAvailabilities) {\n          userIdToEventsByDay[userId] = splitTimeBlocksByDay(\n            this.event,\n            this.calendarAvailabilities[userId],\n            this.weekOffset,\n            this.timezoneOffset\n          )\n        }\n      }\n\n      return userIdToEventsByDay\n    },\n    curRespondentsSet() {\n      return new Set(this.curRespondents)\n    },\n\n    // -----------------------------------\n    //#region Sign up form\n    // -----------------------------------\n\n    /** Returns the name of the new sign up block being dragged */\n    newSignUpBlockName() {\n      return `Slot #${\n        this.signUpBlocksByDay.flat().length +\n        this.signUpBlocksToAddByDay.flat().length +\n        1\n      }`\n    },\n\n    /** Returns the max allowable drag */\n    maxSignUpBlockRowSize() {\n      if (!this.dragStart || !this.isSignUp) return null\n\n      const selectedDay = this.signUpBlocksByDay[this.dragStart.col]\n      const selectedDayToAdd = this.signUpBlocksToAddByDay[this.dragStart.col]\n\n      if (selectedDay.length === 0 && selectedDayToAdd.length === 0) return null\n\n      let maxSize = Infinity\n      for (const block of [...selectedDay, ...selectedDayToAdd]) {\n        if (block.hoursOffset * 4 > this.dragStart.row) {\n          maxSize = Math.min(\n            maxSize,\n            block.hoursOffset * 4 - this.dragStart.row\n          )\n        }\n      }\n\n      return maxSize\n    },\n\n    /** Whether the current user has already responded to the sign up form */\n    alreadyRespondedToSignUpForm() {\n      if (!this.authUser || !this.signUpBlocksByDay) return false\n\n      return this.signUpBlocksByDay.some((dayBlocks) =>\n        dayBlocks.some((block) =>\n          block.responses?.some(\n            (response) => response.userId === this.authUser._id\n          )\n        )\n      )\n    },\n\n    //#endregion\n\n    /** Returns the max number of people in the curRespondents array available at any given time */\n    curRespondentsMax() {\n      let max = 0\n      if (this.event.daysOnly) {\n        for (const day of this.allDays) {\n          const num = [\n            ...(this.responsesFormatted.get(day.dateObject.getTime()) ??\n              new Set()),\n          ].filter((r) => this.curRespondentsSet.has(r)).length\n\n          if (num > max) max = num\n        }\n      } else {\n        for (let i = 0; i < this.event.dates.length; i++) {\n          const date = new Date(this.event.dates[i])\n          for (const time of this.times) {\n            const num = [\n              ...this.getRespondentsForHoursOffset(date, time.hoursOffset),\n            ].filter((r) => this.curRespondentsSet.has(r)).length\n\n            if (num > max) max = num\n          }\n        }\n      }\n      return max\n    },\n    /** Returns the day offset caused by the timezone offset. If the timezone offset changes the date, dayOffset != 0 */\n    dayOffset() {\n      return Math.floor((this.event.startTime - this.timezoneOffset / 60) / 24)\n    },\n    /** Returns all the days that are encompassed by startDate and endDate */\n    allDays() {\n      const days = []\n      const datesSoFar = new Set()\n\n      const getDateString = (date) => {\n        let dateString = \"\"\n        let dayString = \"\"\n        const offsetDate = new Date(date)\n        if (this.isSpecificTimes) {\n          offsetDate.setTime(\n            offsetDate.getTime() - this.timezoneOffset * 60 * 1000\n          )\n        } else {\n          offsetDate.setDate(offsetDate.getDate() + this.dayOffset)\n        }\n        // 使用 dayjs 格式化为中文日期\n        dateString = dayjs(offsetDate).format('M月D日')\n        dayString = this.daysOfWeek[offsetDate.getUTCDay()]\n        return { dateString, dayString }\n      }\n\n      if (\n        this.isSpecificTimes &&\n        (this.state === this.states.SET_SPECIFIC_TIMES ||\n          this.event.times?.length === 0)\n      ) {\n        let prevDate = null // Stores the prevDate to check if the current date is consecutive to the previous date\n        for (let i = 0; i < this.event.dates.length; ++i) {\n          const date = new Date(this.event.dates[i])\n          const localDate = new Date(\n            date.getTime() - this.timezoneOffset * 60 * 1000\n          )\n          localDate.setUTCHours(0, 0, 0, 0)\n          localDate.setTime(\n            localDate.getTime() + this.timezoneOffset * 60 * 1000\n          )\n\n          if (!datesSoFar.has(localDate.getTime())) {\n            datesSoFar.add(localDate.getTime())\n\n            let isConsecutive = true\n            if (prevDate) {\n              isConsecutive =\n                prevDate.getTime() === localDate.getTime() - 24 * 60 * 60 * 1000\n            }\n            const { dayString, dateString } = getDateString(localDate)\n            days.push({\n              dayText: dayString,\n              dateString,\n              dateObject: localDate,\n              isConsecutive,\n            })\n\n            prevDate = new Date(localDate)\n          }\n        }\n        return days\n      }\n\n      for (let i = 0; i < this.event.dates.length; ++i) {\n        const date = new Date(this.event.dates[i])\n        datesSoFar.add(date.getTime())\n\n        const { dayString, dateString } = getDateString(date)\n        days.push({\n          dayText: dayString,\n          dateString,\n          dateObject: date,\n        })\n      }\n\n      let dayIndex = 0\n      for (let i = 0; i < this.event.dates.length; ++i) {\n        const date = new Date(this.event.dates[i])\n        // See if the date goes into the next day\n        const localStart = new Date(\n          date.getTime() - this.timezoneOffset * 60 * 1000\n        )\n        const localEnd = new Date(\n          date.getTime() +\n            this.event.duration * 60 * 60 * 1000 -\n            this.timezoneOffset * 60 * 1000\n        )\n        const localEndIsMidnight =\n          localEnd.getUTCHours() === 0 && localEnd.getUTCMinutes() === 0\n        if (\n          localStart.getUTCDate() !== localEnd.getUTCDate() &&\n          !localEndIsMidnight\n        ) {\n          // The date goes into the next day. Split the date into two dates\n          let nextDate = new Date(date)\n          nextDate.setUTCDate(nextDate.getUTCDate() + 1)\n          if (!datesSoFar.has(nextDate.getTime())) {\n            datesSoFar.add(nextDate.getTime())\n\n            const { dayString, dateString } = getDateString(nextDate)\n            days.splice(dayIndex + 1, 0, {\n              dayText: dayString,\n              dateString,\n              dateObject: nextDate,\n              excludeTimes: true,\n            })\n            dayIndex++\n          }\n        }\n        dayIndex++\n      }\n\n      let prevDate = null // Stores the prevDate to check if the current date is consecutive to the previous date\n      for (let i = 0; i < days.length; ++i) {\n        let isConsecutive = true\n        if (prevDate) {\n          isConsecutive =\n            prevDate.getTime() ===\n            days[i].dateObject.getTime() - 24 * 60 * 60 * 1000\n        }\n\n        days[i].isConsecutive = isConsecutive\n\n        prevDate = new Date(days[i].dateObject)\n      }\n\n      return days\n    },\n    /** Returns a subset of all days based on the page number */\n    days() {\n      const slice = this.allDays.slice(\n        this.page * this.maxDaysPerPage,\n        (this.page + 1) * this.maxDaysPerPage\n      )\n      slice[0] = { ...slice[0], isConsecutive: true }\n      return slice\n    },\n    /** Returns all the days of the month */\n    monthDays() {\n      const monthDays = []\n      const allDaysSet = new Set(\n        this.allDays.map((d) => d.dateObject.getTime())\n      )\n\n      // Calculate monthIndex and year from event start date and page num\n      const date = new Date(this.event.dates[0])\n      const monthIndex = date.getUTCMonth() + this.page\n      const year = date.getUTCFullYear()\n\n      const lastDayOfPrevMonth = new Date(Date.UTC(year, monthIndex, 0))\n      const lastDayOfCurMonth = new Date(Date.UTC(year, monthIndex + 1, 0))\n\n      // Calculate num days from prev month, cur month, and next month to show\n      const curDate = new Date(lastDayOfPrevMonth)\n      let numDaysFromPrevMonth = 0\n      const numDaysInCurMonth = lastDayOfCurMonth.getUTCDate()\n      const numDaysFromNextMonth = 6 - lastDayOfCurMonth.getUTCDay()\n      const hasDaysFromPrevMonth = !this.startCalendarOnMonday\n        ? lastDayOfPrevMonth.getUTCDay() < 6\n        : lastDayOfPrevMonth.getUTCDay() != 0\n      if (hasDaysFromPrevMonth) {\n        curDate.setUTCDate(\n          curDate.getUTCDate() -\n            (lastDayOfPrevMonth.getUTCDay() -\n              (this.startCalendarOnMonday ? 1 : 0))\n        )\n        numDaysFromPrevMonth = lastDayOfPrevMonth.getUTCDay() + 1\n      } else {\n        curDate.setUTCDate(curDate.getUTCDate() + 1)\n      }\n      curDate.setUTCHours(this.event.startTime)\n\n      // Add all days from prev month, cur month, and next month\n      const totalDays =\n        numDaysFromPrevMonth + numDaysInCurMonth + numDaysFromNextMonth\n      for (let i = 0; i < totalDays; ++i) {\n        // Only include days from the current month\n        if (curDate.getUTCMonth() === lastDayOfCurMonth.getUTCMonth()) {\n          monthDays.push({\n            date: curDate.getUTCDate(),\n            time: curDate.getTime(),\n            dateObject: new Date(curDate),\n            included: allDaysSet.has(curDate.getTime()),\n          })\n        } else {\n          monthDays.push({\n            date: \"\",\n            time: curDate.getTime(),\n            dateObject: new Date(curDate),\n            included: false,\n          })\n        }\n\n        curDate.setUTCDate(curDate.getUTCDate() + 1)\n      }\n\n      return monthDays\n    },\n    /** Map from datetime to whether that month day is included  */\n    monthDayIncluded() {\n      const includedMap = new Map()\n      for (const monthDay of this.monthDays) {\n        includedMap.set(monthDay.dateObject.getTime(), monthDay.included)\n      }\n      return includedMap\n    },\n    /** Returns the text to show for the current month */\n    curMonthText() {\n      // 使用 dayjs 格式化为中文月份（如 7月）\n      const date = dayjs(this.event.dates[0]).add(this.page, 'month')\n      return date.format('M月')\n    },\n    defaultState() {\n      // Either the heatmap or the best_times state, depending on the toggle\n      return this.showBestTimes ? this.states.BEST_TIMES : this.states.HEATMAP\n    },\n    editing() {\n      // Returns whether currently in the editing state\n      return (\n        this.state === this.states.EDIT_AVAILABILITY ||\n        this.state === this.states.EDIT_SIGN_UP_BLOCKS\n      )\n    },\n    scheduling() {\n      // Returns whether currently in the scheduling state\n      return this.state === this.states.SCHEDULE_EVENT\n    },\n    isPhone() {\n      return isPhone(this.$vuetify)\n    },\n    isOwner() {\n      return this.authUser?._id === this.event.ownerId\n    },\n    isSpecificDates() {\n      return this.event.type === eventTypes.SPECIFIC_DATES || !this.event.type\n    },\n    isWeekly() {\n      return this.event.type === eventTypes.DOW\n    },\n    isGroup() {\n      return this.event.type === eventTypes.GROUP\n    },\n    isSignUp() {\n      return this.event.isSignUpForm\n    },\n    isSpecificTimes() {\n      return this.event.hasSpecificTimes\n    },\n    respondents() {\n      return Object.values(this.parsedResponses)\n        .map((r) => r.user)\n        .filter(Boolean)\n    },\n    selectedGuestRespondent() {\n      if (this.guestAddedAvailability) return this.guestName\n\n      if (this.curRespondents.length !== 1) return \"\"\n\n      const user = this.parsedResponses[this.curRespondents[0]].user\n      return this.isGuest(user) ? user._id : \"\"\n    },\n    scheduledEventStyle() {\n      const style = {}\n      let top, height, isSecondSplit\n      if (this.dragging) {\n        top = this.dragStart.row\n        height = this.dragCur.row - this.dragStart.row + 1\n        isSecondSplit = this.dragStart.row >= this.splitTimes[0].length\n      } else {\n        top = this.curScheduledEvent.row\n        height = this.curScheduledEvent.numRows\n        isSecondSplit = this.curScheduledEvent.row >= this.splitTimes[0].length\n      }\n\n      if (isSecondSplit) {\n        style.top = `calc(${top} * ${this.timeslotHeight}px + ${this.SPLIT_GAP_HEIGHT}px)`\n      } else {\n        style.top = `calc(${top} * ${this.timeslotHeight}px)`\n      }\n      style.height = `calc(${height} * ${this.timeslotHeight}px)`\n      return style\n    },\n    signUpBlockBeingDraggedStyle() {\n      const style = {}\n      let top = 0,\n        height = 0\n      if (this.dragging) {\n        top = this.dragStart.row\n        height = this.dragCur.row - this.dragStart.row + 1\n      }\n      style.top = `calc(${top} * 1rem)`\n      style.height = `calc(${height} * 1rem)`\n      return style\n    },\n    /** Parses the responses to the Schej, makes necessary changes based on the type of event, and returns it */\n    parsedResponses() {\n      const parsed = {}\n\n      // Return calendar availability if group\n      if (this.event.type === eventTypes.GROUP) {\n        for (const userId in this.event.responses) {\n          const calendarEventsByDay = this.groupCalendarEventsByDay[userId]\n          if (calendarEventsByDay) {\n            // Get manual availability and convert to DOW dates\n            const fetchedManualAvailability = this.getManualAvailabilityDow(\n              this.fetchedResponses[userId]?.manualAvailability\n            )\n            const curManualAvailability =\n              userId === this.authUser._id\n                ? this.getManualAvailabilityDow(this.manualAvailability)\n                : {}\n\n            // Get availability from calendar events and use manual availability on the\n            // \"touched\" days\n            const availability = this.getAvailabilityFromCalendarEvents({\n              calendarEventsByDay,\n              includeTouchedAvailability: true,\n              fetchedManualAvailability: fetchedManualAvailability ?? {},\n              curManualAvailability: curManualAvailability ?? {},\n              calendarOptions:\n                userId === this.authUser._id\n                  ? {\n                      bufferTime: this.bufferTime,\n                      workingHours: this.workingHours,\n                    }\n                  : this.fetchedResponses[userId]?.calendarOptions ?? undefined,\n            })\n\n            parsed[userId] = {\n              ...this.event.responses[userId],\n              availability: availability,\n            }\n          } else {\n            parsed[userId] = {\n              ...this.event.responses[userId],\n              availability: new Set(),\n            }\n          }\n        }\n        return parsed\n      }\n\n      // Return only current user availability if using blind availabilities and user is not owner\n      if (this.event.blindAvailabilityEnabled && !this.isOwner) {\n        const guestName = localStorage[this.guestNameKey]\n        const userId = this.authUser?._id ?? guestName\n        if (userId in this.event.responses) {\n          const user = {\n            ...this.event.responses[userId].user,\n            _id: userId,\n          }\n          parsed[userId] = {\n            ...this.event.responses[userId],\n            availability: new Set(\n              this.fetchedResponses[userId]?.availability?.map((a) =>\n                new Date(a).getTime()\n              )\n            ),\n            ifNeeded: new Set(\n              this.fetchedResponses[userId]?.ifNeeded?.map((a) =>\n                new Date(a).getTime()\n              )\n            ),\n            user: user,\n          }\n        }\n        return parsed\n      }\n\n      // Otherwise, parse responses so that if _id is null (i.e. guest user), then it is set to the guest user's name\n      for (const k of Object.keys(this.event.responses)) {\n        const newUser = {\n          ...this.event.responses[k].user,\n          _id: k,\n        }\n        parsed[k] = {\n          ...this.event.responses[k],\n          availability: new Set(\n            this.fetchedResponses[k]?.availability?.map((a) =>\n              new Date(a).getTime()\n            )\n          ),\n          ifNeeded: new Set(\n            this.fetchedResponses[k]?.ifNeeded?.map((a) =>\n              new Date(a).getTime()\n            )\n          ),\n          user: newUser,\n        }\n      }\n      return parsed\n    },\n    max() {\n      let max = 0\n      for (const [dateTime, availability] of this.responsesFormatted) {\n        if (availability.size > max) {\n          max = availability.size\n        }\n      }\n\n      return max\n    },\n    /** Returns a set containing the times for the event if it has specific times */\n    specificTimesSet() {\n      return new Set(this.event.times?.map((t) => new Date(t).getTime()) ?? [])\n    },\n    /**\n     * Returns a two dimensional array of times\n     * IF endTime < startTime:\n     * the first element is an array of times between 12am and end time and the second element is an array of times between start time and 12am\n     * ELSE:\n     * the first element is an array of times between start time and end time. the second element is an empty array\n     * */\n    splitTimes() {\n      const splitTimes = [[], []]\n\n      const utcStartTime = this.event.startTime\n      const utcEndTime = this.event.startTime + this.event.duration\n      const localStartTime = utcTimeToLocalTime(\n        utcStartTime,\n        this.timezoneOffset\n      )\n      const localEndTime = utcTimeToLocalTime(utcEndTime, this.timezoneOffset)\n\n      // Weird timezones are timezones that are not a multiple of 60 minutes (e.g. GMT-2:30)\n      const isWeirdTimezone = this.timezoneOffset % 60 !== 0\n      const startTimeIsWeird = utcStartTime % 1 !== 0\n      let timeOffset = 0\n      if (isWeirdTimezone !== startTimeIsWeird) {\n        timeOffset = -0.5\n      }\n\n      const getExtraTimes = (hoursOffset) => {\n        if (this.timeslotDuration === timeslotDurations.FIFTEEN_MINUTES) {\n          return [\n            {\n              hoursOffset: hoursOffset + 0.25,\n            },\n            {\n              hoursOffset: hoursOffset + 0.5,\n            },\n            {\n              hoursOffset: hoursOffset + 0.75,\n            },\n          ]\n        } else if (this.timeslotDuration === timeslotDurations.THIRTY_MINUTES) {\n          return [\n            {\n              hoursOffset: hoursOffset + 0.5,\n            },\n          ]\n        }\n        return []\n      }\n\n      if (this.state === this.states.SET_SPECIFIC_TIMES) {\n        // Hours offset for specific times starts from minHours\n        for (let i = 0; i <= 23; ++i) {\n          const hoursOffset = i\n          if (i === 9) {\n            // add an id so we can scroll to it\n            splitTimes[0].push({\n              id: \"time-9\",\n              hoursOffset,\n              text: timeNumToTimeText(i, this.timeType === timeTypes.HOUR12),\n            })\n          } else {\n            splitTimes[0].push({\n              hoursOffset,\n              text: timeNumToTimeText(i, this.timeType === timeTypes.HOUR12),\n            })\n          }\n          splitTimes[0].push(...getExtraTimes(hoursOffset))\n        }\n        return splitTimes\n      }\n\n      if (localEndTime <= localStartTime && localEndTime !== 0) {\n        for (let i = 0; i < localEndTime; ++i) {\n          splitTimes[0].push({\n            hoursOffset: this.event.duration - (localEndTime - i),\n            text: timeNumToTimeText(i, this.timeType === timeTypes.HOUR12),\n          })\n          splitTimes[0].push(\n            ...getExtraTimes(this.event.duration - (localEndTime - i))\n          )\n        }\n        for (let i = 0; i < 24 - localStartTime; ++i) {\n          const adjustedI = i + timeOffset\n          splitTimes[1].push({\n            hoursOffset: adjustedI,\n            text: timeNumToTimeText(\n              localStartTime + adjustedI,\n              this.timeType === timeTypes.HOUR12\n            ),\n          })\n          splitTimes[1].push(...getExtraTimes(adjustedI))\n        }\n      } else {\n        for (let i = 0; i < this.event.duration; ++i) {\n          const adjustedI = i + timeOffset\n          const utcTimeNum = this.event.startTime + adjustedI\n          const localTimeNum = utcTimeToLocalTime(\n            utcTimeNum,\n            this.timezoneOffset\n          )\n\n          splitTimes[0].push({\n            hoursOffset: adjustedI,\n            text: timeNumToTimeText(\n              localTimeNum,\n              this.timeType === timeTypes.HOUR12\n            ),\n          })\n          splitTimes[0].push(...getExtraTimes(adjustedI))\n        }\n        if (timeOffset !== 0) {\n          const localTimeNum = utcTimeToLocalTime(\n            this.event.startTime + this.event.duration - 0.5,\n            this.timezoneOffset\n          )\n          splitTimes[0].push({\n            hoursOffset: this.event.duration - 0.5,\n            text: timeNumToTimeText(\n              localTimeNum,\n              this.timeType === timeTypes.HOUR12\n            ),\n          })\n          splitTimes[0].push(...getExtraTimes(this.event.duration - 0.5))\n        }\n        splitTimes[1] = []\n      }\n\n      return splitTimes\n    },\n    /** Returns the times that are encompassed by startTime and endTime */\n    times() {\n      return [...this.splitTimes[1], ...this.splitTimes[0]]\n    },\n    timeslotDuration() {\n      return this.event.timeIncrement ?? timeslotDurations.FIFTEEN_MINUTES\n    },\n    timeslotHeight() {\n      if (this.timeslotDuration === timeslotDurations.FIFTEEN_MINUTES) {\n        return Math.floor(this.HOUR_HEIGHT / 4)\n      } else if (this.timeslotDuration === timeslotDurations.THIRTY_MINUTES) {\n        return Math.floor(this.HOUR_HEIGHT / 2)\n      } else if (this.timeslotDuration === timeslotDurations.ONE_HOUR) {\n        return this.HOUR_HEIGHT\n      }\n      return Math.floor(this.HOUR_HEIGHT / 4)\n    },\n    timezoneOffset() {\n      if (!(\"offset\" in this.curTimezone)) {\n        return new Date().getTimezoneOffset()\n      }\n\n      if (this.event.type === eventTypes.DOW) {\n        return this.curTimezone.offset * -1\n      }\n\n      // Can't just get the offset directly from curTimezone because it doesn't account for dates in the future\n      // when daylight savings might be in or out of effect, so instead, we get the timezone for the first date\n      // of the event\n      return (\n        dayjs(this.event.dates[0]).tz(this.curTimezone.value).utcOffset() * -1 // Multiply by -1 because offset is flipped\n      )\n    },\n    userHasResponded() {\n      return this.authUser && this.authUser._id in this.parsedResponses\n    },\n    showLeftZigZag() {\n      return this.calendarScrollLeft > 0\n    },\n    showRightZigZag() {\n      return Math.ceil(this.calendarScrollLeft) < this.calendarMaxScroll\n    },\n    maxDaysPerPage() {\n      return this.isPhone ? this.mobileNumDays : 7\n    },\n    hasNextPage() {\n      if (this.event.daysOnly) {\n        const lastDay = new Date(this.event.dates[this.event.dates.length - 1])\n        const curDate = new Date(this.event.dates[0])\n        const monthIndex = curDate.getUTCMonth() + this.page\n        const year = curDate.getUTCFullYear()\n\n        const lastDayOfCurMonth = new Date(Date.UTC(year, monthIndex + 1, 0))\n\n        return lastDayOfCurMonth.getTime() < lastDay.getTime()\n      }\n\n      return (\n        this.allDays.length - (this.page + 1) * this.maxDaysPerPage > 0 ||\n        this.event.type === eventTypes.GROUP\n      )\n    },\n    hasPrevPage() {\n      return this.page > 0 || this.event.type === eventTypes.GROUP\n    },\n    /** Returns whether the event has more than one page */\n    hasPages() {\n      return this.hasNextPage || this.hasPrevPage\n    },\n\n    showStickyRespondents() {\n      return (\n        this.isPhone &&\n        !this.scrolledToRespondents &&\n        (this.curTimeslot.row !== -1 ||\n          this.curRespondent.length > 0 ||\n          this.curRespondents.length > 0)\n      )\n    },\n\n    // Hint stuff\n    hintText() {\n      if (this.isPhone) {\n        switch (this.state) {\n          case this.isGroup && this.states.EDIT_AVAILABILITY:\n            return \"Toggle which calendars are used. Tap and drag to edit your availability.\"\n          case this.states.EDIT_AVAILABILITY:\n            const daysOrTimes = this.event.daysOnly ? \"days\" : \"times\"\n            if (this.availabilityType === availabilityTypes.IF_NEEDED) {\n              return `Tap and drag to add your \"if needed\" ${daysOrTimes} in yellow.`\n            }\n            return `Tap and drag to add your \"available\" ${daysOrTimes} in green.`\n          case this.states.SCHEDULE_EVENT:\n            return \"Tap and drag on the calendar to schedule a Google Calendar event during those times.\"\n          default:\n            return \"\"\n        }\n      }\n\n      switch (this.state) {\n        case this.isGroup && this.states.EDIT_AVAILABILITY:\n          return \"Toggle which calendars are used. Click and drag to edit your availability.\"\n        case this.states.EDIT_AVAILABILITY:\n          const daysOrTimes = this.event.daysOnly ? \"days\" : \"times\"\n          if (this.availabilityType === availabilityTypes.IF_NEEDED) {\n            return `Click and drag to add your \"if needed\" ${daysOrTimes} in yellow.`\n          }\n          return `Click and drag to add your \"available\" ${daysOrTimes} in green.`\n        case this.states.SCHEDULE_EVENT:\n          return \"Click and drag on the calendar to schedule a Google Calendar event during those times.\"\n        default:\n          return \"\"\n      }\n    },\n    hintClosed() {\n      return !this.hintState || localStorage[this.hintStateLocalStorageKey]\n    },\n    hintStateLocalStorageKey() {\n      return `closedHintText${this.state}` + (\"&isGroup\" ? this.isGroup : \"\")\n    },\n    hintTextShown() {\n      return this.showHintText && this.hintText != \"\" && !this.hintClosed\n    },\n\n    timeslotClassStyle() {\n      const classStyles = []\n      for (let d = 0; d < this.days.length; ++d) {\n        const day = this.days[d]\n        for (let t = 0; t < this.splitTimes[0].length; ++t) {\n          const time = this.splitTimes[0][t]\n          classStyles.push(this.getTimeTimeslotClassStyle(day, time, d, t))\n        }\n        for (let t = 0; t < this.splitTimes[1].length; ++t) {\n          const time = this.splitTimes[1][t]\n          classStyles.push(\n            this.getTimeTimeslotClassStyle(\n              day,\n              time,\n              d,\n              t + this.splitTimes[0].length\n            )\n          )\n        }\n      }\n      return classStyles\n    },\n    dayTimeslotClassStyle() {\n      const classStyles = []\n      for (let i = 0; i < this.monthDays.length; ++i) {\n        classStyles.push(\n          this.getDayTimeslotClassStyle(this.monthDays[i].dateObject, i)\n        )\n      }\n      return classStyles\n    },\n    timeslotVon() {\n      const vons = []\n      for (let d = 0; d < this.days.length; ++d) {\n        for (let t = 0; t < this.times.length; ++t) {\n          vons.push(this.getTimeslotVon(t, d))\n        }\n      }\n      return vons\n    },\n    dayTimeslotVon() {\n      const vons = []\n      for (let i = 0; i < this.monthDays.length; ++i) {\n        const row = Math.floor(i / 7)\n        const col = i % 7\n        vons.push(this.getTimeslotVon(row, col))\n      }\n      return vons\n    },\n\n    /** Whether to show spinner on top of availability grid */\n    showLoader() {\n      return (\n        // Loading calendar events\n        ((this.isGroup || this.alwaysShowCalendarEvents || this.editing) &&\n          this.loadingCalendarEvents) ||\n        // Loading responses\n        this.loadingResponses.loading\n      )\n    },\n\n    /** Localstorage key containing the guest's name */\n    guestNameKey() {\n      return `${this.event._id}.guestName`\n    },\n    /** The guest name stored in localstorage */\n    guestName() {\n      return localStorage[this.guestNameKey]\n    },\n    /** Whether a guest has added their availability (saved in localstorage) */\n    guestAddedAvailability() {\n      return (\n        this.guestName?.length > 0 && this.guestName in this.parsedResponses\n      )\n    },\n\n    /** Returns an array of time blocks representing the current user's availability\n     * (used for displaying current user's availability on top of everybody else's availability)\n     */\n    overlaidAvailability() {\n      const overlaidAvailability = []\n      this.days.forEach((day, d) => {\n        overlaidAvailability.push([])\n        let curBlockIndex = 0\n        const addOverlaidAvailabilityBlocks = (time, t) => {\n          const date = this.getDateFromRowCol(t, d)\n          if (!date) return\n\n          const dragAdd =\n            this.dragging &&\n            this.inDragRange(t, d) &&\n            this.dragType === this.DRAG_TYPES.ADD\n          const dragRemove =\n            this.dragging &&\n            this.inDragRange(t, d) &&\n            this.dragType === this.DRAG_TYPES.REMOVE\n\n          // Check if timeslot is available or if needed or in the drag region\n          if (\n            dragAdd ||\n            (!dragRemove &&\n              (this.availability.has(date.getTime()) ||\n                this.ifNeeded.has(date.getTime())))\n          ) {\n            // Determine whether to render as available or if needed block\n            let type = availabilityTypes.AVAILABLE\n            if (dragAdd) {\n              type = this.availabilityType\n            } else {\n              type = this.availability.has(date.getTime())\n                ? availabilityTypes.AVAILABLE\n                : availabilityTypes.IF_NEEDED\n            }\n\n            if (curBlockIndex in overlaidAvailability[d]) {\n              if (overlaidAvailability[d][curBlockIndex].type === type) {\n                // Increase block length if matching type and curBlockIndex exists\n                overlaidAvailability[d][curBlockIndex].hoursLength += 0.25\n              } else {\n                // Add a new block because type is different\n                overlaidAvailability[d].push({\n                  hoursOffset: time.hoursOffset,\n                  hoursLength: 0.25,\n                  type,\n                })\n                curBlockIndex++\n              }\n            } else {\n              // Add a new block because block doesn't exist for current index\n              overlaidAvailability[d].push({\n                hoursOffset: time.hoursOffset,\n                hoursLength: 0.25,\n                type,\n              })\n            }\n          } else if (curBlockIndex in overlaidAvailability[d]) {\n            // Only increment cur block index if block already exists at the current index\n            curBlockIndex++\n          }\n        }\n        for (let t = 0; t < this.splitTimes[0].length; ++t) {\n          addOverlaidAvailabilityBlocks(this.splitTimes[0][t], t)\n        }\n        if (curBlockIndex in overlaidAvailability[d]) {\n          curBlockIndex++\n        }\n        for (let t = 0; t < this.splitTimes[1].length; ++t) {\n          addOverlaidAvailabilityBlocks(\n            this.splitTimes[1][t],\n            t + this.splitTimes[0].length\n          )\n        }\n      })\n      return overlaidAvailability\n    },\n\n    // Options\n    showOverlayAvailabilityToggle() {\n      return this.respondents.length > 0 && this.overlayAvailabilitiesEnabled\n    },\n    showCalendarOptions() {\n      return (\n        !this.addingAvailabilityAsGuest &&\n        this.calendarPermissionGranted &&\n        (this.isGroup || (!this.isGroup && !this.userHasResponded))\n      )\n    },\n\n    /** Returns an array of the x-offsets of the columns, taking into account the split gaps from non-consecutive days */\n    columnOffsets() {\n      const offsets = []\n      let accumulatedOffset = 0\n      for (let i = 0; i < this.days.length; ++i) {\n        offsets.push(accumulatedOffset)\n        if (!this.days[i].isConsecutive) {\n          accumulatedOffset += this.SPLIT_GAP_WIDTH\n        }\n        accumulatedOffset += this.timeslot.width\n      }\n      return offsets\n    },\n  },\n  methods: {\n    ...mapMutations([\"setAuthUser\"]),\n    ...mapActions([\"showInfo\", \"showError\", \"showUpgradeDialog\"]),\n\n    // -----------------------------------\n    //#region Date\n    // -----------------------------------\n\n    /** Returns a date object from the dayindex and hoursoffset given */\n    getDateFromDayHoursOffset(dayIndex, hoursOffset) {\n      return getDateHoursOffset(this.days[dayIndex].dateObject, hoursOffset)\n    },\n    /** Returns a date object from the row and column given on the current page */\n    getDateFromRowCol(row, col) {\n      if (this.event.daysOnly) {\n        const dateObject = this.monthDays[row * 7 + col]?.dateObject\n        if (!dateObject) return null\n        return new Date(dateObject)\n      } else {\n        return this.getDateFromDayTimeIndex(\n          this.maxDaysPerPage * this.page + col,\n          row\n        )\n      }\n    },\n    isColConsecutive(col) {\n      return Boolean(this.days[col]?.isConsecutive)\n    },\n    /** Returns a date object from the day index and time index given */\n    getDateFromDayTimeIndex(dayIndex, timeIndex) {\n      const hasSecondSplit = this.splitTimes[1].length > 0\n      const isFirstSplit = timeIndex < this.splitTimes[0].length\n      const time = isFirstSplit\n        ? this.splitTimes[0][timeIndex]\n        : this.splitTimes[1][timeIndex - this.splitTimes[0].length]\n      let adjustedDayIndex = dayIndex\n      if (hasSecondSplit) {\n        if (isFirstSplit) {\n          adjustedDayIndex = dayIndex - 1\n        } else if (dayIndex === this.allDays.length - 1) {\n          return null\n        }\n      }\n      const day = this.allDays[adjustedDayIndex]\n      if (!day || !time) return null\n      if (day.excludeTimes) {\n        return null\n      }\n\n      const date = getDateHoursOffset(day.dateObject, time.hoursOffset)\n      if (this.isSpecificTimes) {\n        // TODO: see if we need to do anything for 0.5 timezones\n        if (\n          this.state !== this.states.SET_SPECIFIC_TIMES &&\n          this.event.times?.length > 0\n        ) {\n          if (!this.specificTimesSet.has(date.getTime())) {\n            return null\n          }\n        }\n      } else {\n        // Return null for times outside of the correct range\n        if (time.hoursOffset < 0 || time.hoursOffset >= this.event.duration) {\n          return null\n        }\n      }\n      return date\n    },\n    //#endregion\n\n    // -----------------------------------\n    //#region Respondent\n    // -----------------------------------\n    mouseOverRespondent(e, id) {\n      if (this.curRespondents.length === 0) {\n        if (this.state === this.defaultState) {\n          this.state = this.states.SINGLE_AVAILABILITY\n        }\n\n        this.curRespondent = id\n      }\n    },\n    mouseLeaveRespondent(e) {\n      if (this.curRespondents.length === 0) {\n        if (this.state === this.states.SINGLE_AVAILABILITY) {\n          this.state = this.defaultState\n        }\n\n        this.curRespondent = \"\"\n      }\n    },\n    clickRespondent(e, id) {\n      this.state = this.states.SUBSET_AVAILABILITY\n      this.curRespondent = \"\"\n\n      if (this.curRespondentsSet.has(id)) {\n        // Remove id\n        this.curRespondents = this.curRespondents.filter((r) => r != id)\n\n        // Go back to default state if all users deselected\n        if (this.curRespondents.length === 0) {\n          this.state = this.defaultState\n        }\n      } else {\n        // Add id\n        this.curRespondents.push(id)\n      }\n\n      e.stopPropagation()\n    },\n    deselectRespondents(e) {\n      // Don't deselect respondents if toggled best times\n      // or if this was fired by clicking on a timeslot\n      if (\n        e?.target?.previousElementSibling?.id === \"show-best-times-toggle\" ||\n        e?.target?.firstChild?.firstChild?.id === \"show-best-times-toggle\" ||\n        e?.target?.classList?.contains(\"timeslot\") //&& this.isPhone)\n      )\n        return\n\n      if (this.state === this.states.SUBSET_AVAILABILITY) {\n        this.state = this.defaultState\n      }\n\n      this.curRespondents = []\n\n      // Stop persisting timeslot\n      this.timeslotSelected = false\n      this.resetCurTimeslot()\n    },\n\n    isGuest(user) {\n      return user._id == user.firstName\n    },\n    //#endregion\n\n    // -----------------------------------\n    //#region Aggregate user availability\n    // -----------------------------------\n\n    /** Fetches responses from server */\n    fetchResponses() {\n      if (this.calendarOnly) {\n        this.fetchedResponses = this.event.responses\n        return\n      }\n\n      let timeMin, timeMax\n      if (this.event.type === eventTypes.GROUP) {\n        if (this.event.dates.length > 0) {\n          // Fetch the date range for the current week\n          timeMin = new Date(this.event.dates[0])\n          timeMax = new Date(this.event.dates[this.event.dates.length - 1])\n          timeMax.setDate(timeMax.getDate() + 1)\n\n          // Convert dow dates to discrete dates\n          timeMin = dateToDowDate(\n            this.event.dates,\n            timeMin,\n            this.weekOffset,\n            true\n          )\n          timeMax = dateToDowDate(\n            this.event.dates,\n            timeMax,\n            this.weekOffset,\n            true\n          )\n        }\n      } else {\n        if (this.allDays.length > 0) {\n          // Fetch the entire time range of availabilities\n          timeMin = new Date(this.allDays[0].dateObject)\n          timeMax = new Date(this.allDays[this.allDays.length - 1].dateObject)\n          timeMax.setDate(timeMax.getDate() + 1)\n        }\n      }\n\n      if (!timeMin || !timeMax) return\n\n      // Fetch responses between timeMin and timeMax\n      const url = `/events/${\n        this.event._id\n      }/responses?timeMin=${timeMin.toISOString()}&timeMax=${timeMax.toISOString()}`\n      get(url)\n        .then((responses) => {\n          this.fetchedResponses = responses\n          this.getResponsesFormatted()\n        })\n        .catch((err) => {\n          this.showError(\n            \"There was an error fetching availability! Please refresh the page.\"\n          )\n        })\n    },\n    /** Formats the responses in a map where date/time is mapped to the people that are available then */\n    getResponsesFormatted() {\n      const lastFetched = new Date().getTime()\n      this.loadingResponses.loading = true\n      this.loadingResponses.lastFetched = lastFetched\n\n      this.$worker\n        .run(\n          (days, times, parsedResponses, daysOnly, hideIfNeeded) => {\n            // Define functions locally because we can't import functions\n            const splitTimeNum = (timeNum) => {\n              const hours = Math.floor(timeNum)\n              const minutes = Math.floor((timeNum - hours) * 60)\n              return { hours, minutes }\n            }\n            const getDateHoursOffset = (date, hoursOffset) => {\n              const { hours, minutes } = splitTimeNum(hoursOffset)\n              const newDate = new Date(date)\n              newDate.setHours(newDate.getHours() + hours)\n              newDate.setMinutes(newDate.getMinutes() + minutes)\n              return newDate\n            }\n\n            // Create array of all dates in the event\n            const dates = []\n            if (daysOnly) {\n              for (const day of days) {\n                dates.push(day.dateObject)\n              }\n            } else {\n              for (const day of days) {\n                for (const time of times) {\n                  // Iterate through all the times\n                  const date = getDateHoursOffset(\n                    day.dateObject,\n                    time.hoursOffset\n                  )\n                  dates.push(date)\n                }\n              }\n            }\n\n            // Create a map mapping time to the respondents available during that time\n            const formatted = new Map()\n            for (const date of dates) {\n              formatted.set(date.getTime(), new Set())\n\n              // Check every response and see if they are available for the given time\n              for (const response of Object.values(parsedResponses)) {\n                // Check availability array\n                if (\n                  response.availability?.has(date.getTime()) ||\n                  (response.ifNeeded?.has(date.getTime()) && !hideIfNeeded)\n                ) {\n                  formatted.get(date.getTime()).add(response.user._id)\n                  continue\n                }\n              }\n            }\n            return formatted\n          },\n          [\n            this.allDays,\n            this.times,\n            this.parsedResponses,\n            this.event.daysOnly,\n            this.hideIfNeeded,\n          ]\n        )\n        .then((formatted) => {\n          // Only set responses formatted for the latest request\n          if (lastFetched >= this.loadingResponses.lastFetched) {\n            this.responsesFormatted = formatted\n          }\n        })\n        .finally(() => {\n          if (this.loadingResponses.lastFetched === lastFetched) {\n            this.loadingResponses.loading = false\n          }\n        })\n    },\n    /** Returns a set of respondents for the given date/time */\n    getRespondentsForHoursOffset(date, hoursOffset) {\n      const d = getDateHoursOffset(date, hoursOffset)\n      return this.responsesFormatted.get(d.getTime()) ?? new Set()\n    },\n    showAvailability(row, col) {\n      if (this.state === this.states.EDIT_AVAILABILITY && this.isPhone) {\n        // Don't show currently selected timeslot when on phone and editing\n        return\n      }\n\n      // Update current timeslot (the timeslot that has a dotted border around it)\n      this.curTimeslot = { row, col }\n\n      if (this.state === this.states.EDIT_AVAILABILITY || this.curRespondent) {\n        // Don't show availability when editing or when respondent is selected\n        return\n      }\n\n      const date = this.getDateFromRowCol(row, col)\n      if (!date) return\n\n      // Update current timeslot availability to show who is available for the given timeslot\n      const available = this.responsesFormatted.get(date.getTime()) ?? new Set()\n      for (const respondent of this.respondents) {\n        if (available.has(respondent._id)) {\n          this.curTimeslotAvailability[respondent._id] = true\n        } else {\n          this.curTimeslotAvailability[respondent._id] = false\n        }\n      }\n    },\n    //#endregion\n\n    // -----------------------------------\n    //#region Current user availability\n    // -----------------------------------\n    async refreshAuthUser() {\n      this.hasRefreshedAuthUser = true\n      await get(\"/user/profile\").then((authUser) => {\n        this.setAuthUser(authUser)\n      })\n    },\n    /** resets cur user availability to the response stored on the server */\n    resetCurUserAvailability() {\n      if (this.event.type === eventTypes.GROUP) {\n        this.initSharedCalendarAccounts()\n        this.manualAvailability = {}\n      }\n\n      this.availability = new Set()\n      this.ifNeeded = new Set()\n      if (this.userHasResponded) {\n        this.populateUserAvailability(this.authUser._id)\n      }\n    },\n    /** Populates the availability set for the auth user from the responses object stored on the server */\n    populateUserAvailability(id) {\n      this.availability =\n        new Set(this.parsedResponses[id]?.availability) ?? new Set()\n      this.ifNeeded = new Set(this.parsedResponses[id]?.ifNeeded) ?? new Set()\n      this.$nextTick(() => (this.unsavedChanges = false))\n    },\n    /** Returns true if the calendar event is in the first split */\n    getIsTimeBlockInFirstSplit(timeBlock) {\n      return (\n        timeBlock.hoursOffset >= this.splitTimes[0][0].hoursOffset &&\n        timeBlock.hoursOffset <=\n          this.splitTimes[0][this.splitTimes[0].length - 1].hoursOffset\n      )\n    },\n    /** Returns the style for the calendar event block */\n    getTimeBlockStyle(timeBlock) {\n      const style = {}\n      const hasSecondSplit = this.splitTimes[1].length > 0\n      if (!hasSecondSplit || this.getIsTimeBlockInFirstSplit(timeBlock)) {\n        style.top = `calc(${\n          timeBlock.hoursOffset - this.splitTimes[0][0].hoursOffset\n        } * ${this.HOUR_HEIGHT}px)`\n        style.height = `calc(${timeBlock.hoursLength} * ${this.HOUR_HEIGHT}px)`\n      } else {\n        style.top = `calc(${this.splitTimes[0].length} * ${\n          this.timeslotHeight\n        }px + ${this.SPLIT_GAP_HEIGHT}px + ${\n          timeBlock.hoursOffset - this.splitTimes[1][0].hoursOffset\n        } * ${this.HOUR_HEIGHT}px)`\n        style.height = `calc(${timeBlock.hoursLength} * ${this.HOUR_HEIGHT}px)`\n      }\n      return style\n    },\n    /** Returns a set containing the available times based on the given calendar events object */\n    getAvailabilityFromCalendarEvents({\n      calendarEventsByDay = [],\n      includeTouchedAvailability = false, // Whether to include manual availability for touched days\n      fetchedManualAvailability = {}, // Object mapping unix timestamp to array of manual availability (fetched from server)\n      curManualAvailability = {}, // Manual availability with edits (takes precedence over fetchedManualAvailability)\n      calendarOptions = calendarOptionsDefaults, // User id of the user we are getting availability for\n    }) {\n      const availability = new Set()\n\n      for (let i = 0; i < this.allDays.length; ++i) {\n        const day = this.allDays[i]\n        const date = day.dateObject\n\n        if (includeTouchedAvailability) {\n          const endDate = getDateHoursOffset(\n            date,\n            this.times.length * (this.timeslotDuration / 60)\n          )\n\n          // Check if manual availability has been added for the current date\n          let manualAvailabilityAdded = false\n\n          for (const time in curManualAvailability) {\n            if (date.getTime() <= time && time <= endDate.getTime()) {\n              curManualAvailability[time].forEach((a) => {\n                availability.add(new Date(a).getTime())\n              })\n              delete curManualAvailability[time]\n              manualAvailabilityAdded = true\n              break\n            }\n          }\n\n          if (manualAvailabilityAdded) continue\n\n          for (const time in fetchedManualAvailability) {\n            if (date.getTime() <= time && time <= endDate.getTime()) {\n              fetchedManualAvailability[time].forEach((a) => {\n                availability.add(new Date(a).getTime())\n              })\n              delete fetchedManualAvailability[time]\n              manualAvailabilityAdded = true\n              break\n            }\n          }\n\n          if (manualAvailabilityAdded) continue\n        }\n\n        // Calculate buffer time\n        const bufferTimeInMS = calendarOptions.bufferTime.enabled\n          ? calendarOptions.bufferTime.time * 1000 * 60\n          : 0\n\n        // Calculate working hours\n        const startTimeString = timeNumToTimeString(\n          calendarOptions.workingHours.startTime\n        )\n        const isoDateString = getISODateString(getDateWithTimezone(date), true)\n        const workingHoursStartDate = dayjs\n          .tz(`${isoDateString} ${startTimeString}`, this.curTimezone.value)\n          .toDate()\n        let duration =\n          calendarOptions.workingHours.endTime -\n          calendarOptions.workingHours.startTime\n        if (duration <= 0) duration += 24\n        const workingHoursEndDate = getDateHoursOffset(\n          workingHoursStartDate,\n          duration\n        )\n\n        for (let j = 0; j < this.times.length; ++j) {\n          const startDate = this.getDateFromDayTimeIndex(i, j)\n          if (!startDate) continue\n          const endDate = getDateHoursOffset(\n            startDate,\n            this.timeslotDuration / 60\n          )\n\n          // Working hours\n          if (calendarOptions.workingHours.enabled) {\n            if (\n              endDate.getTime() <= workingHoursStartDate.getTime() ||\n              startDate.getTime() >= workingHoursEndDate.getTime()\n            ) {\n              continue\n            }\n          }\n\n          // Check if there exists a calendar event that overlaps [startDate, endDate]\n          const index = calendarEventsByDay[i]?.findIndex((e) => {\n            const startDateBuffered = new Date(\n              e.startDate.getTime() - bufferTimeInMS\n            )\n            const endDateBuffered = new Date(\n              e.endDate.getTime() + bufferTimeInMS\n            )\n\n            const notIntersect =\n              dateCompare(endDate, startDateBuffered) <= 0 ||\n              dateCompare(startDate, endDateBuffered) >= 0\n            return !notIntersect && !e.free\n          })\n          if (index === -1) {\n            availability.add(startDate.getTime())\n          }\n        }\n      }\n      return availability\n    },\n    /** Constructs the availability array using calendarEvents array */\n    setAvailabilityAutomatically() {\n      // This is not a computed property because we should be able to change it manually from what it automatically fills in\n      this.availability = new Set()\n      const tmpAvailability = this.getAvailabilityFromCalendarEvents({\n        calendarEventsByDay: this.calendarEventsByDay,\n        calendarOptions: {\n          bufferTime: this.bufferTime,\n          workingHours: this.workingHours,\n        },\n      })\n\n      const pageStartDate = getDateDayOffset(\n        new Date(this.event.dates[0]),\n        this.page * this.maxDaysPerPage\n      )\n      const pageEndDate = getDateDayOffset(pageStartDate, this.maxDaysPerPage)\n      this.animateAvailability(tmpAvailability, pageStartDate, pageEndDate)\n    },\n    /** Animate the filling out of availability using setTimeout, between startDate and endDate */\n    animateAvailability(availability, startDate, endDate) {\n      this.availabilityAnimEnabled = true\n      this.availabilityAnimTimeouts = []\n\n      let msPerGroup = 25\n      let blocksPerGroup = 2\n      if (\n        (availability.size / blocksPerGroup) * msPerGroup >\n        this.maxAnimTime\n      ) {\n        blocksPerGroup = (availability.size * msPerGroup) / this.maxAnimTime\n      }\n      let availabilityArray = [...availability]\n      availabilityArray = availabilityArray.filter((a) =>\n        isDateBetween(a, startDate, endDate)\n      )\n\n      for (let i = 0; i < availabilityArray.length / blocksPerGroup + 1; ++i) {\n        const timeout = setTimeout(() => {\n          for (const a of availabilityArray.slice(\n            i * blocksPerGroup,\n            i * blocksPerGroup + blocksPerGroup\n          )) {\n            this.availability.add(a)\n          }\n          this.availability = new Set(this.availability)\n          if (i >= availabilityArray.length / blocksPerGroup) {\n            // Make sure the entire availability has been added (will not be guaranteed when only animating a portion of availability)\n            this.availability = new Set(availability)\n            this.availabilityAnimTimeouts.push(\n              setTimeout(() => {\n                this.availabilityAnimEnabled = false\n\n                if (this.showSnackbar) {\n                  this.showInfo(\"Your availability has been autofilled!\")\n                }\n                this.unsavedChanges = false\n              }, 500)\n            )\n          }\n        }, i * msPerGroup)\n\n        this.availabilityAnimTimeouts.push(timeout)\n      }\n    },\n    stopAvailabilityAnim() {\n      for (const timeout of this.availabilityAnimTimeouts) {\n        clearTimeout(timeout)\n      }\n      this.availabilityAnimEnabled = false\n    },\n    async submitAvailability(guestPayload = { name: \"\", email: \"\" }) {\n      let payload = {}\n\n      let type = \"\"\n      // If this is a group submit enabled calendars, otherwise submit availability\n      if (this.isGroup) {\n        type = \"group availability and calendars\"\n        payload = generateEnabledCalendarsPayload(this.sharedCalendarAccounts)\n        payload.manualAvailability = {}\n        for (const day of Object.keys(this.manualAvailability)) {\n          payload.manualAvailability[day] = [\n            ...this.manualAvailability[day],\n          ].map((a) => new Date(a))\n        }\n        payload.calendarOptions = {\n          bufferTime: this.bufferTime,\n          workingHours: this.workingHours,\n        }\n      } else {\n        type = \"availability\"\n        payload.availability = this.availabilityArray\n        payload.ifNeeded = this.ifNeededArray\n        if (this.authUser && !this.addingAvailabilityAsGuest) {\n          payload.guest = false\n        } else {\n          payload.guest = true\n          payload.name = guestPayload.name\n          payload.email = guestPayload.email\n          localStorage[this.guestNameKey] = guestPayload.name\n        }\n      }\n\n      await post(`/events/${this.event._id}/response`, payload)\n\n      // Update analytics\n      const addedIfNeededTimes = this.ifNeededArray.length > 0\n      if (this.authUser) {\n        if (this.authUser._id in this.parsedResponses) {\n          this.$posthog?.capture(`Edited ${type}`, {\n            eventId: this.event._id,\n            addedIfNeededTimes,\n          })\n        } else {\n          this.$posthog?.capture(`Added ${type}`, {\n            eventId: this.event._id,\n            addedIfNeededTimes,\n            // bufferTime: this.bufferTime,\n            bufferTime: this.bufferTime.time,\n            bufferTimeActive: this.bufferTime.enabled,\n            workingHoursEnabled: this.workingHours.enabled,\n            workingHoursStartTime: this.workingHours.startTime,\n            workingHoursEndTime: this.workingHours.endTime,\n          })\n        }\n      } else {\n        if (guestPayload.name in this.parsedResponses) {\n          this.$posthog?.capture(`Edited ${type} as guest`, {\n            eventId: this.event._id,\n            addedIfNeededTimes,\n          })\n        } else {\n          this.$posthog?.capture(`Added ${type} as guest`, {\n            eventId: this.event._id,\n            addedIfNeededTimes,\n          })\n        }\n      }\n\n      this.refreshEvent()\n      this.unsavedChanges = false\n    },\n    async submitNewSignUpBlocks() {\n      if (\n        this.signUpBlocksToAddByDay.flat().length +\n          this.signUpBlocksByDay.flat().length ===\n        0\n      ) {\n        this.showError(\"Please add at least one sign-up block!\")\n        return false\n      }\n\n      for (let i = 0; i < this.signUpBlocksToAddByDay.length; ++i) {\n        this.signUpBlocksByDay[i] = this.signUpBlocksByDay[i].concat(\n          this.signUpBlocksToAddByDay[i]\n        )\n        this.signUpBlocksToAddByDay[i] = []\n      }\n\n      const payload = {\n        name: this.event.name,\n        duration: this.event.duration,\n        dates: this.event.dates,\n        type: this.event.type,\n        signUpBlocks: this.signUpBlocksByDay.flat().map((block) => {\n          return {\n            _id: block._id,\n            name: block.name,\n            capacity: block.capacity,\n            startDate: block.startDate,\n            endDate: block.endDate,\n          }\n        }),\n      }\n\n      put(`/events/${this.event._id}`, payload)\n        .then(() => {\n          // window.location.reload()\n        })\n        .catch((err) => {\n          console.error(err)\n          this.showError(\n            \"There was a problem editing this event! Please try again later.\"\n          )\n        })\n\n      return true\n    },\n\n    async deleteAvailability(name = \"\") {\n      const payload = {}\n      if (this.authUser && !this.addingAvailabilityAsGuest) {\n        payload.guest = false\n        payload.userId = this.authUser._id\n\n        this.$posthog?.capture(\"Deleted availability\", {\n          eventId: this.event._id,\n        })\n      } else {\n        payload.guest = true\n        payload.name = name\n\n        this.$posthog?.capture(\"Deleted availability as guest\", {\n          eventId: this.event._id,\n          name,\n        })\n      }\n      await _delete(`/events/${this.event._id}/response`, payload)\n      this.availability = new Set()\n      if (this.isGroup) this.$router.replace({ name: \"home\" })\n      else this.refreshEvent()\n    },\n    //#endregion\n\n    // -----------------------------------\n    //#region Timeslot\n    // -----------------------------------\n    setTimeslotSize() {\n      /* Gets the dimensions of each timeslot and assigns it to the timeslot variable */\n      const timeslotEl = document.querySelector(\".timeslot\")\n      if (timeslotEl) {\n        ;({ width: this.timeslot.width, height: this.timeslot.height } =\n          timeslotEl.getBoundingClientRect())\n      }\n    },\n    /** Returns a class string and style object for the given time timeslot div */\n    getTimeTimeslotClassStyle(day, time, d, t) {\n      const row = t\n      const col = d\n      const date = this.getDateFromRowCol(row, col)\n      const classStyle = this.getTimeslotClassStyle(date, row, col)\n\n      // Add time timeslot specific stuff\n      const isFirstSplit = t < this.splitTimes[0].length\n      const isDisabled = !date\n\n      // Animation\n      if (this.animateTimeslotAlways || this.availabilityAnimEnabled) {\n        classStyle.class += \"animate-bg-color \"\n      }\n\n      // Height\n      classStyle.style.height = `${this.timeslotHeight}px`\n\n      // Border style\n      if (\n        (this.respondents.length > 0 ||\n          this.editing ||\n          this.state === this.states.SET_SPECIFIC_TIMES) &&\n        this.curTimeslot.row === row &&\n        this.curTimeslot.col === col &&\n        !isDisabled\n      ) {\n        // Dashed border for currently selected timeslot\n        classStyle.class +=\n          \"tw-border tw-border-dashed tw-border-black tw-z-10 \"\n      } else {\n        // Normal border\n        if (date) {\n          const localDate = new Date(\n            date.getTime() - this.timezoneOffset * 60 * 1000\n          )\n          const fractionalTime = localDate.getMinutes()\n          if (fractionalTime === 0) {\n            classStyle.class += \"tw-border-t \"\n          } else if (fractionalTime === 30) {\n            classStyle.class += \"tw-border-t \"\n            classStyle.style.borderTopStyle = \"dashed\"\n          }\n        }\n\n        classStyle.class += \"tw-border-r \"\n        if (col === 0 || !this.isColConsecutive(col))\n          classStyle.class += \"tw-border-l tw-border-l-gray \"\n        if (col === this.days.length - 1 || !this.isColConsecutive(col + 1))\n          classStyle.class += \"tw-border-r-gray \"\n        if (isFirstSplit && row === 0)\n          classStyle.class += \"tw-border-t tw-border-t-gray \"\n        if (!isFirstSplit && row === this.splitTimes[0].length)\n          classStyle.class += \"tw-border-t tw-border-t-gray \"\n        if (isFirstSplit && row === this.splitTimes[0].length - 1)\n          classStyle.class += \"tw-border-b tw-border-b-gray \"\n        if (\n          !isFirstSplit &&\n          row === this.splitTimes[0].length + this.splitTimes[1].length - 1\n        )\n          classStyle.class += \"tw-border-b tw-border-b-gray \"\n\n        const totalRespondents =\n          this.state === this.states.SUBSET_AVAILABILITY\n            ? this.curRespondents.length\n            : this.respondents.length\n        if (\n          this.state === this.states.EDIT_AVAILABILITY ||\n          this.state === this.states.SINGLE_AVAILABILITY ||\n          totalRespondents === 1\n        ) {\n          classStyle.class += \"tw-border-[#999999] \"\n        } else {\n          classStyle.class += \"tw-border-[#DDDDDD99] \"\n        }\n      }\n\n      // Edit fill color and border color if day is not interactable\n      if (isDisabled) {\n        classStyle.class +=\n          \"tw-bg-light-gray-stroke tw-border-light-gray-stroke \"\n      }\n\n      // Change default red:\n      if (classStyle.style.backgroundColor === \"#E523230D\") {\n        classStyle.style.backgroundColor = \"#E5232333\"\n      }\n\n      return classStyle\n    },\n    /** Returns the shared class string and style object for the given timeslot (either time timeslot or day timeslot) */\n    getTimeslotClassStyle(date, row, col) {\n      let c = \"\"\n      const s = {}\n      if (!date) return { class: c, style: s }\n\n      const timeslotRespondents =\n        this.responsesFormatted.get(date.getTime()) ?? new Set()\n\n      // Fill style\n\n      if (this.isSignUp) {\n        c += \"tw-bg-light-gray \"\n        return { class: c, style: s }\n      }\n\n      if (\n        (!this.overlayAvailability &&\n          this.state === this.states.EDIT_AVAILABILITY) ||\n        this.state === this.states.SET_SPECIFIC_TIMES\n      ) {\n        // Set default background color to red (unavailable)\n        s.backgroundColor = \"#E523230D\"\n\n        // Show only current user availability\n        const inDragRange = this.inDragRange(row, col)\n        if (inDragRange) {\n          // Set style if drag range goes over the current timeslot\n          if (this.dragType === this.DRAG_TYPES.ADD) {\n            if (this.state === this.states.SET_SPECIFIC_TIMES) {\n              c += \"tw-bg-white \"\n            } else {\n              if (this.availabilityType === availabilityTypes.AVAILABLE) {\n                s.backgroundColor = \"#00994C77\"\n              } else if (\n                this.availabilityType === availabilityTypes.IF_NEEDED\n              ) {\n                c += \"tw-bg-yellow \"\n              }\n            }\n          } else if (this.dragType === this.DRAG_TYPES.REMOVE) {\n            if (this.state === this.states.SET_SPECIFIC_TIMES) {\n              c += \"tw-bg-gray \"\n            }\n          }\n        } else {\n          // Otherwise just show the current availability\n          // Show current availability from availability set\n          if (this.state === this.states.SET_SPECIFIC_TIMES) {\n            if (this.tempTimes.has(date.getTime())) {\n              c += \"tw-bg-white \"\n            } else {\n              c += \"tw-bg-gray \"\n            }\n          } else {\n            if (this.availability.has(date.getTime())) {\n              s.backgroundColor = \"#00994C77\"\n            } else if (this.ifNeeded.has(date.getTime())) {\n              c += \"tw-bg-yellow \"\n            }\n          }\n        }\n      }\n\n      if (this.state === this.states.SINGLE_AVAILABILITY) {\n        // Show only the currently selected respondent's availability\n        const respondent = this.curRespondent\n        if (timeslotRespondents.has(respondent)) {\n          if (this.parsedResponses[respondent]?.ifNeeded?.has(date.getTime())) {\n            c += \"tw-bg-yellow \"\n          } else {\n            s.backgroundColor = \"#00994C77\"\n          }\n        } else {\n          s.backgroundColor = \"#E523230D\"\n        }\n        return { class: c, style: s }\n      }\n\n      if (\n        this.overlayAvailability ||\n        this.state === this.states.BEST_TIMES ||\n        this.state === this.states.HEATMAP ||\n        this.state === this.states.SCHEDULE_EVENT ||\n        this.state === this.states.SUBSET_AVAILABILITY\n      ) {\n        let numRespondents\n        let max\n\n        if (\n          this.state === this.states.BEST_TIMES ||\n          this.state === this.states.HEATMAP ||\n          this.state === this.states.SCHEDULE_EVENT\n        ) {\n          numRespondents = timeslotRespondents.size\n          max = this.max\n        } else if (this.state === this.states.SUBSET_AVAILABILITY) {\n          numRespondents = [...timeslotRespondents].filter((r) =>\n            this.curRespondentsSet.has(r)\n          ).length\n\n          max = this.curRespondentsMax\n        } else if (this.overlayAvailability) {\n          if (\n            (this.userHasResponded || this.curGuestId?.length > 0) &&\n            timeslotRespondents.has(this.authUser?._id ?? this.curGuestId)\n          ) {\n            // Subtract 1 because we do not want to include current user's availability\n            numRespondents = timeslotRespondents.size - 1\n            max = this.max\n          } else {\n            numRespondents = timeslotRespondents.size\n            max = this.max\n          }\n        }\n\n        const totalRespondents =\n          this.state === this.states.SUBSET_AVAILABILITY\n            ? this.curRespondents.length\n            : this.respondents.length\n\n        if (this.defaultState === this.states.BEST_TIMES) {\n          if (max > 0 && numRespondents === max) {\n            // Only set timeslot to green for the times that most people are available\n            if (totalRespondents === 1 || this.overlayAvailability) {\n              // Make single responses less saturated\n              const green = \"#00994C88\"\n              s.backgroundColor = green\n            } else {\n              const green = \"#00994C\"\n              s.backgroundColor = green\n            }\n          }\n        } else if (this.defaultState === this.states.HEATMAP) {\n          if (numRespondents > 0) {\n            if (totalRespondents === 1) {\n              const respondentId =\n                this.state === this.states.SUBSET_AVAILABILITY\n                  ? this.curRespondents[0]\n                  : this.respondents[0]._id\n              if (\n                this.parsedResponses[respondentId]?.ifNeeded?.has(\n                  date.getTime()\n                )\n              ) {\n                c += \"tw-bg-yellow \"\n              } else {\n                const green = \"#00994C88\"\n                s.backgroundColor = green\n              }\n            } else {\n              // Determine color of timeslot based on number of people available\n              const frac = numRespondents / max\n              const green = \"#00994C\"\n              let alpha\n              if (!this.overlayAvailability) {\n                alpha = Math.floor(frac * (255 - 30))\n                  .toString(16)\n                  .toUpperCase()\n                  .substring(0, 2)\n                  .padStart(2, \"0\")\n                if (\n                  frac == 1 &&\n                  ((this.curRespondents.length > 0 &&\n                    max === this.curRespondents.length) ||\n                    (this.curRespondents.length === 0 &&\n                      max === this.respondents.length))\n                ) {\n                  alpha = \"FF\"\n                }\n              } else {\n                alpha = Math.floor(frac * (255 - 85))\n                  .toString(16)\n                  .toUpperCase()\n                  .substring(0, 2)\n                  .padStart(2, \"0\")\n              }\n\n              s.backgroundColor = green + alpha\n            }\n          } else if (totalRespondents === 1) {\n            const red = \"#E523230D\"\n            s.backgroundColor = red\n          }\n        }\n      }\n\n      return { class: c, style: s }\n    },\n    getDayTimeslotClassStyle(date, i) {\n      const row = Math.floor(i / 7)\n      const col = i % 7\n\n      let classStyle\n      // Only compute class style for days that are included\n      if (this.monthDayIncluded.get(date.getTime())) {\n        classStyle = this.getTimeslotClassStyle(date, row, col)\n        if (this.state === this.states.EDIT_AVAILABILITY) {\n          classStyle.class += \"tw-cursor-pointer \"\n        }\n\n        const backgroundColor = classStyle.style.backgroundColor\n        if (\n          backgroundColor &&\n          lightOrDark(removeTransparencyFromHex(backgroundColor)) === \"dark\"\n        ) {\n          classStyle.class += \"tw-text-white \"\n        }\n      } else {\n        classStyle = {\n          class: \"tw-bg-off-white tw-text-gray \",\n          style: {},\n        }\n      }\n\n      // Change default red:\n      if (classStyle.style.backgroundColor === \"#E523230D\") {\n        classStyle.style.backgroundColor = \"#E523233B\"\n      }\n\n      // Change edit green\n      // if (classStyle.style.backgroundColor === \"#00994C88\") {\n      //   classStyle.style.backgroundColor = \"#29BC6880\"\n      // }\n\n      // Border style\n      if (\n        (this.respondents.length > 0 ||\n          this.state === this.states.EDIT_AVAILABILITY) &&\n        this.curTimeslot.row === row &&\n        this.curTimeslot.col === col &&\n        this.monthDayIncluded.get(date.getTime())\n      ) {\n        // Dashed border for currently selected timeslot\n        classStyle.class +=\n          \"tw-outline-2 tw-outline-dashed tw-outline-black tw-z-10 \"\n      } else {\n        // Normal border\n        if (col === 0) classStyle.class += \"tw-border-l tw-border-l-gray \"\n        classStyle.class += \"tw-border-r tw-border-r-gray \"\n        if (col !== 7 - 1) {\n          classStyle.style.borderRightStyle = \"dashed\"\n        }\n\n        if (row === 0) classStyle.class += \"tw-border-t tw-border-t-gray \"\n        classStyle.class += \"tw-border-b tw-border-b-gray \"\n        if (row !== Math.floor(this.monthDays.length / 7) - 1) {\n          classStyle.style.borderBottomStyle = \"dashed\"\n        }\n      }\n\n      return classStyle\n    },\n    getTimeslotVon(row, col) {\n      if (this.interactable) {\n        return {\n          click: () => {\n            if (this.timeslotSelected) {\n              // Get rid of persistent timeslot selection if clicked on the same timeslot that is currently being persisted\n              if (\n                row === this.curTimeslot.row &&\n                col === this.curTimeslot.col\n              ) {\n                this.timeslotSelected = false\n              }\n            } else if (\n              this.state !== this.states.EDIT_AVAILABILITY &&\n              (this.userHasResponded || this.guestAddedAvailability)\n            ) {\n              // Persist timeslot selection if user has already responded\n              this.timeslotSelected = true\n            }\n\n            this.showAvailability(row, col)\n          },\n          mousedown: () => {\n            // Highlight availability button\n            if (\n              this.state === this.defaultState &&\n              ((!this.isPhone &&\n                !(this.userHasResponded || this.guestAddedAvailability)) ||\n                this.respondents.length == 0)\n            )\n              this.highlightAvailabilityBtn()\n          },\n          mouseover: () => {\n            // Only show availability on hover if timeslot is not being persisted\n            if (!this.timeslotSelected) {\n              this.showAvailability(row, col)\n              if (!this.event.daysOnly) {\n                const date = this.getDateFromRowCol(row, col)\n                if (date) {\n                  date.setTime(date.getTime() - this.timezoneOffset * 60 * 1000)\n                  const startDate = dayjs(date).utc()\n                  const endDate = dayjs(date)\n                    .utc()\n                    .add(this.timeslotDuration, \"minutes\")\n                  const timeFormat =\n                    this.timeType === timeTypes.HOUR12 ? \"h:mm A\" : \"HH:mm\"\n                  let dateFormat\n                  if (this.isSpecificDates) {\n                    dateFormat = \"ddd, MMM D, YYYY\"\n                  } else {\n                    dateFormat = \"ddd\"\n                  }\n                  this.tooltipContent = `${startDate.format(\n                    dateFormat\n                  )} ${startDate.format(timeFormat)} to ${endDate.format(\n                    timeFormat\n                  )}`\n                }\n              }\n            }\n          },\n          mouseleave: () => {\n            this.tooltipContent = \"\"\n          },\n        }\n      }\n      return {}\n    },\n    resetCurTimeslot() {\n      // Only reset cur timeslot if it isn't being persisted\n      if (this.timeslotSelected) return\n\n      this.curTimeslotAvailability = {}\n      for (const respondent of this.respondents) {\n        this.curTimeslotAvailability[respondent._id] = true\n      }\n      this.curTimeslot = { row: -1, col: -1 }\n\n      // End drag if mouse left time grid\n      this.endDrag()\n    },\n    //#endregion\n\n    // -----------------------------------\n    //#region Editing\n    // -----------------------------------\n    startEditing() {\n      this.state = this.isSignUp\n        ? this.states.EDIT_SIGN_UP_BLOCKS\n        : this.states.EDIT_AVAILABILITY\n      this.availabilityType = availabilityTypes.AVAILABLE\n      this.availability = new Set()\n      this.ifNeeded = new Set()\n\n      if (this.authUser && !this.addingAvailabilityAsGuest) {\n        this.resetCurUserAvailability()\n      }\n      this.$nextTick(() => (this.unsavedChanges = false))\n      this.pageHasChanged = false\n    },\n    stopEditing() {\n      this.state = this.defaultState\n      this.stopAvailabilityAnim()\n\n      // Reset options\n      this.availabilityType = availabilityTypes.AVAILABLE\n      this.overlayAvailability = false\n    },\n    highlightAvailabilityBtn() {\n      this.$emit(\"highlightAvailabilityBtn\")\n    },\n    editGuestAvailability(id) {\n      if (this.authUser) {\n        this.$emit(\"addAvailabilityAsGuest\")\n      } else {\n        this.startEditing()\n      }\n\n      this.$nextTick(() => {\n        this.populateUserAvailability(id)\n        this.$emit(\"setCurGuestId\", id)\n      })\n    },\n    refreshEvent() {\n      this.$emit(\"refreshEvent\")\n    },\n    //#endregion\n\n    // -----------------------------------\n    //#region Schedule event\n    // -----------------------------------\n    scheduleEvent() {\n      this.state = this.states.SCHEDULE_EVENT\n      this.$posthog?.capture(\"schedule_event_button_clicked\")\n    },\n    cancelScheduleEvent() {\n      this.state = this.defaultState\n    },\n\n    /** Redirect user to Google Calendar to finish the creation of the event */\n    confirmScheduleEvent(googleCalendar = true) {\n      if (!this.curScheduledEvent) return\n      // if (!isPremiumUser(this.authUser)) {\n      //   this.showUpgradeDialog({\n      //     type: upgradeDialogTypes.SCHEDULE_EVENT,\n      //     data: {\n      //       scheduledEvent: this.curScheduledEvent,\n      //     },\n      //   })\n      //   return\n      // }\n\n      this.$posthog?.capture(\"schedule_event_confirmed\")\n      // Get start date, and end date from the area that the user has dragged out\n      const { col, row, numRows } = this.curScheduledEvent\n      let startDate = this.getDateFromRowCol(row, col)\n      let endDate = new Date(startDate)\n      endDate.setMinutes(\n        startDate.getMinutes() + this.timeslotDuration * numRows\n      )\n\n      if (this.isWeekly || this.isGroup) {\n        // Determine offset based on current day of the week.\n        // People expect the event to be scheduled in the future, not the past, which is why this check exists\n        let offset = 0\n        if (this.isGroup) {\n          offset = this.weekOffset\n        } else if (this.isWeekly) {\n          if (new Date().getDay() > startDate.getDay()) {\n            offset = 1\n          }\n        }\n\n        // Transform startDate and endDate to be the current week offset\n        startDate = dateToDowDate(this.event.dates, startDate, offset, true)\n        endDate = dateToDowDate(this.event.dates, endDate, offset, true)\n      }\n\n      // Format email string separated by commas\n      const emails = this.respondents.map((r) => {\n        // Return email if they are not a guest, otherwise return their name\n        if (r.email.length > 0) {\n          return r.email\n        } else {\n          // return `${r.firstName} (no email)`\n          return null\n        }\n      })\n      const emailsString = encodeURIComponent(emails.filter(Boolean).join(\",\"))\n\n      const eventId = this.event.shortId ?? this.event._id\n\n      let url = \"\"\n      if (googleCalendar) {\n        // Format start and end date to be in the format required by gcal (remove -, :, and .000)\n        const start = startDate.toISOString().replace(/([-:]|\\.000)/g, \"\")\n        const end = endDate.toISOString().replace(/([-:]|\\.000)/g, \"\")\n\n        // Construct Google Calendar event creation template url\n        url = `https://calendar.google.com/calendar/render?action=TEMPLATE&text=${encodeURIComponent(\n          this.event.name\n        )}&dates=${start}/${end}&details=${encodeURIComponent(\n          \"\\n\\nThis event was scheduled with schej: https://schej.it/e/\"\n        )}${eventId}&ctz=${this.curTimezone.value}&add=${emailsString}`\n      } else {\n        url = `https://outlook.live.com/calendar/0/deeplink/compose?subject=${encodeURIComponent(\n          this.event.name\n        )}&body=${encodeURIComponent(\n          \"\\n\\nThis event was scheduled with schej: https://schej.it/e/\" +\n            eventId\n        )}&startdt=${startDate.toISOString()}&enddt=${endDate.toISOString()}&location=${encodeURIComponent(\n          this.event.location || \"\"\n        )}&path=/calendar/action/compose&timezone=${this.curTimezone.value}`\n      }\n\n      // Navigate to url and reset state\n      window.open(url, \"_blank\")\n      this.state = this.defaultState\n    },\n    //#endregion\n\n    // -----------------------------------\n    //#region Drag Stuff\n    // -----------------------------------\n    normalizeXY(e) {\n      /* Normalize the touch event to be relative to element */\n      let pageX, pageY\n      if (\"touches\" in e) {\n        // is a touch event\n        ;({ pageX, pageY } = e.touches[0])\n      } else {\n        // is a mouse event\n        ;({ pageX, pageY } = e)\n      }\n      const { left, top } = e.currentTarget.getBoundingClientRect()\n      const x = pageX - left\n      const y = pageY - top - window.scrollY\n      return { x, y }\n    },\n    clampRow(row) {\n      if (this.event.daysOnly) {\n        row = clamp(row, 0, Math.floor(this.monthDays.length / 7) - 1)\n      } else {\n        row = clamp(row, 0, this.times.length - 1)\n      }\n      return row\n    },\n    clampCol(col) {\n      if (this.event.daysOnly) {\n        col = clamp(col, 0, 7 - 1)\n      } else {\n        col = clamp(col, 0, this.days.length - 1)\n      }\n      return col\n    },\n    /** Returns row, col for the timeslot we are currently hovering over given the x and y position */\n    getRowColFromXY(x, y) {\n      const { width, height } = this.timeslot\n      let col = Math.floor(x / width)\n      if (!this.event.daysOnly) {\n        col = this.columnOffsets.length\n        for (let i = 0; i < this.columnOffsets.length; ++i) {\n          if (x < this.columnOffsets[i]) {\n            col = i - 1\n            break\n          }\n        }\n      }\n      let row = Math.floor(y / height)\n\n      // Account for split gap\n      if (!this.event.daysOnly && row > this.splitTimes[0].length) {\n        const adjustedRow = Math.floor((y - this.SPLIT_GAP_HEIGHT) / height)\n        if (adjustedRow >= this.splitTimes[0].length) {\n          // Make sure we don't go to a lesser index\n          row = adjustedRow\n        }\n      }\n\n      row = this.clampRow(row)\n      col = this.clampCol(col)\n      return {\n        row,\n        col,\n      }\n    },\n    endDrag() {\n      if (!this.allowDrag) return\n\n      if (!this.dragStart || !this.dragCur) return\n\n      // Update availability set based on drag region\n      if (\n        this.state === this.states.EDIT_AVAILABILITY ||\n        this.state === this.states.SET_SPECIFIC_TIMES\n      ) {\n        // Determine colInc and rowInc\n        let colInc =\n          (this.dragCur.col - this.dragStart.col) /\n          Math.abs(this.dragCur.col - this.dragStart.col)\n        let rowInc =\n          (this.dragCur.row - this.dragStart.row) /\n          Math.abs(this.dragCur.row - this.dragStart.row)\n        if (isNaN(colInc)) colInc = 1\n        if (isNaN(rowInc)) rowInc = 1\n\n        // Determine iteration variables\n        let rowStart = this.dragStart.row\n        let rowMax = this.dragCur.row + rowInc\n        let colStart = this.dragStart.col\n        let colMax = this.dragCur.col + colInc\n\n        // Correct iteration variables if days only\n        if (this.event.daysOnly) {\n          colStart = 0\n          colMax = 7\n          colInc = 1\n        }\n\n        // Iterate all selected time slots and either add or remove them\n        for (let r = rowStart; r != rowMax; r += rowInc) {\n          for (let c = colStart; c != colMax; c += colInc) {\n            const date = this.getDateFromRowCol(r, c)\n            if (!date) continue\n\n            if (this.event.daysOnly) {\n              // Don't add to availability set if month day is not included\n              const isMonthDayIncluded =\n                this.monthDayIncluded.get(date.getTime()) &&\n                this.inDragRange(r, c)\n              if (!isMonthDayIncluded) continue\n            }\n\n            if (this.dragType === this.DRAG_TYPES.ADD) {\n              if (this.state === this.states.SET_SPECIFIC_TIMES) {\n                this.tempTimes.add(date.getTime())\n              } else {\n                // Add / remove time from availability set\n                if (this.availabilityType === availabilityTypes.AVAILABLE) {\n                  this.availability.add(date.getTime())\n                  this.ifNeeded.delete(date.getTime())\n                } else if (\n                  this.availabilityType === availabilityTypes.IF_NEEDED\n                ) {\n                  this.ifNeeded.add(date.getTime())\n                  this.availability.delete(date.getTime())\n                }\n              }\n            } else if (this.dragType === this.DRAG_TYPES.REMOVE) {\n              if (this.state === this.states.SET_SPECIFIC_TIMES) {\n                this.tempTimes.delete(date.getTime())\n              } else {\n                // Add / remove time from availability set\n                this.availability.delete(date.getTime())\n                this.ifNeeded.delete(date.getTime())\n              }\n            }\n\n            // Edit manualAvailability set if event is a GROUP\n            if (this.event.type === eventTypes.GROUP) {\n              const discreteDate = dateToDowDate(\n                this.event.dates,\n                date,\n                this.weekOffset,\n                true\n              )\n              const startDateOfDay = dateToDowDate(\n                this.event.dates,\n                this.days[c].dateObject,\n                this.weekOffset,\n                true\n              )\n\n              // If date not touched, then add all of the existing calendar availabilities and mark it as touched\n              if (!(startDateOfDay.getTime() in this.manualAvailability)) {\n                // Create new set\n                this.manualAvailability[startDateOfDay.getTime()] = new Set()\n\n                // Add the existing calendar availabilities\n                const existingAvailability = this.getAvailabilityForColumn(c)\n                for (const a of existingAvailability) {\n                  const convertedDate = dateToDowDate(\n                    this.event.dates,\n                    new Date(a),\n                    this.weekOffset,\n                    true\n                  )\n                  this.manualAvailability[startDateOfDay.getTime()].add(\n                    convertedDate.getTime()\n                  )\n                }\n              }\n\n              // Add / remove time from manual availability set\n              if (this.dragType === this.DRAG_TYPES.ADD) {\n                this.manualAvailability[startDateOfDay.getTime()].add(\n                  discreteDate.getTime()\n                )\n              } else if (this.dragType === this.DRAG_TYPES.REMOVE) {\n                this.manualAvailability[startDateOfDay.getTime()].delete(\n                  discreteDate.getTime()\n                )\n              }\n            }\n          }\n        }\n        this.availability = new Set(this.availability)\n      } else if (this.state === this.states.SCHEDULE_EVENT) {\n        // Update scheduled event\n        const col = this.dragStart.col\n        const row = this.dragStart.row\n        const numRows = this.dragCur.row - this.dragStart.row + 1\n\n        if (numRows > 0) {\n          this.curScheduledEvent = { col, row, numRows }\n        } else {\n          this.curScheduledEvent = null\n        }\n      } else if (this.state === this.states.EDIT_SIGN_UP_BLOCKS) {\n        // Update sign up blocks\n        const dayIndex = this.dragStart.col\n        const hoursOffset = this.dragStart.row / 4\n        const hoursLength = (this.dragCur.row - this.dragStart.row + 1) / 4\n        if (hoursLength > 0) {\n          this.signUpBlocksToAddByDay[dayIndex].push(\n            this.createSignUpBlock(dayIndex, hoursOffset, hoursLength)\n          )\n        }\n      }\n\n      // Set dragging defaults\n      this.dragging = false\n      this.dragStart = null\n      this.dragCur = null\n    },\n    inDragRange(row, col) {\n      /* Returns whether the given row and col is within the drag range */\n      if (this.dragging) {\n        if (this.event.daysOnly) {\n          if (\n            isBetween(row, this.dragStart.row, this.dragCur.row) ||\n            isBetween(row, this.dragCur.row, this.dragStart.row)\n          ) {\n            if (this.dragCur.row < this.dragStart.row) {\n              return (\n                (this.dragCur.row === row && this.dragCur.col <= col) ||\n                (this.dragStart.row === row && this.dragStart.col >= col) ||\n                (this.dragStart.row !== row && this.dragCur.row !== row)\n              )\n            } else if (this.dragCur.row > this.dragStart.row) {\n              return (\n                (this.dragCur.row === row && this.dragCur.col >= col) ||\n                (this.dragStart.row === row && this.dragStart.col <= col) ||\n                (this.dragStart.row !== row && this.dragCur.row !== row)\n              )\n            } else {\n              // cur row == start row\n              return (\n                isBetween(col, this.dragStart.col, this.dragCur.col) ||\n                isBetween(col, this.dragCur.col, this.dragStart.col)\n              )\n            }\n          }\n          return false\n        }\n\n        return (\n          (isBetween(row, this.dragStart.row, this.dragCur.row) ||\n            isBetween(row, this.dragCur.row, this.dragStart.row)) &&\n          (isBetween(col, this.dragStart.col, this.dragCur.col) ||\n            isBetween(col, this.dragCur.col, this.dragStart.col))\n        )\n      }\n      return false\n    },\n    moveDrag(e) {\n      if (!this.allowDrag) return\n      if (e.touches?.length > 1) return // If dragging with more than one finger\n      if (!this.dragStart) return\n\n      e.preventDefault()\n      let { row, col } = this.getRowColFromXY(\n        ...Object.values(this.normalizeXY(e))\n      )\n\n      if (\n        this.maxSignUpBlockRowSize &&\n        row >= this.dragStart.row + this.maxSignUpBlockRowSize\n      ) {\n        row = this.dragStart.row + this.maxSignUpBlockRowSize - 1\n      } else if (this.state === this.states.SCHEDULE_EVENT) {\n        const isFirstSplit = this.dragStart.row < this.splitTimes[0].length\n        if (isFirstSplit) {\n          row = Math.min(row, this.splitTimes[0].length - 1)\n        }\n      }\n\n      this.dragCur = { row, col }\n    },\n    startDrag(e) {\n      const { row, col } = this.getRowColFromXY(\n        ...Object.values(this.normalizeXY(e))\n      )\n\n      // If sign up form, check if trying to drag in a block\n      if (this.isSignUp) {\n        for (const block of this.signUpBlocksByDay[col].concat(\n          this.signUpBlocksToAddByDay[col]\n        )) {\n          if (\n            isBetween(\n              row,\n              block.hoursOffset * 4,\n              (block.hoursOffset + block.hoursLength) * 4 - 1\n            )\n          ) {\n            this.$refs.signUpBlocksList.scrollToSignUpBlock(block._id)\n            return\n          }\n        }\n      }\n\n      if (!this.allowDrag) return\n      if (e.touches?.length > 1) return // If dragging with more than one finger\n\n      const date = this.getDateFromRowCol(row, col)\n      if (!date) return\n\n      // Dont start dragging if day not included in daysonly event\n      if (this.event.daysOnly && !this.monthDayIncluded.get(date.getTime())) {\n        return\n      }\n\n      this.dragging = true\n      this.dragStart = { row, col }\n      this.dragCur = { row, col }\n\n      // Prevent scroll\n      e.preventDefault()\n\n      // Set drag type\n      if (this.isSignUp) {\n        this.dragType = this.DRAG_TYPES.ADD\n      } else if (\n        (this.state === this.states.SET_SPECIFIC_TIMES &&\n          this.tempTimes.has(date.getTime())) ||\n        (this.availabilityType === availabilityTypes.AVAILABLE &&\n          this.availability.has(date.getTime())) ||\n        (this.availabilityType === availabilityTypes.IF_NEEDED &&\n          this.ifNeeded.has(date.getTime()))\n      ) {\n        this.dragType = this.DRAG_TYPES.REMOVE\n      } else {\n        this.dragType = this.DRAG_TYPES.ADD\n      }\n    },\n    //#endregion\n\n    // -----------------------------------\n    //#region Options\n    // -----------------------------------\n    getLocalTimezone() {\n      const split = new Date(this.event.dates[0])\n        .toLocaleTimeString(\"en-us\", { timeZoneName: \"short\" })\n        .split(\" \")\n      const localTimezone = split[split.length - 1]\n\n      return localTimezone\n    },\n    onShowBestTimesChange() {\n      localStorage[\"showBestTimes\"] = this.showBestTimes\n      if (\n        this.state == this.states.BEST_TIMES ||\n        this.state == this.states.HEATMAP\n      )\n        this.state = this.defaultState\n    },\n    toggleShowEditOptions() {\n      this.showEditOptions = !this.showEditOptions\n      localStorage[\"showEditOptions\"] = this.showEditOptions\n    },\n    toggleShowEventOptions() {\n      this.showEventOptions = !this.showEventOptions\n      localStorage[\"showEventOptions\"] = this.showEventOptions\n    },\n    updateOverlayAvailability(val) {\n      this.overlayAvailability = !!val\n      this.$posthog?.capture(\"overlay_availability_toggled\", {\n        enabled: !!val,\n      })\n    },\n    //#endregion\n\n    // -----------------------------------\n    //#region Scroll\n    // -----------------------------------\n    onCalendarScroll(e) {\n      this.calendarMaxScroll = e.target.scrollWidth - e.target.offsetWidth\n      this.calendarScrollLeft = e.target.scrollLeft\n    },\n    onScroll(e) {\n      this.checkElementsVisible()\n    },\n    /** Checks whether certain elements are visible and sets variables accoringly */\n    checkElementsVisible() {\n      const optionsSectionEl = this.$refs.optionsSection\n      if (optionsSectionEl) {\n        this.optionsVisible = isElementInViewport(optionsSectionEl, {\n          bottomOffset: -64,\n        })\n      }\n\n      const respondentsListEl = this.$refs.respondentsList?.$el\n      if (respondentsListEl) {\n        this.scrolledToRespondents = isElementInViewport(respondentsListEl, {\n          bottomOffset: -64,\n        })\n      }\n    },\n    //#endregion\n\n    // -----------------------------------\n    //#region Pagination\n    // -----------------------------------\n    nextPage(e) {\n      e.stopImmediatePropagation()\n      if (this.event.type === eventTypes.GROUP) {\n        // Go to next page if there are still more days left to see\n        // Otherwise, update week offset\n        if ((this.page + 1) * this.maxDaysPerPage < this.allDays.length) {\n          this.page++\n        } else {\n          this.page = 0\n          this.$emit(\"update:weekOffset\", this.weekOffset + 1)\n        }\n      } else {\n        this.page++\n      }\n      this.pageHasChanged = true\n    },\n    prevPage(e) {\n      e.stopImmediatePropagation()\n      if (this.event.type === eventTypes.GROUP) {\n        // Go to prev page if there is a prev page\n        // Otherwise, update week offset\n        if (this.page > 0) {\n          this.page--\n        } else {\n          this.page = Math.ceil(this.allDays.length / this.maxDaysPerPage) - 1\n          this.$emit(\"update:weekOffset\", this.weekOffset - 1)\n        }\n      } else {\n        this.page--\n      }\n      this.pageHasChanged = true\n    },\n    //#endregion\n\n    // -----------------------------------\n    //#region Resize\n    // -----------------------------------\n    onResize() {\n      this.setTimeslotSize()\n    },\n    //#endregion\n\n    // -----------------------------------\n    //#region hint\n    // -----------------------------------\n    closeHint() {\n      this.hintState = false\n      localStorage[this.hintStateLocalStorageKey] = true\n    },\n    //#endregion\n\n    // -----------------------------------\n    //#region Group\n    // -----------------------------------\n\n    /** Toggles calendar account - in groups to enable/disable calendars */\n    toggleCalendarAccount(payload) {\n      this.sharedCalendarAccounts[\n        getCalendarAccountKey(payload.email, payload.calendarType)\n      ].enabled = payload.enabled\n      this.sharedCalendarAccounts = JSON.parse(\n        JSON.stringify(this.sharedCalendarAccounts)\n      )\n    },\n\n    /** Toggles sub calendar account - in groups to enable/disable sub calendars */\n    toggleSubCalendarAccount(payload) {\n      this.sharedCalendarAccounts[\n        getCalendarAccountKey(payload.email, payload.calendarType)\n      ].subCalendars[payload.subCalendarId].enabled = payload.enabled\n      this.sharedCalendarAccounts = JSON.parse(\n        JSON.stringify(this.sharedCalendarAccounts)\n      )\n    },\n\n    /** Sets the initial sharedCalendarAccounts object */\n    initSharedCalendarAccounts() {\n      if (!this.authUser) return\n\n      // Init shared calendar accounts to current calendar accounts\n      this.sharedCalendarAccounts = JSON.parse(\n        JSON.stringify(this.authUser.calendarAccounts)\n      )\n\n      // Disable all calendars\n      for (const id in this.sharedCalendarAccounts) {\n        this.sharedCalendarAccounts[id].enabled = false\n        if (this.sharedCalendarAccounts[id].subCalendars) {\n          for (const subCalendarId in this.sharedCalendarAccounts[id]\n            .subCalendars) {\n            this.sharedCalendarAccounts[id].subCalendars[\n              subCalendarId\n            ].enabled = false\n          }\n        }\n      }\n\n      // Enable calendars based on responses\n      if (this.authUser._id in this.event.responses) {\n        const enabledCalendars =\n          this.event.responses[this.authUser._id].enabledCalendars\n\n        for (const id in enabledCalendars) {\n          this.sharedCalendarAccounts[id].enabled = true\n\n          enabledCalendars[id].forEach((subCalendarId) => {\n            this.sharedCalendarAccounts[id].subCalendars[\n              subCalendarId\n            ].enabled = true\n          })\n        }\n      }\n    },\n\n    /** Based on the date, determine whether it has been touched */\n    isTouched(date, availability = [...this.availability]) {\n      const start = new Date(date)\n      const end = new Date(date)\n      end.setHours(end.getHours() + this.event.duration)\n\n      for (const a of availability) {\n        const availableTime = new Date(a).getTime()\n        if (\n          start.getTime() <= availableTime &&\n          availableTime <= end.getTime()\n        ) {\n          return true\n        }\n      }\n\n      return false\n    },\n\n    /** Returns a subset of availability for the current date */\n    getAvailabilityForColumn(column, availability = [...this.availability]) {\n      const subset = new Set()\n      const availabilitySet = new Set(availability)\n      for (\n        let r = 0;\n        r < this.splitTimes[0].length + this.splitTimes[1].length;\n        ++r\n      ) {\n        const date = this.getDateFromRowCol(r, column)\n        if (!date) continue\n\n        if (availabilitySet.has(date.getTime())) {\n          subset.add(date.getTime())\n        }\n      }\n\n      return subset\n    },\n\n    /** Returns a copy of the manual availability, converted to dow dates */\n    getManualAvailabilityDow(manualAvailability = this.manualAvailability) {\n      if (!manualAvailability) return null\n\n      const manualAvailabilityDow = {}\n      for (const time in manualAvailability) {\n        const dowTime = dateToDowDate(\n          this.event.dates,\n          new Date(parseInt(time)),\n          this.weekOffset\n        ).getTime()\n        manualAvailabilityDow[dowTime] = [...manualAvailability[time]].map(\n          (a) => dateToDowDate(this.event.dates, new Date(a), this.weekOffset)\n        )\n      }\n      return manualAvailabilityDow\n    },\n    //#endregion\n\n    // -----------------------------------\n    //#region Sign up form\n    // -----------------------------------\n\n    /** Creates a sign up block for the current day and hour offset */\n    createSignUpBlock(dayIndex, hoursOffset, hoursLength) {\n      const timeBlock = getTimeBlock(\n        this.days[dayIndex].dateObject,\n        hoursOffset,\n        hoursLength\n      )\n\n      return {\n        _id: ObjectID().toString(),\n        capacity: 1,\n        name: this.newSignUpBlockName,\n        ...timeBlock,\n        hoursOffset,\n        hoursLength,\n      }\n    },\n\n    /** Updates the sign up block with the same id */\n    editSignUpBlock(signUpBlock) {\n      this.signUpBlocksByDay.forEach((blocksInDay, dayIndex) => {\n        blocksInDay.forEach((block, blockIndex) => {\n          if (signUpBlock._id === block._id) {\n            this.signUpBlocksByDay[dayIndex][blockIndex] = signUpBlock\n            this.signUpBlocksByDay = [...this.signUpBlocksByDay]\n            return\n          }\n        })\n      })\n\n      this.signUpBlocksToAddByDay.forEach((blocksInDay, dayIndex) => {\n        blocksInDay.forEach((block, blockIndex) => {\n          if (signUpBlock._id === block._id) {\n            this.signUpBlocksToAddByDay[dayIndex][blockIndex] = signUpBlock\n            this.signUpBlocksToAddByDay = [...this.signUpBlocksToAddByDay]\n            return\n          }\n        })\n      })\n    },\n\n    /** Deletes the sign up block with the id */\n    deleteSignUpBlock(signUpBlockId) {\n      this.signUpBlocksByDay.forEach((blocksInDay, dayIndex) => {\n        blocksInDay.forEach((block, blockIndex) => {\n          if (signUpBlockId === block._id) {\n            this.signUpBlocksByDay[dayIndex].splice(blockIndex, 1)\n            return\n          }\n        })\n      })\n\n      this.signUpBlocksToAddByDay.forEach((blocksInDay, dayIndex) => {\n        blocksInDay.forEach((block, blockIndex) => {\n          if (signUpBlockId === block._id) {\n            this.signUpBlocksToAddByDay[dayIndex].splice(blockIndex, 1)\n            return\n          }\n        })\n      })\n    },\n\n    /** Reloads all the data for the sign up form */\n    resetSignUpForm() {\n      /** Split sign up blocks by day */\n      this.signUpBlocksByDay = splitTimeBlocksByDay(\n        this.event,\n        this.event.signUpBlocks ?? []\n      )\n\n      this.resetSignUpBlocksToAddByDay()\n\n      /** Populate sign up block responses */\n      for (const userId in this.event.signUpResponses) {\n        const signUpResponse = this.event.signUpResponses[userId]\n        for (const signUpBlockId of signUpResponse.signUpBlockIds) {\n          const signUpBlock = this.signUpBlocksByDay\n            .flat()\n            .find((signUpBlock) => signUpBlock._id === signUpBlockId)\n\n          if (!signUpBlock.responses) signUpBlock.responses = []\n          signUpBlock.responses.push(signUpResponse)\n        }\n      }\n    },\n\n    /** Initialize sign up blocks to be added array */\n    resetSignUpBlocksToAddByDay() {\n      this.signUpBlocksToAddByDay = []\n      for (const day of this.signUpBlocksByDay) {\n        this.signUpBlocksToAddByDay.push([])\n      }\n    },\n\n    /** Emits sign up for block to parent element */\n    handleSignUpBlockClick(block) {\n      if (!this.alreadyRespondedToSignUpForm && !this.isOwner)\n        this.$emit(\"signUpForBlock\", block)\n    },\n\n    //#endregion\n\n    // -----------------------------------\n    //#region Specific times for specific days\n    // -----------------------------------\n\n    /** Saves the temporary times to the event */\n    saveTempTimes() {\n      // Set event times\n      this.event.times = [...this.tempTimes]\n        .map((t) => new Date(t))\n        .sort((a, b) => a.getTime() - b.getTime())\n\n      const { minHours, maxHours } = this.getMinMaxHoursFromTimes(\n        this.event.times\n      )\n\n      // Set event dates to start at the new times\n      for (let i = 0; i < this.event.dates.length; ++i) {\n        const date = new Date(this.event.dates[i])\n        date.setTime(date.getTime() - this.timezoneOffset * 60 * 1000)\n        date.setUTCHours(minHours, 0, 0, 0)\n        date.setTime(date.getTime() + this.timezoneOffset * 60 * 1000)\n        this.event.dates[i] = date.toISOString()\n      }\n\n      // Set event duration to the difference between the max and min hours\n      this.event.duration = maxHours - minHours + 1\n\n      // Update event\n      put(`/events/${this.event._id}`, this.event)\n        .then(() => {\n          this.state = this.defaultState\n        })\n        .catch((err) => {\n          this.showError(err)\n        })\n    },\n\n    /** Returns the min and max hours from the times */\n    getMinMaxHoursFromTimes(times) {\n      let minHours = 24\n      let maxHours = 0\n      for (const time of times) {\n        const timeDate = new Date(time)\n        const date = new Date(\n          timeDate.getTime() - this.timezoneOffset * 60 * 1000\n        )\n        const localHours = date.getUTCHours()\n        if (localHours < minHours) {\n          minHours = localHours\n        } else if (localHours > maxHours) {\n          maxHours = localHours\n        }\n      }\n      return { minHours, maxHours }\n    },\n\n    //#endregion\n\n    /** Recalculate availability the calendar based on calendar events */\n    reanimateAvailability() {\n      if (\n        this.state === this.states.EDIT_AVAILABILITY &&\n        this.authUser &&\n        !(this.authUser?._id in this.event.responses) && // User hasn't responded yet\n        !this.loadingCalendarEvents &&\n        (!this.unsavedChanges || this.availabilityAnimEnabled)\n      ) {\n        for (const timeout of this.availabilityAnimTimeouts) {\n          clearTimeout(timeout)\n        }\n        this.setAvailabilityAutomatically()\n      }\n    },\n  },\n  watch: {\n    availability() {\n      if (this.state === this.states.EDIT_AVAILABILITY) {\n        this.unsavedChanges = true\n      }\n    },\n    event: {\n      immediate: true,\n      handler() {\n        this.initSharedCalendarAccounts()\n        this.fetchResponses()\n      },\n    },\n    state(nextState, prevState) {\n      this.$nextTick(() => this.checkElementsVisible())\n\n      // Reset scheduled event when exiting schedule event state\n      if (prevState === this.states.SCHEDULE_EVENT) {\n        this.curScheduledEvent = null\n      } else if (prevState === this.states.EDIT_AVAILABILITY) {\n        this.unsavedChanges = false\n      }\n\n      if (nextState === this.states.SET_SPECIFIC_TIMES) {\n        this.$nextTick(() => {\n          const time9 = document.getElementById(\"time-9\")\n          if (time9) {\n            const yOffset = -150\n            const y =\n              time9.getBoundingClientRect().top + window.scrollY + yOffset\n            window.scrollTo({ top: y, behavior: \"smooth\" })\n          }\n        })\n      }\n    },\n    respondents: {\n      immediate: true,\n      handler() {\n        this.curTimeslotAvailability = {}\n        for (const respondent of this.respondents) {\n          this.curTimeslotAvailability[respondent._id] = true\n        }\n      },\n    },\n    calendarEventsByDay(val, oldVal) {\n      if (JSON.stringify(val) !== JSON.stringify(oldVal)) {\n        this.reanimateAvailability()\n      }\n    },\n    page() {\n      this.$nextTick(() => {\n        this.setTimeslotSize()\n      })\n    },\n    allDays() {\n      this.$nextTick(() => {\n        this.setTimeslotSize()\n      })\n    },\n    showStickyRespondents: {\n      immediate: true,\n      handler(cur) {\n        clearTimeout(this.delayedShowStickyRespondentsTimeout)\n        this.delayedShowStickyRespondentsTimeout = setTimeout(() => {\n          this.delayedShowStickyRespondents = cur\n        }, 100)\n      },\n    },\n    maxDaysPerPage() {\n      // Set page to 0 if user switches from portrait to landscape orientation and we're on an invalid page number,\n      // i.e. we're on a page that displays 0 days\n      if (this.page * this.maxDaysPerPage >= this.allDays.length) {\n        this.page = 0\n      }\n    },\n    mobileNumDays() {\n      // Save mobile num days in localstorage\n      localStorage[\"mobileNumDays\"] = this.mobileNumDays\n\n      // Set timeslot size because it has changed\n      this.$nextTick(() => {\n        this.setTimeslotSize()\n      })\n    },\n    weekOffset() {\n      if (this.event.type === eventTypes.GROUP) {\n        this.fetchResponses()\n      }\n    },\n    hideIfNeeded() {\n      this.getResponsesFormatted()\n    },\n    parsedResponses() {\n      // Theoretically, parsed responses should only be changing for groups\n      this.getResponsesFormatted()\n\n      // Repopulate user availability when editing availability (this happens when switching weeks in a group)\n      if (\n        this.event.type === eventTypes.GROUP &&\n        this.state === this.states.EDIT_AVAILABILITY &&\n        this.authUser\n      ) {\n        this.availability = new Set()\n        this.populateUserAvailability(this.authUser._id)\n      }\n    },\n    showBestTimes() {\n      this.onShowBestTimesChange()\n    },\n    startCalendarOnMonday() {\n      localStorage[\"startCalendarOnMonday\"] = this.startCalendarOnMonday\n    },\n    bufferTime(cur, prev) {\n      if (cur.enabled !== prev.enabled || cur.enabled) {\n        this.reanimateAvailability()\n      }\n    },\n    workingHours(cur, prev) {\n      if (cur.enabled !== prev.enabled || cur.enabled) {\n        this.reanimateAvailability()\n      }\n    },\n    timeType() {\n      localStorage[\"timeType\"] = this.timeType\n    },\n    fromEditEvent() {\n      if (this.fromEditEvent && this.isSpecificTimes) {\n        this.tempTimes = new Set(\n          this.event.times.map((t) => new Date(t).getTime())\n        )\n        this.state = this.states.SET_SPECIFIC_TIMES\n      }\n    },\n  },\n  created() {\n    this.resetCurUserAvailability()\n\n    addEventListener(\"click\", this.deselectRespondents)\n  },\n  mounted() {\n    // Get query parameters from URL\n    const urlParams = new URLSearchParams(window.location.search)\n\n    // Set initial state\n    if (\n      this.event.hasSpecificTimes &&\n      (this.fromEditEvent || !this.event.times || this.event.times.length === 0)\n    ) {\n      this.state = this.states.SET_SPECIFIC_TIMES\n    } else if (urlParams.get(\"scheduled_event\")) {\n      const scheduledEvent = JSON.parse(urlParams.get(\"scheduled_event\"))\n      this.curScheduledEvent = scheduledEvent\n      this.state = this.states.SCHEDULE_EVENT\n\n      // Remove the scheduled_event parameter from URL to avoid reloading the same state\n      const newUrl = new URL(window.location.href)\n      newUrl.searchParams.delete(\"scheduled_event\")\n      window.history.replaceState({}, document.title, newUrl.toString())\n    } else if (this.showBestTimes) {\n      this.state = \"best_times\"\n    } else {\n      this.state = \"heatmap\"\n    }\n\n    // Set calendar options defaults\n    if (this.authUser) {\n      this.bufferTime =\n        this.authUser?.calendarOptions?.bufferTime ??\n        calendarOptionsDefaults.bufferTime\n      this.workingHours =\n        this.authUser?.calendarOptions?.workingHours ??\n        calendarOptionsDefaults.workingHours\n      if (this.isGroup) {\n        if (this.event.responses[this.authUser._id]?.calendarOptions) {\n          // Update calendar options if user has changed them for this specific group\n          const { bufferTime, workingHours } =\n            this.event.responses[this.authUser._id]?.calendarOptions\n          if (bufferTime) this.bufferTime = bufferTime\n          if (workingHours) this.workingHours = workingHours\n        } else {\n          this.bufferTime = calendarOptionsDefaults.bufferTime\n          this.workingHours = calendarOptionsDefaults.workingHours\n        }\n      }\n    }\n\n    // Set initial calendar max scroll\n    // this.calendarMaxScroll =\n    //   this.$refs.calendar.scrollWidth - this.$refs.calendar.offsetWidth\n\n    // Get timeslot size\n    this.setTimeslotSize()\n    addEventListener(\"resize\", this.onResize)\n    addEventListener(\"scroll\", this.onScroll)\n    if (!this.calendarOnly) {\n      const timesEl = document.getElementById(\"drag-section\")\n      if (isTouchEnabled()) {\n        timesEl.addEventListener(\"touchstart\", this.startDrag)\n        timesEl.addEventListener(\"touchmove\", this.moveDrag)\n        timesEl.addEventListener(\"touchend\", this.endDrag)\n        timesEl.addEventListener(\"touchcancel\", this.endDrag)\n      }\n      timesEl.addEventListener(\"mousedown\", this.startDrag)\n      timesEl.addEventListener(\"mousemove\", this.moveDrag)\n      timesEl.addEventListener(\"mouseup\", this.endDrag)\n    }\n\n    // Parse sign up blocks and responses\n    this.resetSignUpForm()\n  },\n  beforeDestroy() {\n    removeEventListener(\"click\", this.deselectRespondents)\n    removeEventListener(\"resize\", this.onResize)\n    removeEventListener(\"scroll\", this.onScroll)\n  },\n  components: {\n    AlertText,\n    AvailabilityTypeToggle,\n    ExpandableSection,\n    BufferTimeSwitch,\n    UserAvatarContent,\n    ZigZag,\n    ConfirmDetailsDialog,\n    ToolRow,\n    CalendarAccounts,\n    RespondentsList,\n    Advertisement,\n    GCalWeekSelector,\n    WorkingHoursToggle,\n    SignUpBlock,\n    SignUpCalendarBlock,\n    SignUpBlocksList,\n    CalendarEventBlock, // Added component registration\n    SpecificTimesInstructions, // Added component registration\n    Tooltip,\n  },\n}\n</script>\n"],"mappings":";;;;AAm7BA,SACAA,iBAAA,EACAC,WAAA,EACAC,kBAAA,EACAC,IAAA,EACAC,GAAA,EACAC,SAAA,EACAC,KAAA,EACAC,OAAA,EACAC,kBAAA,EACAC,oBAAA,EACAC,YAAA,EACAC,aAAA,EACAC,OAAA,EACAC,GAAA,EACAC,gBAAA,EACAC,aAAA,EACAC,+BAAA,EACAC,cAAA,EACAC,mBAAA,EACAC,WAAA,EACAC,yBAAA,EACAC,cAAA,EACAC,qBAAA,EACAC,gBAAA,EACAC,mBAAA,EACAC,mBAAA,EACAC,aAAA,QACA;AACA,SACAC,iBAAA,EACAC,uBAAA,EACAC,UAAA,EACAC,SAAA,EACAC,iBAAA,EACAC,kBAAA,QACA;AACA,SAAAC,YAAA,EAAAC,UAAA,EAAAC,QAAA;AACA,OAAAC,iBAAA;AACA,OAAAC,gBAAA;AACA,OAAAC,aAAA;AACA,OAAAC,WAAA;AACA,OAAAC,mBAAA;AACA,OAAAC,gBAAA;AACA,OAAAC,MAAA;AACA,OAAAC,oBAAA;AACA,OAAAC,OAAA;AACA,OAAAC,eAAA;AACA,OAAAC,gBAAA;AACA,OAAAC,iBAAA;AACA,OAAAC,kBAAA;AACA,OAAAC,SAAA;AACA,OAAAC,OAAA;AAEA,OAAAC,KAAA;AACA;AACAA,KAAA,CAAAC,MAAA;AACA,OAAAC,QAAA;AACA,OAAAC,SAAA;AACA,OAAAC,cAAA;AACA,OAAAC,sBAAA;AACA,OAAAC,gBAAA;AACA,OAAAC,kBAAA;AACA,OAAAC,yBAAA;AACAR,KAAA,CAAAS,MAAA,CAAAN,SAAA;AACAH,KAAA,CAAAS,MAAA,CAAAL,cAAA;AAEA;EACAM,IAAA;EACAC,KAAA;IACAC,KAAA;MAAAC,IAAA,EAAAC,MAAA;MAAAC,QAAA;IAAA;IACAC,aAAA;MAAAH,IAAA,EAAAI,OAAA;MAAAC,OAAA;IAAA;IAEAC,qBAAA;MAAAN,IAAA,EAAAI,OAAA;MAAAC,OAAA;IAAA;IAAA;IACAE,iBAAA;MAAAP,IAAA,EAAAC,MAAA;MAAAI,OAAA,EAAAA,CAAA;IAAA;IAAA;IACAG,yBAAA;MAAAR,IAAA,EAAAS,KAAA;MAAAP,QAAA;IAAA;IAAA;IACAQ,yBAAA;MAAAV,IAAA,EAAAI,OAAA;MAAAC,OAAA;IAAA;IAAA;;IAEAM,UAAA;MAAAX,IAAA,EAAAY,MAAA;MAAAP,OAAA;IAAA;IAAA;;IAEAQ,wBAAA;MAAAb,IAAA,EAAAI,OAAA;MAAAC,OAAA;IAAA;IAAA;IACAS,YAAA;MAAAd,IAAA,EAAAI,OAAA;MAAAC,OAAA;IAAA;IAAA;IACAU,YAAA;MAAAf,IAAA,EAAAI,OAAA;MAAAC,OAAA;IAAA;IAAA;IACAW,YAAA;MAAAhB,IAAA,EAAAI,OAAA;MAAAC,OAAA;IAAA;IAAA;IACAY,YAAA;MAAAjB,IAAA,EAAAI,OAAA;MAAAC,OAAA;IAAA;IAAA;IACAa,qBAAA;MAAAlB,IAAA,EAAAI,OAAA;MAAAC,OAAA;IAAA;IAAA;IACAc,YAAA;MAAAnB,IAAA,EAAAI,OAAA;MAAAC,OAAA;IAAA;IAAA;;IAEAe,UAAA;MAAApB,IAAA,EAAAqB,MAAA;MAAAhB,OAAA;IAAA;IAAA;IACAiB,yBAAA;MAAAtB,IAAA,EAAAI,OAAA;MAAAC,OAAA;IAAA;IAAA;;IAEAkB,eAAA;MAAAvB,IAAA,EAAAC,MAAA;MAAAI,OAAA,EAAAA,CAAA;IAAA;IAEA;IACAmB,sBAAA;MAAAxB,IAAA,EAAAC,MAAA;MAAAI,OAAA,EAAAA,CAAA;IAAA;EACA;EACAoB,KAAA;IACA;MACAC,MAAA;QACAC,OAAA;QAAA;QACAC,mBAAA;QAAA;QACAC,mBAAA;QAAA;QACAC,UAAA;QAAA;QACAC,iBAAA;QAAA;QACAC,mBAAA;QAAA;QACAC,cAAA;QAAA;QACAC,kBAAA;MACA;MACAC,KAAA;MAEAC,YAAA,MAAAC,GAAA;MAAA;MACAC,QAAA,MAAAD,GAAA;MAAA;MACAE,SAAA,MAAAF,GAAA;MAAA;MACAG,wBAAA;MAAA;MACAC,uBAAA;MAAA;MACAC,WAAA;MAAA;MACAC,cAAA;MAAA;MACAC,WAAA;QAAAC,GAAA;QAAAC,GAAA;MAAA;MAAA;MACAC,gBAAA;MAAA;MACAC,uBAAA;MAAA;MACAC,aAAA;MAAA;MACAC,cAAA;MAAA;MACAC,sBAAA;MAAA;MACAC,gBAAA;MAAA;MACAC,gBAAA;QAAAC,OAAA;QAAAC,WAAA,MAAAC,IAAA,GAAAC,OAAA;MAAA;MAAA;MACAC,kBAAA,MAAAC,GAAA;MAAA;MACAC,cAAA;MAAA;;MAEA;MACAC,iBAAA;MAAA;MACAC,sBAAA;MAAA;;MAEA;MACAC,eAAA,EACAC,YAAA,uBAAAC,SAAA,GACA,QACAD,YAAA;MACAE,gBAAA,EAAAvG,iBAAA,CAAAwG,SAAA;MAAA;MACAC,mBAAA;MAAA;MACAC,UAAA,EAAAzG,uBAAA,CAAAyG,UAAA;MAAA;MACAC,YAAA,EAAA1G,uBAAA,CAAA0G,YAAA;MAAA;;MAEA;MACAC,gBAAA,EACAP,YAAA,wBAAAC,SAAA,GACA,QACAD,YAAA;MACAQ,aAAA,EACAR,YAAA,qBAAAC,SAAA,GACA,QACAD,YAAA;MACAS,YAAA;MAEA;MACAC,UAAA;QACAC,GAAA;QACAC,MAAA;MACA;MACAC,gBAAA;MACAC,eAAA;MACAC,WAAA;MACAC,QAAA;QACAC,KAAA;QACAC,MAAA;MACA;MACAC,QAAA;MACAC,QAAA;MACAC,SAAA;MACAC,OAAA;MAEA;MACAC,WAAA,OAAAhE,eAAA;MACAiE,iBAAA;MAAA;MACAC,QAAA,EACAzB,YAAA,iBACA3G,cAAA,KAAAS,SAAA,CAAA4H,MAAA,GAAA5H,SAAA,CAAA6H,MAAA;MAAA;MACAC,kBAAA;MACAC,qBAAA;MACA;MACA;MACA;;MAEA;MACAC,wBAAA;MACAC,qBAAA;MAEA;MACAC,cAAA;MACAC,kBAAA;MAAA;MACAC,iBAAA;MAAA;MACAC,qBAAA;MAAA;MACAC,4BAAA;MAAA;MACAC,mCAAA;MAAA;;MAEA;MACAC,IAAA;MACAC,aAAA,EAAAvC,YAAA,oBACAwC,QAAA,CAAAxC,YAAA,qBACA;MAAA;MACAyC,cAAA;MAEAC,oBAAA;MAEA;MACAC,SAAA;MAEA;MACAC,kBAAA;MAEA;MACAC,MAAA,GACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA;IAEA;EACA;EACAC,QAAA;IACA,GAAA3I,QAAA;IACA;IACA4I,eAAA;MACA,SAAAxK,OAAA;MACA,YAAAyK,QAAA;IACA;IACA;IACAC,WAAA;MACA;MACA,aAAApB,qBAAA,GACA,6CACA;IACA;IACA;IACAqB,mBAAA;MACA,cAAA1B,iBAAA;IACA;IACA;IACA2B,kBAAA;MACA,gBAAA/E,YAAA,EAAAgF,GAAA,CAAAC,IAAA,QAAA7D,IAAA,CAAA6D,IAAA;IACA;IACA;IACAC,cAAA;MACA,gBAAAhF,QAAA,EAAA8E,GAAA,CAAAC,IAAA,QAAA7D,IAAA,CAAA6D,IAAA;IACA;IACAE,UAAA;MACA,OACA,KAAApF,KAAA,UAAAT,MAAA,CAAAK,iBAAA,IACA,KAAAI,KAAA,UAAAT,MAAA,CAAAM,mBAAA,IACA,KAAAG,KAAA,UAAAT,MAAA,CAAAO,cAAA,IACA,KAAAE,KAAA,UAAAT,MAAA,CAAAQ,kBAAA;IAEA;IACA;IACAsF,oBAAA;MACA;MACA,SAAAhH,yBAAA,cAAAA,yBAAA;;MAEA;MACA,UAAAiH,QAAA,SAAAnG,yBAAA;MAEA,IAAAoG,MAAA;MACA,IAAA3H,KAAA;MAEA,MAAA4H,gBAAA,QAAAC,OAAA,GACA,KAAAzE,sBAAA,GACA,KAAAsE,QAAA,CAAAE,gBAAA;;MAEA;MACA,WAAAE,EAAA,IAAAF,gBAAA;QACA,KAAAA,gBAAA,CAAAE,EAAA,EAAAC,OAAA;QAEA,SAAAvH,iBAAA,CAAAwH,cAAA,CAAAF,EAAA;UACA,WAAAG,KAAA,SAAAzH,iBAAA,CAAAsH,EAAA,EAAAI,cAAA;YACAlI,KAAA,QAAAQ,iBAAA,CAAAsH,EAAA,EAAAI,cAAA,CAAAD,KAAA;;YAEA;YACA,MAAAE,YAAA,GAAAP,gBAAA,CAAAE,EAAA,EAAAK,YAAA;YACA,KAAAA,YAAA,MAAAnI,KAAA,CAAAoI,UAAA,IAAAD,YAAA;cACA;cACA;cACAR,MAAA,CAAAU,IAAA,CAAArI,KAAA;cACA,UAAA2G,oBAAA,UAAAkB,OAAA;gBACA,KAAAS,eAAA;cACA;cACA;YACA;;YAEA;YACA,IAAAH,YAAA,CAAAnI,KAAA,CAAAoI,UAAA,EAAAL,OAAA;cACAJ,MAAA,CAAAU,IAAA,CAAArI,KAAA;YACA;UACA;QACA;MACA;MAEA,MAAAuI,UAAA,GAAAC,IAAA,CAAAC,KAAA,CAAAD,IAAA,CAAAE,SAAA,CAAAf,MAAA;MAEA,MAAAF,mBAAA,GAAA/K,oBAAA,CACA,KAAAsD,KAAA,EACAuI,UAAA,EACA,KAAA3H,UAAA,EACA,KAAA+H,cACA;MAEA,OAAAlB,mBAAA;IACA;IACA;IACAmB,yBAAA;MACA,SAAA5I,KAAA,CAAAC,IAAA,KAAAnC,UAAA,CAAA+K,KAAA;MAEA,MAAAC,mBAAA;MACA,WAAAC,MAAA,SAAA/I,KAAA,CAAAgJ,SAAA;QACA,IAAAD,MAAA,UAAArB,QAAA,CAAAuB,GAAA;UACAH,mBAAA,CAAAC,MAAA,SAAAtB,mBAAA;QACA,WAAAsB,MAAA,SAAAtH,sBAAA;UACAqH,mBAAA,CAAAC,MAAA,IAAArM,oBAAA,CACA,KAAAsD,KAAA,EACA,KAAAyB,sBAAA,CAAAsH,MAAA,GACA,KAAAnI,UAAA,EACA,KAAA+H,cACA;QACA;MACA;MAEA,OAAAG,mBAAA;IACA;IACAI,kBAAA;MACA,WAAA5G,GAAA,MAAAa,cAAA;IACA;IAEA;IACA;IACA;;IAEA;IACAgG,mBAAA;MACA,gBACA,KAAArF,iBAAA,CAAAsF,IAAA,GAAAC,MAAA,GACA,KAAAtF,sBAAA,CAAAqF,IAAA,GAAAC,MAAA,GACA,CACA;IACA;IAEA;IACAC,sBAAA;MACA,UAAAhE,SAAA,UAAA2B,QAAA;MAEA,MAAAsC,WAAA,QAAAzF,iBAAA,MAAAwB,SAAA,CAAAvC,GAAA;MACA,MAAAyG,gBAAA,QAAAzF,sBAAA,MAAAuB,SAAA,CAAAvC,GAAA;MAEA,IAAAwG,WAAA,CAAAF,MAAA,UAAAG,gBAAA,CAAAH,MAAA;MAEA,IAAAI,OAAA,GAAAC,QAAA;MACA,WAAAC,KAAA,QAAAJ,WAAA,KAAAC,gBAAA;QACA,IAAAG,KAAA,CAAAC,WAAA,YAAAtE,SAAA,CAAAxC,GAAA;UACA2G,OAAA,GAAAI,IAAA,CAAAC,GAAA,CACAL,OAAA,EACAE,KAAA,CAAAC,WAAA,YAAAtE,SAAA,CAAAxC,GACA;QACA;MACA;MAEA,OAAA2G,OAAA;IACA;IAEA;IACAM,6BAAA;MACA,UAAArC,QAAA,UAAA5D,iBAAA;MAEA,YAAAA,iBAAA,CAAAkG,IAAA,CAAAC,SAAA,IACAA,SAAA,CAAAD,IAAA,CAAAL,KAAA,IACAA,KAAA,CAAAX,SAAA,EAAAgB,IAAA,CACAE,QAAA,IAAAA,QAAA,CAAAnB,MAAA,UAAArB,QAAA,CAAAuB,GACA,CACA,CACA;IACA;IAEA;;IAEA;IACAkB,kBAAA;MACA,IAAAC,GAAA;MACA,SAAApK,KAAA,CAAAqK,QAAA;QACA,WAAAC,GAAA,SAAAC,OAAA;UACA,MAAAC,GAAA,IACA,SAAA7G,kBAAA,CAAA7G,GAAA,CAAAwN,GAAA,CAAAG,UAAA,CAAA/G,OAAA,OACA,IAAApB,GAAA,IACA,CAAAoI,MAAA,CAAAC,CAAA,SAAAzB,iBAAA,CAAA0B,GAAA,CAAAD,CAAA,GAAAtB,MAAA;UAEA,IAAAmB,GAAA,GAAAJ,GAAA,EAAAA,GAAA,GAAAI,GAAA;QACA;MACA;QACA,SAAAK,CAAA,MAAAA,CAAA,QAAA7K,KAAA,CAAA8K,KAAA,CAAAzB,MAAA,EAAAwB,CAAA;UACA,MAAAE,IAAA,OAAAtH,IAAA,MAAAzD,KAAA,CAAA8K,KAAA,CAAAD,CAAA;UACA,WAAAG,IAAA,SAAAC,KAAA;YACA,MAAAT,GAAA,IACA,QAAAU,4BAAA,CAAAH,IAAA,EAAAC,IAAA,CAAApB,WAAA,EACA,CAAAc,MAAA,CAAAC,CAAA,SAAAzB,iBAAA,CAAA0B,GAAA,CAAAD,CAAA,GAAAtB,MAAA;YAEA,IAAAmB,GAAA,GAAAJ,GAAA,EAAAA,GAAA,GAAAI,GAAA;UACA;QACA;MACA;MACA,OAAAJ,GAAA;IACA;IACA;IACAe,UAAA;MACA,OAAAtB,IAAA,CAAAuB,KAAA,OAAApL,KAAA,CAAAqL,SAAA,QAAA1C,cAAA;IACA;IACA;IACA4B,QAAA;MACA,MAAAe,IAAA;MACA,MAAAC,UAAA,OAAAjJ,GAAA;MAEA,MAAAkJ,aAAA,GAAAT,IAAA;QACA,IAAAU,UAAA;QACA,IAAAC,SAAA;QACA,MAAAC,UAAA,OAAAlI,IAAA,CAAAsH,IAAA;QACA,SAAAa,eAAA;UACAD,UAAA,CAAAE,OAAA,CACAF,UAAA,CAAAjI,OAAA,UAAAiF,cAAA,YACA;QACA;UACAgD,UAAA,CAAAG,OAAA,CAAAH,UAAA,CAAAI,OAAA,UAAAZ,SAAA;QACA;QACA;QACAM,UAAA,GAAArM,KAAA,CAAAuM,UAAA,EAAAK,MAAA;QACAN,SAAA,QAAAxE,UAAA,CAAAyE,UAAA,CAAAM,SAAA;QACA;UAAAR,UAAA;UAAAC;QAAA;MACA;MAEA,IACA,KAAAE,eAAA,KACA,KAAAxJ,KAAA,UAAAT,MAAA,CAAAQ,kBAAA,IACA,KAAAnC,KAAA,CAAAiL,KAAA,EAAA5B,MAAA,SACA;QACA,IAAA6C,QAAA;QACA,SAAArB,CAAA,MAAAA,CAAA,QAAA7K,KAAA,CAAA8K,KAAA,CAAAzB,MAAA,IAAAwB,CAAA;UACA,MAAAE,IAAA,OAAAtH,IAAA,MAAAzD,KAAA,CAAA8K,KAAA,CAAAD,CAAA;UACA,MAAAsB,SAAA,OAAA1I,IAAA,CACAsH,IAAA,CAAArH,OAAA,UAAAiF,cAAA,YACA;UACAwD,SAAA,CAAAC,WAAA;UACAD,SAAA,CAAAN,OAAA,CACAM,SAAA,CAAAzI,OAAA,UAAAiF,cAAA,YACA;UAEA,KAAA4C,UAAA,CAAAX,GAAA,CAAAuB,SAAA,CAAAzI,OAAA;YACA6H,UAAA,CAAAc,GAAA,CAAAF,SAAA,CAAAzI,OAAA;YAEA,IAAA4I,aAAA;YACA,IAAAJ,QAAA;cACAI,aAAA,GACAJ,QAAA,CAAAxI,OAAA,OAAAyI,SAAA,CAAAzI,OAAA;YACA;YACA;cAAAgI,SAAA;cAAAD;YAAA,IAAAD,aAAA,CAAAW,SAAA;YACAb,IAAA,CAAAjD,IAAA;cACAkE,OAAA,EAAAb,SAAA;cACAD,UAAA;cACAhB,UAAA,EAAA0B,SAAA;cACAG;YACA;YAEAJ,QAAA,OAAAzI,IAAA,CAAA0I,SAAA;UACA;QACA;QACA,OAAAb,IAAA;MACA;MAEA,SAAAT,CAAA,MAAAA,CAAA,QAAA7K,KAAA,CAAA8K,KAAA,CAAAzB,MAAA,IAAAwB,CAAA;QACA,MAAAE,IAAA,OAAAtH,IAAA,MAAAzD,KAAA,CAAA8K,KAAA,CAAAD,CAAA;QACAU,UAAA,CAAAc,GAAA,CAAAtB,IAAA,CAAArH,OAAA;QAEA;UAAAgI,SAAA;UAAAD;QAAA,IAAAD,aAAA,CAAAT,IAAA;QACAO,IAAA,CAAAjD,IAAA;UACAkE,OAAA,EAAAb,SAAA;UACAD,UAAA;UACAhB,UAAA,EAAAM;QACA;MACA;MAEA,IAAAyB,QAAA;MACA,SAAA3B,CAAA,MAAAA,CAAA,QAAA7K,KAAA,CAAA8K,KAAA,CAAAzB,MAAA,IAAAwB,CAAA;QACA,MAAAE,IAAA,OAAAtH,IAAA,MAAAzD,KAAA,CAAA8K,KAAA,CAAAD,CAAA;QACA;QACA,MAAA4B,UAAA,OAAAhJ,IAAA,CACAsH,IAAA,CAAArH,OAAA,UAAAiF,cAAA,YACA;QACA,MAAA+D,QAAA,OAAAjJ,IAAA,CACAsH,IAAA,CAAArH,OAAA,KACA,KAAA1D,KAAA,CAAA2M,QAAA,oBACA,KAAAhE,cAAA,YACA;QACA,MAAAiE,kBAAA,GACAF,QAAA,CAAAG,WAAA,YAAAH,QAAA,CAAAI,aAAA;QACA,IACAL,UAAA,CAAAM,UAAA,OAAAL,QAAA,CAAAK,UAAA,MACA,CAAAH,kBAAA,EACA;UACA;UACA,IAAAI,QAAA,OAAAvJ,IAAA,CAAAsH,IAAA;UACAiC,QAAA,CAAAC,UAAA,CAAAD,QAAA,CAAAD,UAAA;UACA,KAAAxB,UAAA,CAAAX,GAAA,CAAAoC,QAAA,CAAAtJ,OAAA;YACA6H,UAAA,CAAAc,GAAA,CAAAW,QAAA,CAAAtJ,OAAA;YAEA;cAAAgI,SAAA;cAAAD;YAAA,IAAAD,aAAA,CAAAwB,QAAA;YACA1B,IAAA,CAAA4B,MAAA,CAAAV,QAAA;cACAD,OAAA,EAAAb,SAAA;cACAD,UAAA;cACAhB,UAAA,EAAAuC,QAAA;cACAG,YAAA;YACA;YACAX,QAAA;UACA;QACA;QACAA,QAAA;MACA;MAEA,IAAAN,QAAA;MACA,SAAArB,CAAA,MAAAA,CAAA,GAAAS,IAAA,CAAAjC,MAAA,IAAAwB,CAAA;QACA,IAAAyB,aAAA;QACA,IAAAJ,QAAA;UACAI,aAAA,GACAJ,QAAA,CAAAxI,OAAA,OACA4H,IAAA,CAAAT,CAAA,EAAAJ,UAAA,CAAA/G,OAAA;QACA;QAEA4H,IAAA,CAAAT,CAAA,EAAAyB,aAAA,GAAAA,aAAA;QAEAJ,QAAA,OAAAzI,IAAA,CAAA6H,IAAA,CAAAT,CAAA,EAAAJ,UAAA;MACA;MAEA,OAAAa,IAAA;IACA;IACA;IACAA,KAAA;MACA,MAAA8B,KAAA,QAAA7C,OAAA,CAAA6C,KAAA,CACA,KAAA7G,IAAA,QAAA8G,cAAA,EACA,MAAA9G,IAAA,aAAA8G,cACA;MACAD,KAAA;QAAA,GAAAA,KAAA;QAAAd,aAAA;MAAA;MACA,OAAAc,KAAA;IACA;IACA;IACAE,UAAA;MACA,MAAAA,SAAA;MACA,MAAAC,UAAA,OAAAjL,GAAA,CACA,KAAAiI,OAAA,CAAAlD,GAAA,CAAAmG,CAAA,IAAAA,CAAA,CAAA/C,UAAA,CAAA/G,OAAA,GACA;;MAEA;MACA,MAAAqH,IAAA,OAAAtH,IAAA,MAAAzD,KAAA,CAAA8K,KAAA;MACA,MAAA2C,UAAA,GAAA1C,IAAA,CAAA2C,WAAA,UAAAnH,IAAA;MACA,MAAAoH,IAAA,GAAA5C,IAAA,CAAA6C,cAAA;MAEA,MAAAC,kBAAA,OAAApK,IAAA,CAAAA,IAAA,CAAAqK,GAAA,CAAAH,IAAA,EAAAF,UAAA;MACA,MAAAM,iBAAA,OAAAtK,IAAA,CAAAA,IAAA,CAAAqK,GAAA,CAAAH,IAAA,EAAAF,UAAA;;MAEA;MACA,MAAAO,OAAA,OAAAvK,IAAA,CAAAoK,kBAAA;MACA,IAAAI,oBAAA;MACA,MAAAC,iBAAA,GAAAH,iBAAA,CAAAhB,UAAA;MACA,MAAAoB,oBAAA,OAAAJ,iBAAA,CAAA9B,SAAA;MACA,MAAAmC,oBAAA,SAAAtI,qBAAA,GACA+H,kBAAA,CAAA5B,SAAA,SACA4B,kBAAA,CAAA5B,SAAA;MACA,IAAAmC,oBAAA;QACAJ,OAAA,CAAAf,UAAA,CACAe,OAAA,CAAAjB,UAAA,MACAc,kBAAA,CAAA5B,SAAA,MACA,KAAAnG,qBAAA,UACA;QACAmI,oBAAA,GAAAJ,kBAAA,CAAA5B,SAAA;MACA;QACA+B,OAAA,CAAAf,UAAA,CAAAe,OAAA,CAAAjB,UAAA;MACA;MACAiB,OAAA,CAAA5B,WAAA,MAAApM,KAAA,CAAAqL,SAAA;;MAEA;MACA,MAAAgD,SAAA,GACAJ,oBAAA,GAAAC,iBAAA,GAAAC,oBAAA;MACA,SAAAtD,CAAA,MAAAA,CAAA,GAAAwD,SAAA,IAAAxD,CAAA;QACA;QACA,IAAAmD,OAAA,CAAAN,WAAA,OAAAK,iBAAA,CAAAL,WAAA;UACAJ,SAAA,CAAAjF,IAAA;YACA0C,IAAA,EAAAiD,OAAA,CAAAjB,UAAA;YACA/B,IAAA,EAAAgD,OAAA,CAAAtK,OAAA;YACA+G,UAAA,MAAAhH,IAAA,CAAAuK,OAAA;YACAM,QAAA,EAAAf,UAAA,CAAA3C,GAAA,CAAAoD,OAAA,CAAAtK,OAAA;UACA;QACA;UACA4J,SAAA,CAAAjF,IAAA;YACA0C,IAAA;YACAC,IAAA,EAAAgD,OAAA,CAAAtK,OAAA;YACA+G,UAAA,MAAAhH,IAAA,CAAAuK,OAAA;YACAM,QAAA;UACA;QACA;QAEAN,OAAA,CAAAf,UAAA,CAAAe,OAAA,CAAAjB,UAAA;MACA;MAEA,OAAAO,SAAA;IACA;IACA;IACAiB,iBAAA;MACA,MAAAC,WAAA,OAAA5K,GAAA;MACA,WAAA6K,QAAA,SAAAnB,SAAA;QACAkB,WAAA,CAAAE,GAAA,CAAAD,QAAA,CAAAhE,UAAA,CAAA/G,OAAA,IAAA+K,QAAA,CAAAH,QAAA;MACA;MACA,OAAAE,WAAA;IACA;IACA;IACAG,aAAA;MACA;MACA,MAAA5D,IAAA,GAAA3L,KAAA,MAAAY,KAAA,CAAA8K,KAAA,KAAAuB,GAAA,MAAA9F,IAAA;MACA,OAAAwE,IAAA,CAAAiB,MAAA;IACA;IACA4C,aAAA;MACA;MACA,YAAAnK,aAAA,QAAA9C,MAAA,CAAAI,UAAA,QAAAJ,MAAA,CAAAC,OAAA;IACA;IACAiN,QAAA;MACA;MACA,OACA,KAAAzM,KAAA,UAAAT,MAAA,CAAAK,iBAAA,IACA,KAAAI,KAAA,UAAAT,MAAA,CAAAM,mBAAA;IAEA;IACA6M,WAAA;MACA;MACA,YAAA1M,KAAA,UAAAT,MAAA,CAAAO,cAAA;IACA;IACA1F,QAAA;MACA,OAAAA,OAAA,MAAAuS,QAAA;IACA;IACAC,QAAA;MACA,YAAAtH,QAAA,EAAAuB,GAAA,UAAAjJ,KAAA,CAAAiP,OAAA;IACA;IACAC,gBAAA;MACA,YAAAlP,KAAA,CAAAC,IAAA,KAAAnC,UAAA,CAAAqR,cAAA,UAAAnP,KAAA,CAAAC,IAAA;IACA;IACAmP,SAAA;MACA,YAAApP,KAAA,CAAAC,IAAA,KAAAnC,UAAA,CAAAuR,GAAA;IACA;IACAxH,QAAA;MACA,YAAA7H,KAAA,CAAAC,IAAA,KAAAnC,UAAA,CAAA+K,KAAA;IACA;IACA5B,SAAA;MACA,YAAAjH,KAAA,CAAAsP,YAAA;IACA;IACA1D,gBAAA;MACA,YAAA5L,KAAA,CAAAuP,gBAAA;IACA;IACAC,YAAA;MACA,OAAAtP,MAAA,CAAAuP,MAAA,MAAAC,eAAA,EACArI,GAAA,CAAAsD,CAAA,IAAAA,CAAA,CAAAgF,IAAA,EACAjF,MAAA,CAAArK,OAAA;IACA;IACAuP,wBAAA;MACA,SAAAC,sBAAA,cAAAC,SAAA;MAEA,SAAA3M,cAAA,CAAAkG,MAAA;MAEA,MAAAsG,IAAA,QAAAD,eAAA,MAAAvM,cAAA,KAAAwM,IAAA;MACA,YAAAI,OAAA,CAAAJ,IAAA,IAAAA,IAAA,CAAA1G,GAAA;IACA;IACA+G,oBAAA;MACA,MAAAC,KAAA;MACA,IAAAC,GAAA,EAAA/K,MAAA,EAAAgL,aAAA;MACA,SAAA/K,QAAA;QACA8K,GAAA,QAAA5K,SAAA,CAAAxC,GAAA;QACAqC,MAAA,QAAAI,OAAA,CAAAzC,GAAA,QAAAwC,SAAA,CAAAxC,GAAA;QACAqN,aAAA,QAAA7K,SAAA,CAAAxC,GAAA,SAAAsN,UAAA,IAAA/G,MAAA;MACA;QACA6G,GAAA,QAAAzK,iBAAA,CAAA3C,GAAA;QACAqC,MAAA,QAAAM,iBAAA,CAAA4K,OAAA;QACAF,aAAA,QAAA1K,iBAAA,CAAA3C,GAAA,SAAAsN,UAAA,IAAA/G,MAAA;MACA;MAEA,IAAA8G,aAAA;QACAF,KAAA,CAAAC,GAAA,WAAAA,GAAA,WAAAI,cAAA,aAAAxL,gBAAA;MACA;QACAmL,KAAA,CAAAC,GAAA,WAAAA,GAAA,WAAAI,cAAA;MACA;MACAL,KAAA,CAAA9K,MAAA,WAAAA,MAAA,WAAAmL,cAAA;MACA,OAAAL,KAAA;IACA;IACAM,6BAAA;MACA,MAAAN,KAAA;MACA,IAAAC,GAAA;QACA/K,MAAA;MACA,SAAAC,QAAA;QACA8K,GAAA,QAAA5K,SAAA,CAAAxC,GAAA;QACAqC,MAAA,QAAAI,OAAA,CAAAzC,GAAA,QAAAwC,SAAA,CAAAxC,GAAA;MACA;MACAmN,KAAA,CAAAC,GAAA,WAAAA,GAAA;MACAD,KAAA,CAAA9K,MAAA,WAAAA,MAAA;MACA,OAAA8K,KAAA;IACA;IACA;IACAP,gBAAA;MACA,MAAAc,MAAA;;MAEA;MACA,SAAAxQ,KAAA,CAAAC,IAAA,KAAAnC,UAAA,CAAA+K,KAAA;QACA,WAAAE,MAAA,SAAA/I,KAAA,CAAAgJ,SAAA;UACA,MAAAvB,mBAAA,QAAAmB,wBAAA,CAAAG,MAAA;UACA,IAAAtB,mBAAA;YACA;YACA,MAAAgJ,yBAAA,QAAAC,wBAAA,CACA,KAAArN,gBAAA,CAAA0F,MAAA,GAAAlC,kBACA;YACA,MAAA8J,qBAAA,GACA5H,MAAA,UAAArB,QAAA,CAAAuB,GAAA,GACA,KAAAyH,wBAAA,MAAA7J,kBAAA,IACA;;YAEA;YACA;YACA,MAAAxE,YAAA,QAAAuO,iCAAA;cACAnJ,mBAAA;cACAoJ,0BAAA;cACAJ,yBAAA,EAAAA,yBAAA;cACAE,qBAAA,EAAAA,qBAAA;cACAG,eAAA,EACA/H,MAAA,UAAArB,QAAA,CAAAuB,GAAA,GACA;gBACA3E,UAAA,OAAAA,UAAA;gBACAC,YAAA,OAAAA;cACA,IACA,KAAAlB,gBAAA,CAAA0F,MAAA,GAAA+H,eAAA,IAAA5M;YACA;YAEAsM,MAAA,CAAAzH,MAAA;cACA,QAAA/I,KAAA,CAAAgJ,SAAA,CAAAD,MAAA;cACA1G,YAAA,EAAAA;YACA;UACA;YACAmO,MAAA,CAAAzH,MAAA;cACA,QAAA/I,KAAA,CAAAgJ,SAAA,CAAAD,MAAA;cACA1G,YAAA,MAAAC,GAAA;YACA;UACA;QACA;QACA,OAAAkO,MAAA;MACA;;MAEA;MACA,SAAAxQ,KAAA,CAAA+Q,wBAAA,UAAA/B,OAAA;QACA,MAAAc,SAAA,GAAA7L,YAAA,MAAA+M,YAAA;QACA,MAAAjI,MAAA,QAAArB,QAAA,EAAAuB,GAAA,IAAA6G,SAAA;QACA,IAAA/G,MAAA,SAAA/I,KAAA,CAAAgJ,SAAA;UACA,MAAA2G,IAAA;YACA,QAAA3P,KAAA,CAAAgJ,SAAA,CAAAD,MAAA,EAAA4G,IAAA;YACA1G,GAAA,EAAAF;UACA;UACAyH,MAAA,CAAAzH,MAAA;YACA,QAAA/I,KAAA,CAAAgJ,SAAA,CAAAD,MAAA;YACA1G,YAAA,MAAAC,GAAA,CACA,KAAAe,gBAAA,CAAA0F,MAAA,GAAA1G,YAAA,EAAAgF,GAAA,CAAA4J,CAAA,IACA,IAAAxN,IAAA,CAAAwN,CAAA,EAAAvN,OAAA,EACA,CACA;YACAnB,QAAA,MAAAD,GAAA,CACA,KAAAe,gBAAA,CAAA0F,MAAA,GAAAxG,QAAA,EAAA8E,GAAA,CAAA4J,CAAA,IACA,IAAAxN,IAAA,CAAAwN,CAAA,EAAAvN,OAAA,EACA,CACA;YACAiM,IAAA,EAAAA;UACA;QACA;QACA,OAAAa,MAAA;MACA;;MAEA;MACA,WAAAU,CAAA,IAAAhR,MAAA,CAAAiR,IAAA,MAAAnR,KAAA,CAAAgJ,SAAA;QACA,MAAAoI,OAAA;UACA,QAAApR,KAAA,CAAAgJ,SAAA,CAAAkI,CAAA,EAAAvB,IAAA;UACA1G,GAAA,EAAAiI;QACA;QACAV,MAAA,CAAAU,CAAA;UACA,QAAAlR,KAAA,CAAAgJ,SAAA,CAAAkI,CAAA;UACA7O,YAAA,MAAAC,GAAA,CACA,KAAAe,gBAAA,CAAA6N,CAAA,GAAA7O,YAAA,EAAAgF,GAAA,CAAA4J,CAAA,IACA,IAAAxN,IAAA,CAAAwN,CAAA,EAAAvN,OAAA,EACA,CACA;UACAnB,QAAA,MAAAD,GAAA,CACA,KAAAe,gBAAA,CAAA6N,CAAA,GAAA3O,QAAA,EAAA8E,GAAA,CAAA4J,CAAA,IACA,IAAAxN,IAAA,CAAAwN,CAAA,EAAAvN,OAAA,EACA,CACA;UACAiM,IAAA,EAAAyB;QACA;MACA;MACA,OAAAZ,MAAA;IACA;IACApG,IAAA;MACA,IAAAA,GAAA;MACA,YAAAiH,QAAA,EAAAhP,YAAA,UAAAsB,kBAAA;QACA,IAAAtB,YAAA,CAAAiP,IAAA,GAAAlH,GAAA;UACAA,GAAA,GAAA/H,YAAA,CAAAiP,IAAA;QACA;MACA;MAEA,OAAAlH,GAAA;IACA;IACA;IACAmH,iBAAA;MACA,WAAAjP,GAAA,MAAAtC,KAAA,CAAAiL,KAAA,EAAA5D,GAAA,CAAAmK,CAAA,QAAA/N,IAAA,CAAA+N,CAAA,EAAA9N,OAAA;IACA;IACA;AACA;AACA;AACA;AACA;AACA;AACA;IACA0M,WAAA;MACA,MAAAA,UAAA;MAEA,MAAAqB,YAAA,QAAAzR,KAAA,CAAAqL,SAAA;MACA,MAAAqG,UAAA,QAAA1R,KAAA,CAAAqL,SAAA,QAAArL,KAAA,CAAA2M,QAAA;MACA,MAAAgF,cAAA,GAAAlV,kBAAA,CACAgV,YAAA,EACA,KAAA9I,cACA;MACA,MAAAiJ,YAAA,GAAAnV,kBAAA,CAAAiV,UAAA,OAAA/I,cAAA;;MAEA;MACA,MAAAkJ,eAAA,QAAAlJ,cAAA;MACA,MAAAmJ,gBAAA,GAAAL,YAAA;MACA,IAAAM,UAAA;MACA,IAAAF,eAAA,KAAAC,gBAAA;QACAC,UAAA;MACA;MAEA,MAAAC,aAAA,GAAApI,WAAA;QACA,SAAAqI,gBAAA,KAAAjU,iBAAA,CAAAkU,eAAA;UACA,QACA;YACAtI,WAAA,EAAAA,WAAA;UACA,GACA;YACAA,WAAA,EAAAA,WAAA;UACA,GACA;YACAA,WAAA,EAAAA,WAAA;UACA,EACA;QACA,gBAAAqI,gBAAA,KAAAjU,iBAAA,CAAAmU,cAAA;UACA,QACA;YACAvI,WAAA,EAAAA,WAAA;UACA,EACA;QACA;QACA;MACA;MAEA,SAAAxH,KAAA,UAAAT,MAAA,CAAAQ,kBAAA;QACA;QACA,SAAA0I,CAAA,MAAAA,CAAA,UAAAA,CAAA;UACA,MAAAjB,WAAA,GAAAiB,CAAA;UACA,IAAAA,CAAA;YACA;YACAuF,UAAA,IAAA/H,IAAA;cACAP,EAAA;cACA8B,WAAA;cACAwI,IAAA,EAAAnW,iBAAA,CAAA4O,CAAA,OAAAnF,QAAA,KAAA3H,SAAA,CAAA4H,MAAA;YACA;UACA;YACAyK,UAAA,IAAA/H,IAAA;cACAuB,WAAA;cACAwI,IAAA,EAAAnW,iBAAA,CAAA4O,CAAA,OAAAnF,QAAA,KAAA3H,SAAA,CAAA4H,MAAA;YACA;UACA;UACAyK,UAAA,IAAA/H,IAAA,IAAA2J,aAAA,CAAApI,WAAA;QACA;QACA,OAAAwG,UAAA;MACA;MAEA,IAAAwB,YAAA,IAAAD,cAAA,IAAAC,YAAA;QACA,SAAA/G,CAAA,MAAAA,CAAA,GAAA+G,YAAA,IAAA/G,CAAA;UACAuF,UAAA,IAAA/H,IAAA;YACAuB,WAAA,OAAA5J,KAAA,CAAA2M,QAAA,IAAAiF,YAAA,GAAA/G,CAAA;YACAuH,IAAA,EAAAnW,iBAAA,CAAA4O,CAAA,OAAAnF,QAAA,KAAA3H,SAAA,CAAA4H,MAAA;UACA;UACAyK,UAAA,IAAA/H,IAAA,CACA,GAAA2J,aAAA,MAAAhS,KAAA,CAAA2M,QAAA,IAAAiF,YAAA,GAAA/G,CAAA,EACA;QACA;QACA,SAAAA,CAAA,MAAAA,CAAA,QAAA8G,cAAA,IAAA9G,CAAA;UACA,MAAAwH,SAAA,GAAAxH,CAAA,GAAAkH,UAAA;UACA3B,UAAA,IAAA/H,IAAA;YACAuB,WAAA,EAAAyI,SAAA;YACAD,IAAA,EAAAnW,iBAAA,CACA0V,cAAA,GAAAU,SAAA,EACA,KAAA3M,QAAA,KAAA3H,SAAA,CAAA4H,MACA;UACA;UACAyK,UAAA,IAAA/H,IAAA,IAAA2J,aAAA,CAAAK,SAAA;QACA;MACA;QACA,SAAAxH,CAAA,MAAAA,CAAA,QAAA7K,KAAA,CAAA2M,QAAA,IAAA9B,CAAA;UACA,MAAAwH,SAAA,GAAAxH,CAAA,GAAAkH,UAAA;UACA,MAAAO,UAAA,QAAAtS,KAAA,CAAAqL,SAAA,GAAAgH,SAAA;UACA,MAAAE,YAAA,GAAA9V,kBAAA,CACA6V,UAAA,EACA,KAAA3J,cACA;UAEAyH,UAAA,IAAA/H,IAAA;YACAuB,WAAA,EAAAyI,SAAA;YACAD,IAAA,EAAAnW,iBAAA,CACAsW,YAAA,EACA,KAAA7M,QAAA,KAAA3H,SAAA,CAAA4H,MACA;UACA;UACAyK,UAAA,IAAA/H,IAAA,IAAA2J,aAAA,CAAAK,SAAA;QACA;QACA,IAAAN,UAAA;UACA,MAAAQ,YAAA,GAAA9V,kBAAA,CACA,KAAAuD,KAAA,CAAAqL,SAAA,QAAArL,KAAA,CAAA2M,QAAA,QACA,KAAAhE,cACA;UACAyH,UAAA,IAAA/H,IAAA;YACAuB,WAAA,OAAA5J,KAAA,CAAA2M,QAAA;YACAyF,IAAA,EAAAnW,iBAAA,CACAsW,YAAA,EACA,KAAA7M,QAAA,KAAA3H,SAAA,CAAA4H,MACA;UACA;UACAyK,UAAA,IAAA/H,IAAA,IAAA2J,aAAA,MAAAhS,KAAA,CAAA2M,QAAA;QACA;QACAyD,UAAA;MACA;MAEA,OAAAA,UAAA;IACA;IACA;IACAnF,MAAA;MACA,gBAAAmF,UAAA,aAAAA,UAAA;IACA;IACA6B,iBAAA;MACA,YAAAjS,KAAA,CAAAwS,aAAA,IAAAxU,iBAAA,CAAAkU,eAAA;IACA;IACA5B,eAAA;MACA,SAAA2B,gBAAA,KAAAjU,iBAAA,CAAAkU,eAAA;QACA,OAAArI,IAAA,CAAAuB,KAAA,MAAApG,WAAA;MACA,gBAAAiN,gBAAA,KAAAjU,iBAAA,CAAAmU,cAAA;QACA,OAAAtI,IAAA,CAAAuB,KAAA,MAAApG,WAAA;MACA,gBAAAiN,gBAAA,KAAAjU,iBAAA,CAAAyU,QAAA;QACA,YAAAzN,WAAA;MACA;MACA,OAAA6E,IAAA,CAAAuB,KAAA,MAAApG,WAAA;IACA;IACA2D,eAAA;MACA,uBAAAnD,WAAA;QACA,WAAA/B,IAAA,GAAAiP,iBAAA;MACA;MAEA,SAAA1S,KAAA,CAAAC,IAAA,KAAAnC,UAAA,CAAAuR,GAAA;QACA,YAAA7J,WAAA,CAAAmN,MAAA;MACA;;MAEA;MACA;MACA;MACA,OACAvT,KAAA,MAAAY,KAAA,CAAA8K,KAAA,KAAA8H,EAAA,MAAApN,WAAA,CAAAqN,KAAA,EAAAC,SAAA;MAAA;IAEA;IACAC,iBAAA;MACA,YAAArL,QAAA,SAAAA,QAAA,CAAAuB,GAAA,SAAAyG,eAAA;IACA;IACAsD,eAAA;MACA,YAAA9M,kBAAA;IACA;IACA+M,gBAAA;MACA,OAAApJ,IAAA,CAAAqJ,IAAA,MAAAhN,kBAAA,SAAAC,iBAAA;IACA;IACAkH,eAAA;MACA,YAAA7Q,OAAA,QAAAgK,aAAA;IACA;IACA2M,YAAA;MACA,SAAAnT,KAAA,CAAAqK,QAAA;QACA,MAAA+I,OAAA,OAAA3P,IAAA,MAAAzD,KAAA,CAAA8K,KAAA,MAAA9K,KAAA,CAAA8K,KAAA,CAAAzB,MAAA;QACA,MAAA2E,OAAA,OAAAvK,IAAA,MAAAzD,KAAA,CAAA8K,KAAA;QACA,MAAA2C,UAAA,GAAAO,OAAA,CAAAN,WAAA,UAAAnH,IAAA;QACA,MAAAoH,IAAA,GAAAK,OAAA,CAAAJ,cAAA;QAEA,MAAAG,iBAAA,OAAAtK,IAAA,CAAAA,IAAA,CAAAqK,GAAA,CAAAH,IAAA,EAAAF,UAAA;QAEA,OAAAM,iBAAA,CAAArK,OAAA,KAAA0P,OAAA,CAAA1P,OAAA;MACA;MAEA,OACA,KAAA6G,OAAA,CAAAlB,MAAA,SAAA9C,IAAA,aAAA8G,cAAA,QACA,KAAArN,KAAA,CAAAC,IAAA,KAAAnC,UAAA,CAAA+K,KAAA;IAEA;IACAwK,YAAA;MACA,YAAA9M,IAAA,aAAAvG,KAAA,CAAAC,IAAA,KAAAnC,UAAA,CAAA+K,KAAA;IACA;IACA;IACAyK,SAAA;MACA,YAAAH,WAAA,SAAAE,WAAA;IACA;IAEAE,sBAAA;MACA,OACA,KAAA/W,OAAA,IACA,MAAA4J,qBAAA,KACA,KAAAvD,WAAA,CAAAC,GAAA,WACA,KAAAI,aAAA,CAAAmG,MAAA,QACA,KAAAlG,cAAA,CAAAkG,MAAA;IAEA;IAEA;IACAmK,SAAA;MACA,SAAAhX,OAAA;QACA,aAAA4F,KAAA;UACA,UAAAyF,OAAA,SAAAlG,MAAA,CAAAK,iBAAA;YACA;UACA,UAAAL,MAAA,CAAAK,iBAAA;YACA,MAAAyR,WAAA,QAAAzT,KAAA,CAAAqK,QAAA;YACA,SAAAlG,gBAAA,KAAAvG,iBAAA,CAAA8V,SAAA;cACA,+CAAAD,WAAA;YACA;YACA,+CAAAA,WAAA;UACA,UAAA9R,MAAA,CAAAO,cAAA;YACA;UACA;YACA;QACA;MACA;MAEA,aAAAE,KAAA;QACA,UAAAyF,OAAA,SAAAlG,MAAA,CAAAK,iBAAA;UACA;QACA,UAAAL,MAAA,CAAAK,iBAAA;UACA,MAAAyR,WAAA,QAAAzT,KAAA,CAAAqK,QAAA;UACA,SAAAlG,gBAAA,KAAAvG,iBAAA,CAAA8V,SAAA;YACA,iDAAAD,WAAA;UACA;UACA,iDAAAA,WAAA;QACA,UAAA9R,MAAA,CAAAO,cAAA;UACA;QACA;UACA;MACA;IACA;IACAyR,WAAA;MACA,aAAA/M,SAAA,IAAA3C,YAAA,MAAA2P,wBAAA;IACA;IACAA,yBAAA;MACA,6BAAAxR,KAAA,wBAAAyF,OAAA;IACA;IACAgM,cAAA;MACA,YAAAzS,YAAA,SAAAoS,QAAA,gBAAAG,UAAA;IACA;IAEAG,mBAAA;MACA,MAAAC,WAAA;MACA,SAAAvG,CAAA,MAAAA,CAAA,QAAAlC,IAAA,CAAAjC,MAAA,IAAAmE,CAAA;QACA,MAAAlD,GAAA,QAAAgB,IAAA,CAAAkC,CAAA;QACA,SAAAgE,CAAA,MAAAA,CAAA,QAAApB,UAAA,IAAA/G,MAAA,IAAAmI,CAAA;UACA,MAAAxG,IAAA,QAAAoF,UAAA,IAAAoB,CAAA;UACAuC,WAAA,CAAA1L,IAAA,MAAA2L,yBAAA,CAAA1J,GAAA,EAAAU,IAAA,EAAAwC,CAAA,EAAAgE,CAAA;QACA;QACA,SAAAA,CAAA,MAAAA,CAAA,QAAApB,UAAA,IAAA/G,MAAA,IAAAmI,CAAA;UACA,MAAAxG,IAAA,QAAAoF,UAAA,IAAAoB,CAAA;UACAuC,WAAA,CAAA1L,IAAA,CACA,KAAA2L,yBAAA,CACA1J,GAAA,EACAU,IAAA,EACAwC,CAAA,EACAgE,CAAA,QAAApB,UAAA,IAAA/G,MACA,CACA;QACA;MACA;MACA,OAAA0K,WAAA;IACA;IACAE,sBAAA;MACA,MAAAF,WAAA;MACA,SAAAlJ,CAAA,MAAAA,CAAA,QAAAyC,SAAA,CAAAjE,MAAA,IAAAwB,CAAA;QACAkJ,WAAA,CAAA1L,IAAA,CACA,KAAA6L,wBAAA,MAAA5G,SAAA,CAAAzC,CAAA,EAAAJ,UAAA,EAAAI,CAAA,CACA;MACA;MACA,OAAAkJ,WAAA;IACA;IACAI,YAAA;MACA,MAAAC,IAAA;MACA,SAAA5G,CAAA,MAAAA,CAAA,QAAAlC,IAAA,CAAAjC,MAAA,IAAAmE,CAAA;QACA,SAAAgE,CAAA,MAAAA,CAAA,QAAAvG,KAAA,CAAA5B,MAAA,IAAAmI,CAAA;UACA4C,IAAA,CAAA/L,IAAA,MAAAgM,cAAA,CAAA7C,CAAA,EAAAhE,CAAA;QACA;MACA;MACA,OAAA4G,IAAA;IACA;IACAE,eAAA;MACA,MAAAF,IAAA;MACA,SAAAvJ,CAAA,MAAAA,CAAA,QAAAyC,SAAA,CAAAjE,MAAA,IAAAwB,CAAA;QACA,MAAA/H,GAAA,GAAA+G,IAAA,CAAAuB,KAAA,CAAAP,CAAA;QACA,MAAA9H,GAAA,GAAA8H,CAAA;QACAuJ,IAAA,CAAA/L,IAAA,MAAAgM,cAAA,CAAAvR,GAAA,EAAAC,GAAA;MACA;MACA,OAAAqR,IAAA;IACA;IAEA;IACAG,WAAA;MACA;QACA;QACA,MAAA1M,OAAA,SAAA/G,wBAAA,SAAA+N,OAAA,KACA,KAAAtO,qBAAA;QACA;QACA,KAAA+C,gBAAA,CAAAC;MAAA;IAEA;IAEA;IACAyN,aAAA;MACA,eAAAhR,KAAA,CAAAiJ,GAAA;IACA;IACA;IACA6G,UAAA;MACA,OAAA7L,YAAA,MAAA+M,YAAA;IACA;IACA;IACAnB,uBAAA;MACA,OACA,KAAAC,SAAA,EAAAzG,MAAA,aAAAyG,SAAA,SAAAJ,eAAA;IAEA;IAEA;AACA;AACA;IACA8E,qBAAA;MACA,MAAAA,oBAAA;MACA,KAAAlJ,IAAA,CAAAmJ,OAAA,EAAAnK,GAAA,EAAAkD,CAAA;QACAgH,oBAAA,CAAAnM,IAAA;QACA,IAAAqM,aAAA;QACA,MAAAC,6BAAA,GAAAA,CAAA3J,IAAA,EAAAwG,CAAA;UACA,MAAAzG,IAAA,QAAA6J,iBAAA,CAAApD,CAAA,EAAAhE,CAAA;UACA,KAAAzC,IAAA;UAEA,MAAA8J,OAAA,GACA,KAAAzP,QAAA,IACA,KAAA0P,WAAA,CAAAtD,CAAA,EAAAhE,CAAA,KACA,KAAAnI,QAAA,UAAAV,UAAA,CAAAC,GAAA;UACA,MAAAmQ,UAAA,GACA,KAAA3P,QAAA,IACA,KAAA0P,WAAA,CAAAtD,CAAA,EAAAhE,CAAA,KACA,KAAAnI,QAAA,UAAAV,UAAA,CAAAE,MAAA;;UAEA;UACA,IACAgQ,OAAA,IACA,CAAAE,UAAA,KACA,KAAA1S,YAAA,CAAAuI,GAAA,CAAAG,IAAA,CAAArH,OAAA,OACA,KAAAnB,QAAA,CAAAqI,GAAA,CAAAG,IAAA,CAAArH,OAAA,MACA;YACA;YACA,IAAAzD,IAAA,GAAArC,iBAAA,CAAAwG,SAAA;YACA,IAAAyQ,OAAA;cACA5U,IAAA,QAAAkE,gBAAA;YACA;cACAlE,IAAA,QAAAoC,YAAA,CAAAuI,GAAA,CAAAG,IAAA,CAAArH,OAAA,MACA9F,iBAAA,CAAAwG,SAAA,GACAxG,iBAAA,CAAA8V,SAAA;YACA;YAEA,IAAAgB,aAAA,IAAAF,oBAAA,CAAAhH,CAAA;cACA,IAAAgH,oBAAA,CAAAhH,CAAA,EAAAkH,aAAA,EAAAzU,IAAA,KAAAA,IAAA;gBACA;gBACAuU,oBAAA,CAAAhH,CAAA,EAAAkH,aAAA,EAAAM,WAAA;cACA;gBACA;gBACAR,oBAAA,CAAAhH,CAAA,EAAAnF,IAAA;kBACAuB,WAAA,EAAAoB,IAAA,CAAApB,WAAA;kBACAoL,WAAA;kBACA/U;gBACA;gBACAyU,aAAA;cACA;YACA;cACA;cACAF,oBAAA,CAAAhH,CAAA,EAAAnF,IAAA;gBACAuB,WAAA,EAAAoB,IAAA,CAAApB,WAAA;gBACAoL,WAAA;gBACA/U;cACA;YACA;UACA,WAAAyU,aAAA,IAAAF,oBAAA,CAAAhH,CAAA;YACA;YACAkH,aAAA;UACA;QACA;QACA,SAAAlD,CAAA,MAAAA,CAAA,QAAApB,UAAA,IAAA/G,MAAA,IAAAmI,CAAA;UACAmD,6BAAA,MAAAvE,UAAA,IAAAoB,CAAA,GAAAA,CAAA;QACA;QACA,IAAAkD,aAAA,IAAAF,oBAAA,CAAAhH,CAAA;UACAkH,aAAA;QACA;QACA,SAAAlD,CAAA,MAAAA,CAAA,QAAApB,UAAA,IAAA/G,MAAA,IAAAmI,CAAA;UACAmD,6BAAA,CACA,KAAAvE,UAAA,IAAAoB,CAAA,GACAA,CAAA,QAAApB,UAAA,IAAA/G,MACA;QACA;MACA;MACA,OAAAmL,oBAAA;IACA;IAEA;IACAS,8BAAA;MACA,YAAAzF,WAAA,CAAAnG,MAAA,aAAA6L,4BAAA;IACA;IACAC,oBAAA;MACA,OACA,MAAA5T,yBAAA,IACA,KAAAZ,yBAAA,KACA,KAAAkH,OAAA,UAAAA,OAAA,UAAAkL,gBAAA;IAEA;IAEA;IACAqC,cAAA;MACA,MAAAC,OAAA;MACA,IAAAC,iBAAA;MACA,SAAAzK,CAAA,MAAAA,CAAA,QAAAS,IAAA,CAAAjC,MAAA,IAAAwB,CAAA;QACAwK,OAAA,CAAAhN,IAAA,CAAAiN,iBAAA;QACA,UAAAhK,IAAA,CAAAT,CAAA,EAAAyB,aAAA;UACAgJ,iBAAA,SAAAvQ,eAAA;QACA;QACAuQ,iBAAA,SAAArQ,QAAA,CAAAC,KAAA;MACA;MACA,OAAAmQ,OAAA;IACA;EACA;EACAE,OAAA;IACA,GAAArX,YAAA;IACA,GAAAC,UAAA;IAEA;IACA;IACA;;IAEA;IACAqX,0BAAAhJ,QAAA,EAAA5C,WAAA;MACA,OAAAzN,kBAAA,MAAAmP,IAAA,CAAAkB,QAAA,EAAA/B,UAAA,EAAAb,WAAA;IACA;IACA;IACAgL,kBAAA9R,GAAA,EAAAC,GAAA;MACA,SAAA/C,KAAA,CAAAqK,QAAA;QACA,MAAAI,UAAA,QAAA6C,SAAA,CAAAxK,GAAA,OAAAC,GAAA,GAAA0H,UAAA;QACA,KAAAA,UAAA;QACA,WAAAhH,IAAA,CAAAgH,UAAA;MACA;QACA,YAAAgL,uBAAA,CACA,KAAApI,cAAA,QAAA9G,IAAA,GAAAxD,GAAA,EACAD,GACA;MACA;IACA;IACA4S,iBAAA3S,GAAA;MACA,OAAA1C,OAAA,MAAAiL,IAAA,CAAAvI,GAAA,GAAAuJ,aAAA;IACA;IACA;IACAmJ,wBAAAjJ,QAAA,EAAAmJ,SAAA;MACA,MAAAC,cAAA,QAAAxF,UAAA,IAAA/G,MAAA;MACA,MAAAwM,YAAA,GAAAF,SAAA,QAAAvF,UAAA,IAAA/G,MAAA;MACA,MAAA2B,IAAA,GAAA6K,YAAA,GACA,KAAAzF,UAAA,IAAAuF,SAAA,IACA,KAAAvF,UAAA,IAAAuF,SAAA,QAAAvF,UAAA,IAAA/G,MAAA;MACA,IAAAyM,gBAAA,GAAAtJ,QAAA;MACA,IAAAoJ,cAAA;QACA,IAAAC,YAAA;UACAC,gBAAA,GAAAtJ,QAAA;QACA,WAAAA,QAAA,UAAAjC,OAAA,CAAAlB,MAAA;UACA;QACA;MACA;MACA,MAAAiB,GAAA,QAAAC,OAAA,CAAAuL,gBAAA;MACA,KAAAxL,GAAA,KAAAU,IAAA;MACA,IAAAV,GAAA,CAAA6C,YAAA;QACA;MACA;MAEA,MAAApC,IAAA,GAAA5O,kBAAA,CAAAmO,GAAA,CAAAG,UAAA,EAAAO,IAAA,CAAApB,WAAA;MACA,SAAAgC,eAAA;QACA;QACA,IACA,KAAAxJ,KAAA,UAAAT,MAAA,CAAAQ,kBAAA,IACA,KAAAnC,KAAA,CAAAiL,KAAA,EAAA5B,MAAA,MACA;UACA,UAAAkI,gBAAA,CAAA3G,GAAA,CAAAG,IAAA,CAAArH,OAAA;YACA;UACA;QACA;MACA;QACA;QACA,IAAAsH,IAAA,CAAApB,WAAA,QAAAoB,IAAA,CAAApB,WAAA,SAAA5J,KAAA,CAAA2M,QAAA;UACA;QACA;MACA;MACA,OAAA5B,IAAA;IACA;IACA;;IAEA;IACA;IACA;IACAgL,oBAAAC,CAAA,EAAAlO,EAAA;MACA,SAAA3E,cAAA,CAAAkG,MAAA;QACA,SAAAjH,KAAA,UAAAwM,YAAA;UACA,KAAAxM,KAAA,QAAAT,MAAA,CAAAE,mBAAA;QACA;QAEA,KAAAqB,aAAA,GAAA4E,EAAA;MACA;IACA;IACAmO,qBAAAD,CAAA;MACA,SAAA7S,cAAA,CAAAkG,MAAA;QACA,SAAAjH,KAAA,UAAAT,MAAA,CAAAE,mBAAA;UACA,KAAAO,KAAA,QAAAwM,YAAA;QACA;QAEA,KAAA1L,aAAA;MACA;IACA;IACAgT,gBAAAF,CAAA,EAAAlO,EAAA;MACA,KAAA1F,KAAA,QAAAT,MAAA,CAAAG,mBAAA;MACA,KAAAoB,aAAA;MAEA,SAAAgG,iBAAA,CAAA0B,GAAA,CAAA9C,EAAA;QACA;QACA,KAAA3E,cAAA,QAAAA,cAAA,CAAAuH,MAAA,CAAAC,CAAA,IAAAA,CAAA,IAAA7C,EAAA;;QAEA;QACA,SAAA3E,cAAA,CAAAkG,MAAA;UACA,KAAAjH,KAAA,QAAAwM,YAAA;QACA;MACA;QACA;QACA,KAAAzL,cAAA,CAAAkF,IAAA,CAAAP,EAAA;MACA;MAEAkO,CAAA,CAAAG,eAAA;IACA;IACAC,oBAAAJ,CAAA;MACA;MACA;MACA,IACAA,CAAA,EAAAK,MAAA,EAAAC,sBAAA,EAAAxO,EAAA,iCACAkO,CAAA,EAAAK,MAAA,EAAAE,UAAA,EAAAA,UAAA,EAAAzO,EAAA,iCACAkO,CAAA,EAAAK,MAAA,EAAAG,SAAA,EAAAC,QAAA;MAAA,EAEA;MAEA,SAAArU,KAAA,UAAAT,MAAA,CAAAG,mBAAA;QACA,KAAAM,KAAA,QAAAwM,YAAA;MACA;MAEA,KAAAzL,cAAA;;MAEA;MACA,KAAAH,gBAAA;MACA,KAAA0T,gBAAA;IACA;IAEA3G,QAAAJ,IAAA;MACA,OAAAA,IAAA,CAAA1G,GAAA,IAAA0G,IAAA,CAAAgH,SAAA;IACA;IACA;;IAEA;IACA;IACA;;IAEA;IACAC,eAAA;MACA,SAAA5V,YAAA;QACA,KAAAqC,gBAAA,QAAArD,KAAA,CAAAgJ,SAAA;QACA;MACA;MAEA,IAAA6N,OAAA,EAAAC,OAAA;MACA,SAAA9W,KAAA,CAAAC,IAAA,KAAAnC,UAAA,CAAA+K,KAAA;QACA,SAAA7I,KAAA,CAAA8K,KAAA,CAAAzB,MAAA;UACA;UACAwN,OAAA,OAAApT,IAAA,MAAAzD,KAAA,CAAA8K,KAAA;UACAgM,OAAA,OAAArT,IAAA,MAAAzD,KAAA,CAAA8K,KAAA,MAAA9K,KAAA,CAAA8K,KAAA,CAAAzB,MAAA;UACAyN,OAAA,CAAAhL,OAAA,CAAAgL,OAAA,CAAA/K,OAAA;;UAEA;UACA8K,OAAA,GAAAja,aAAA,CACA,KAAAoD,KAAA,CAAA8K,KAAA,EACA+L,OAAA,EACA,KAAAjW,UAAA,EACA,IACA;UACAkW,OAAA,GAAAla,aAAA,CACA,KAAAoD,KAAA,CAAA8K,KAAA,EACAgM,OAAA,EACA,KAAAlW,UAAA,EACA,IACA;QACA;MACA;QACA,SAAA2J,OAAA,CAAAlB,MAAA;UACA;UACAwN,OAAA,OAAApT,IAAA,MAAA8G,OAAA,IAAAE,UAAA;UACAqM,OAAA,OAAArT,IAAA,MAAA8G,OAAA,MAAAA,OAAA,CAAAlB,MAAA,MAAAoB,UAAA;UACAqM,OAAA,CAAAhL,OAAA,CAAAgL,OAAA,CAAA/K,OAAA;QACA;MACA;MAEA,KAAA8K,OAAA,KAAAC,OAAA;;MAEA;MACA,MAAAC,GAAA,cACA,KAAA/W,KAAA,CAAAiJ,GACA,sBAAA4N,OAAA,CAAAG,WAAA,cAAAF,OAAA,CAAAE,WAAA;MACAla,GAAA,CAAAia,GAAA,EACAE,IAAA,CAAAjO,SAAA;QACA,KAAA3F,gBAAA,GAAA2F,SAAA;QACA,KAAAkO,qBAAA;MACA,GACAC,KAAA,CAAAC,GAAA;QACA,KAAAC,SAAA,CACA,oEACA;MACA;IACA;IACA;IACAH,sBAAA;MACA,MAAA1T,WAAA,OAAAC,IAAA,GAAAC,OAAA;MACA,KAAAJ,gBAAA,CAAAC,OAAA;MACA,KAAAD,gBAAA,CAAAE,WAAA,GAAAA,WAAA;MAEA,KAAA8T,OAAA,CACAC,GAAA,CACA,CAAAjM,IAAA,EAAAL,KAAA,EAAAyE,eAAA,EAAArF,QAAA,EAAA3F,YAAA;QACA;QACA,MAAA8S,YAAA,GAAAC,OAAA;UACA,MAAAC,KAAA,GAAA7N,IAAA,CAAAuB,KAAA,CAAAqM,OAAA;UACA,MAAAE,OAAA,GAAA9N,IAAA,CAAAuB,KAAA,EAAAqM,OAAA,GAAAC,KAAA;UACA;YAAAA,KAAA;YAAAC;UAAA;QACA;QACA,MAAAxb,kBAAA,GAAAA,CAAA4O,IAAA,EAAAnB,WAAA;UACA;YAAA8N,KAAA;YAAAC;UAAA,IAAAH,YAAA,CAAA5N,WAAA;UACA,MAAAgO,OAAA,OAAAnU,IAAA,CAAAsH,IAAA;UACA6M,OAAA,CAAAC,QAAA,CAAAD,OAAA,CAAAE,QAAA,KAAAJ,KAAA;UACAE,OAAA,CAAAG,UAAA,CAAAH,OAAA,CAAAI,UAAA,KAAAL,OAAA;UACA,OAAAC,OAAA;QACA;;QAEA;QACA,MAAA9M,KAAA;QACA,IAAAT,QAAA;UACA,WAAAC,GAAA,IAAAgB,IAAA;YACAR,KAAA,CAAAzC,IAAA,CAAAiC,GAAA,CAAAG,UAAA;UACA;QACA;UACA,WAAAH,GAAA,IAAAgB,IAAA;YACA,WAAAN,IAAA,IAAAC,KAAA;cACA;cACA,MAAAF,IAAA,GAAA5O,kBAAA,CACAmO,GAAA,CAAAG,UAAA,EACAO,IAAA,CAAApB,WACA;cACAkB,KAAA,CAAAzC,IAAA,CAAA0C,IAAA;YACA;UACA;QACA;;QAEA;QACA,MAAAkN,SAAA,OAAArU,GAAA;QACA,WAAAmH,IAAA,IAAAD,KAAA;UACAmN,SAAA,CAAAvJ,GAAA,CAAA3D,IAAA,CAAArH,OAAA,QAAApB,GAAA;;UAEA;UACA,WAAA4H,QAAA,IAAAhK,MAAA,CAAAuP,MAAA,CAAAC,eAAA;YACA;YACA,IACAxF,QAAA,CAAA7H,YAAA,EAAAuI,GAAA,CAAAG,IAAA,CAAArH,OAAA,OACAwG,QAAA,CAAA3H,QAAA,EAAAqI,GAAA,CAAAG,IAAA,CAAArH,OAAA,QAAAgB,YAAA,EACA;cACAuT,SAAA,CAAAnb,GAAA,CAAAiO,IAAA,CAAArH,OAAA,IAAA2I,GAAA,CAAAnC,QAAA,CAAAyF,IAAA,CAAA1G,GAAA;cACA;YACA;UACA;QACA;QACA,OAAAgP,SAAA;MACA,GACA,CACA,KAAA1N,OAAA,EACA,KAAAU,KAAA,EACA,KAAAyE,eAAA,EACA,KAAA1P,KAAA,CAAAqK,QAAA,EACA,KAAA3F,YAAA,CAEA,EACAuS,IAAA,CAAAgB,SAAA;QACA;QACA,IAAAzU,WAAA,SAAAF,gBAAA,CAAAE,WAAA;UACA,KAAAG,kBAAA,GAAAsU,SAAA;QACA;MACA,GACAC,OAAA;QACA,SAAA5U,gBAAA,CAAAE,WAAA,KAAAA,WAAA;UACA,KAAAF,gBAAA,CAAAC,OAAA;QACA;MACA;IACA;IACA;IACA2H,6BAAAH,IAAA,EAAAnB,WAAA;MACA,MAAA4D,CAAA,GAAArR,kBAAA,CAAA4O,IAAA,EAAAnB,WAAA;MACA,YAAAjG,kBAAA,CAAA7G,GAAA,CAAA0Q,CAAA,CAAA9J,OAAA,WAAApB,GAAA;IACA;IACA6V,iBAAArV,GAAA,EAAAC,GAAA;MACA,SAAAX,KAAA,UAAAT,MAAA,CAAAK,iBAAA,SAAAxF,OAAA;QACA;QACA;MACA;;MAEA;MACA,KAAAqG,WAAA;QAAAC,GAAA;QAAAC;MAAA;MAEA,SAAAX,KAAA,UAAAT,MAAA,CAAAK,iBAAA,SAAAkB,aAAA;QACA;QACA;MACA;MAEA,MAAA6H,IAAA,QAAA6J,iBAAA,CAAA9R,GAAA,EAAAC,GAAA;MACA,KAAAgI,IAAA;;MAEA;MACA,MAAAqN,SAAA,QAAAzU,kBAAA,CAAA7G,GAAA,CAAAiO,IAAA,CAAArH,OAAA,WAAApB,GAAA;MACA,WAAA+V,UAAA,SAAA7I,WAAA;QACA,IAAA4I,SAAA,CAAAxN,GAAA,CAAAyN,UAAA,CAAApP,GAAA;UACA,KAAAhG,uBAAA,CAAAoV,UAAA,CAAApP,GAAA;QACA;UACA,KAAAhG,uBAAA,CAAAoV,UAAA,CAAApP,GAAA;QACA;MACA;IACA;IACA;;IAEA;IACA;IACA;IACA,MAAAX,gBAAA;MACA,KAAA3B,oBAAA;MACA,MAAA7J,GAAA,kBAAAma,IAAA,CAAAvP,QAAA;QACA,KAAA4Q,WAAA,CAAA5Q,QAAA;MACA;IACA;IACA;IACA6Q,yBAAA;MACA,SAAAvY,KAAA,CAAAC,IAAA,KAAAnC,UAAA,CAAA+K,KAAA;QACA,KAAA2P,0BAAA;QACA,KAAA3R,kBAAA;MACA;MAEA,KAAAxE,YAAA,OAAAC,GAAA;MACA,KAAAC,QAAA,OAAAD,GAAA;MACA,SAAAyQ,gBAAA;QACA,KAAA0F,wBAAA,MAAA/Q,QAAA,CAAAuB,GAAA;MACA;IACA;IACA;IACAwP,yBAAA3Q,EAAA;MACA,KAAAzF,YAAA,GACA,IAAAC,GAAA,MAAAoN,eAAA,CAAA5H,EAAA,GAAAzF,YAAA,SAAAC,GAAA;MACA,KAAAC,QAAA,OAAAD,GAAA,MAAAoN,eAAA,CAAA5H,EAAA,GAAAvF,QAAA,SAAAD,GAAA;MACA,KAAAoW,SAAA,YAAA9V,cAAA;IACA;IACA;IACA+V,2BAAAC,SAAA;MACA,OACAA,SAAA,CAAAhP,WAAA,SAAAwG,UAAA,OAAAxG,WAAA,IACAgP,SAAA,CAAAhP,WAAA,IACA,KAAAwG,UAAA,SAAAA,UAAA,IAAA/G,MAAA,MAAAO,WAAA;IAEA;IACA;IACAiP,kBAAAD,SAAA;MACA,MAAA3I,KAAA;MACA,MAAA2F,cAAA,QAAAxF,UAAA,IAAA/G,MAAA;MACA,KAAAuM,cAAA,SAAA+C,0BAAA,CAAAC,SAAA;QACA3I,KAAA,CAAAC,GAAA,WACA0I,SAAA,CAAAhP,WAAA,QAAAwG,UAAA,OAAAxG,WACA,WAAA5E,WAAA;QACAiL,KAAA,CAAA9K,MAAA,WAAAyT,SAAA,CAAA5D,WAAA,WAAAhQ,WAAA;MACA;QACAiL,KAAA,CAAAC,GAAA,gBAAAE,UAAA,IAAA/G,MAAA,MACA,KAAAiH,cACA,aAAAxL,gBAAA,QACA8T,SAAA,CAAAhP,WAAA,QAAAwG,UAAA,OAAAxG,WACA,WAAA5E,WAAA;QACAiL,KAAA,CAAA9K,MAAA,WAAAyT,SAAA,CAAA5D,WAAA,WAAAhQ,WAAA;MACA;MACA,OAAAiL,KAAA;IACA;IACA;IACAW,kCAAA;MACAnJ,mBAAA;MACAoJ,0BAAA;MAAA;MACAJ,yBAAA;MAAA;MACAE,qBAAA;MAAA;MACAG,eAAA,GAAAjT,uBAAA;IACA;MACA,MAAAwE,YAAA,OAAAC,GAAA;MAEA,SAAAuI,CAAA,MAAAA,CAAA,QAAAN,OAAA,CAAAlB,MAAA,IAAAwB,CAAA;QACA,MAAAP,GAAA,QAAAC,OAAA,CAAAM,CAAA;QACA,MAAAE,IAAA,GAAAT,GAAA,CAAAG,UAAA;QAEA,IAAAoG,0BAAA;UACA,MAAAiI,OAAA,GAAA3c,kBAAA,CACA4O,IAAA,EACA,KAAAE,KAAA,CAAA5B,MAAA,SAAA4I,gBAAA,MACA;;UAEA;UACA,IAAA8G,uBAAA;UAEA,WAAA/N,IAAA,IAAA2F,qBAAA;YACA,IAAA5F,IAAA,CAAArH,OAAA,MAAAsH,IAAA,IAAAA,IAAA,IAAA8N,OAAA,CAAApV,OAAA;cACAiN,qBAAA,CAAA3F,IAAA,EAAAyJ,OAAA,CAAAxD,CAAA;gBACA5O,YAAA,CAAAgK,GAAA,KAAA5I,IAAA,CAAAwN,CAAA,EAAAvN,OAAA;cACA;cACA,OAAAiN,qBAAA,CAAA3F,IAAA;cACA+N,uBAAA;cACA;YACA;UACA;UAEA,IAAAA,uBAAA;UAEA,WAAA/N,IAAA,IAAAyF,yBAAA;YACA,IAAA1F,IAAA,CAAArH,OAAA,MAAAsH,IAAA,IAAAA,IAAA,IAAA8N,OAAA,CAAApV,OAAA;cACA+M,yBAAA,CAAAzF,IAAA,EAAAyJ,OAAA,CAAAxD,CAAA;gBACA5O,YAAA,CAAAgK,GAAA,KAAA5I,IAAA,CAAAwN,CAAA,EAAAvN,OAAA;cACA;cACA,OAAA+M,yBAAA,CAAAzF,IAAA;cACA+N,uBAAA;cACA;YACA;UACA;UAEA,IAAAA,uBAAA;QACA;;QAEA;QACA,MAAAC,cAAA,GAAAlI,eAAA,CAAAxM,UAAA,CAAAyD,OAAA,GACA+I,eAAA,CAAAxM,UAAA,CAAA0G,IAAA,eACA;;QAEA;QACA,MAAAiO,eAAA,GAAAvb,mBAAA,CACAoT,eAAA,CAAAvM,YAAA,CAAA8G,SACA;QACA,MAAA6N,aAAA,GAAA1b,gBAAA,CAAAC,mBAAA,CAAAsN,IAAA;QACA,MAAAoO,qBAAA,GAAA/Z,KAAA,CACAwT,EAAA,IAAAsG,aAAA,IAAAD,eAAA,SAAAzT,WAAA,CAAAqN,KAAA,EACAuG,MAAA;QACA,IAAAzM,QAAA,GACAmE,eAAA,CAAAvM,YAAA,CAAA8U,OAAA,GACAvI,eAAA,CAAAvM,YAAA,CAAA8G,SAAA;QACA,IAAAsB,QAAA,OAAAA,QAAA;QACA,MAAA2M,mBAAA,GAAAnd,kBAAA,CACAgd,qBAAA,EACAxM,QACA;QAEA,SAAA4M,CAAA,MAAAA,CAAA,QAAAtO,KAAA,CAAA5B,MAAA,IAAAkQ,CAAA;UACA,MAAAC,SAAA,QAAA/D,uBAAA,CAAA5K,CAAA,EAAA0O,CAAA;UACA,KAAAC,SAAA;UACA,MAAAV,OAAA,GAAA3c,kBAAA,CACAqd,SAAA,EACA,KAAAvH,gBAAA,KACA;;UAEA;UACA,IAAAnB,eAAA,CAAAvM,YAAA,CAAAwD,OAAA;YACA,IACA+Q,OAAA,CAAApV,OAAA,MAAAyV,qBAAA,CAAAzV,OAAA,MACA8V,SAAA,CAAA9V,OAAA,MAAA4V,mBAAA,CAAA5V,OAAA,IACA;cACA;YACA;UACA;;UAEA;UACA,MAAAuE,KAAA,GAAAR,mBAAA,CAAAoD,CAAA,GAAA4O,SAAA,CAAAzD,CAAA;YACA,MAAA0D,iBAAA,OAAAjW,IAAA,CACAuS,CAAA,CAAAwD,SAAA,CAAA9V,OAAA,KAAAsV,cACA;YACA,MAAAW,eAAA,OAAAlW,IAAA,CACAuS,CAAA,CAAA8C,OAAA,CAAApV,OAAA,KAAAsV,cACA;YAEA,MAAAY,YAAA,GACA1d,WAAA,CAAA4c,OAAA,EAAAY,iBAAA,UACAxd,WAAA,CAAAsd,SAAA,EAAAG,eAAA;YACA,QAAAC,YAAA,KAAA5D,CAAA,CAAA6D,IAAA;UACA;UACA,IAAA5R,KAAA;YACA5F,YAAA,CAAAgK,GAAA,CAAAmN,SAAA,CAAA9V,OAAA;UACA;QACA;MACA;MACA,OAAArB,YAAA;IACA;IACA;IACAyX,6BAAA;MACA;MACA,KAAAzX,YAAA,OAAAC,GAAA;MACA,MAAAyX,eAAA,QAAAnJ,iCAAA;QACAnJ,mBAAA,OAAAA,mBAAA;QACAqJ,eAAA;UACAxM,UAAA,OAAAA,UAAA;UACAC,YAAA,OAAAA;QACA;MACA;MAEA,MAAAyV,aAAA,GAAAjd,gBAAA,CACA,IAAA0G,IAAA,MAAAzD,KAAA,CAAA8K,KAAA,MACA,KAAAvE,IAAA,QAAA8G,cACA;MACA,MAAA4M,WAAA,GAAAld,gBAAA,CAAAid,aAAA,OAAA3M,cAAA;MACA,KAAA6M,mBAAA,CAAAH,eAAA,EAAAC,aAAA,EAAAC,WAAA;IACA;IACA;IACAC,oBAAA7X,YAAA,EAAAmX,SAAA,EAAAV,OAAA;MACA,KAAApW,uBAAA;MACA,KAAAD,wBAAA;MAEA,IAAA0X,UAAA;MACA,IAAAC,cAAA;MACA,IACA/X,YAAA,CAAAiP,IAAA,GAAA8I,cAAA,GAAAD,UAAA,GACA,KAAAxX,WAAA,EACA;QACAyX,cAAA,GAAA/X,YAAA,CAAAiP,IAAA,GAAA6I,UAAA,QAAAxX,WAAA;MACA;MACA,IAAAyE,iBAAA,OAAA/E,YAAA;MACA+E,iBAAA,GAAAA,iBAAA,CAAAsD,MAAA,CAAAuG,CAAA,IACAjU,aAAA,CAAAiU,CAAA,EAAAuI,SAAA,EAAAV,OAAA,CACA;MAEA,SAAAjO,CAAA,MAAAA,CAAA,GAAAzD,iBAAA,CAAAiC,MAAA,GAAA+Q,cAAA,QAAAvP,CAAA;QACA,MAAAwP,OAAA,GAAAC,UAAA;UACA,WAAArJ,CAAA,IAAA7J,iBAAA,CAAAgG,KAAA,CACAvC,CAAA,GAAAuP,cAAA,EACAvP,CAAA,GAAAuP,cAAA,GAAAA,cACA;YACA,KAAA/X,YAAA,CAAAgK,GAAA,CAAA4E,CAAA;UACA;UACA,KAAA5O,YAAA,OAAAC,GAAA,MAAAD,YAAA;UACA,IAAAwI,CAAA,IAAAzD,iBAAA,CAAAiC,MAAA,GAAA+Q,cAAA;YACA;YACA,KAAA/X,YAAA,OAAAC,GAAA,CAAAD,YAAA;YACA,KAAAI,wBAAA,CAAA4F,IAAA,CACAiS,UAAA;cACA,KAAA5X,uBAAA;cAEA,SAAAxB,YAAA;gBACA,KAAAqZ,QAAA;cACA;cACA,KAAA3X,cAAA;YACA,OACA;UACA;QACA,GAAAiI,CAAA,GAAAsP,UAAA;QAEA,KAAA1X,wBAAA,CAAA4F,IAAA,CAAAgS,OAAA;MACA;IACA;IACAG,qBAAA;MACA,WAAAH,OAAA,SAAA5X,wBAAA;QACAgY,YAAA,CAAAJ,OAAA;MACA;MACA,KAAA3X,uBAAA;IACA;IACA,MAAAgY,mBAAAC,YAAA;MAAA7a,IAAA;MAAA8a,KAAA;IAAA;MACA,IAAAC,OAAA;MAEA,IAAA5a,IAAA;MACA;MACA,SAAA4H,OAAA;QACA5H,IAAA;QACA4a,OAAA,GAAA5d,+BAAA,MAAAmG,sBAAA;QACAyX,OAAA,CAAAhU,kBAAA;QACA,WAAAyD,GAAA,IAAApK,MAAA,CAAAiR,IAAA,MAAAtK,kBAAA;UACAgU,OAAA,CAAAhU,kBAAA,CAAAyD,GAAA,KACA,QAAAzD,kBAAA,CAAAyD,GAAA,EACA,CAAAjD,GAAA,CAAA4J,CAAA,QAAAxN,IAAA,CAAAwN,CAAA;QACA;QACA4J,OAAA,CAAA/J,eAAA;UACAxM,UAAA,OAAAA,UAAA;UACAC,YAAA,OAAAA;QACA;MACA;QACAtE,IAAA;QACA4a,OAAA,CAAAxY,YAAA,QAAA+E,iBAAA;QACAyT,OAAA,CAAAtY,QAAA,QAAAgF,aAAA;QACA,SAAAG,QAAA,UAAAnG,yBAAA;UACAsZ,OAAA,CAAAC,KAAA;QACA;UACAD,OAAA,CAAAC,KAAA;UACAD,OAAA,CAAA/a,IAAA,GAAA6a,YAAA,CAAA7a,IAAA;UACA+a,OAAA,CAAAD,KAAA,GAAAD,YAAA,CAAAC,KAAA;UACA3W,YAAA,MAAA+M,YAAA,IAAA2J,YAAA,CAAA7a,IAAA;QACA;MACA;MAEA,MAAA1D,IAAA,iBAAA4D,KAAA,CAAAiJ,GAAA,aAAA4R,OAAA;;MAEA;MACA,MAAAE,kBAAA,QAAAxT,aAAA,CAAA8B,MAAA;MACA,SAAA3B,QAAA;QACA,SAAAA,QAAA,CAAAuB,GAAA,SAAAyG,eAAA;UACA,KAAAsL,QAAA,EAAAC,OAAA,WAAAhb,IAAA;YACAib,OAAA,OAAAlb,KAAA,CAAAiJ,GAAA;YACA8R;UACA;QACA;UACA,KAAAC,QAAA,EAAAC,OAAA,UAAAhb,IAAA;YACAib,OAAA,OAAAlb,KAAA,CAAAiJ,GAAA;YACA8R,kBAAA;YACA;YACAzW,UAAA,OAAAA,UAAA,CAAA0G,IAAA;YACAmQ,gBAAA,OAAA7W,UAAA,CAAAyD,OAAA;YACAqT,mBAAA,OAAA7W,YAAA,CAAAwD,OAAA;YACAsT,qBAAA,OAAA9W,YAAA,CAAA8G,SAAA;YACAiQ,mBAAA,OAAA/W,YAAA,CAAA8U;UACA;QACA;MACA;QACA,IAAAsB,YAAA,CAAA7a,IAAA,SAAA4P,eAAA;UACA,KAAAsL,QAAA,EAAAC,OAAA,WAAAhb,IAAA;YACAib,OAAA,OAAAlb,KAAA,CAAAiJ,GAAA;YACA8R;UACA;QACA;UACA,KAAAC,QAAA,EAAAC,OAAA,UAAAhb,IAAA;YACAib,OAAA,OAAAlb,KAAA,CAAAiJ,GAAA;YACA8R;UACA;QACA;MACA;MAEA,KAAAQ,YAAA;MACA,KAAA3Y,cAAA;IACA;IACA,MAAA4Y,sBAAA;MACA,IACA,KAAAzX,sBAAA,CAAAqF,IAAA,GAAAC,MAAA,GACA,KAAAvF,iBAAA,CAAAsF,IAAA,GAAAC,MAAA,KACA,GACA;QACA,KAAAgO,SAAA;QACA;MACA;MAEA,SAAAxM,CAAA,MAAAA,CAAA,QAAA9G,sBAAA,CAAAsF,MAAA,IAAAwB,CAAA;QACA,KAAA/G,iBAAA,CAAA+G,CAAA,SAAA/G,iBAAA,CAAA+G,CAAA,EAAA4Q,MAAA,CACA,KAAA1X,sBAAA,CAAA8G,CAAA,CACA;QACA,KAAA9G,sBAAA,CAAA8G,CAAA;MACA;MAEA,MAAAgQ,OAAA;QACA/a,IAAA,OAAAE,KAAA,CAAAF,IAAA;QACA6M,QAAA,OAAA3M,KAAA,CAAA2M,QAAA;QACA7B,KAAA,OAAA9K,KAAA,CAAA8K,KAAA;QACA7K,IAAA,OAAAD,KAAA,CAAAC,IAAA;QACAyb,YAAA,OAAA5X,iBAAA,CAAAsF,IAAA,GAAA/B,GAAA,CAAAsC,KAAA;UACA;YACAV,GAAA,EAAAU,KAAA,CAAAV,GAAA;YACAnJ,IAAA,EAAA6J,KAAA,CAAA7J,IAAA;YACA6b,QAAA,EAAAhS,KAAA,CAAAgS,QAAA;YACAnC,SAAA,EAAA7P,KAAA,CAAA6P,SAAA;YACAV,OAAA,EAAAnP,KAAA,CAAAmP;UACA;QACA;MACA;MAEAzc,GAAA,iBAAA2D,KAAA,CAAAiJ,GAAA,IAAA4R,OAAA,EACA5D,IAAA;QACA;MAAA,CACA,EACAE,KAAA,CAAAC,GAAA;QACAwE,OAAA,CAAAC,KAAA,CAAAzE,GAAA;QACA,KAAAC,SAAA,CACA,iEACA;MACA;MAEA;IACA;IAEA,MAAAyE,mBAAAhc,IAAA;MACA,MAAA+a,OAAA;MACA,SAAAnT,QAAA,UAAAnG,yBAAA;QACAsZ,OAAA,CAAAC,KAAA;QACAD,OAAA,CAAA9R,MAAA,QAAArB,QAAA,CAAAuB,GAAA;QAEA,KAAA+R,QAAA,EAAAC,OAAA;UACAC,OAAA,OAAAlb,KAAA,CAAAiJ;QACA;MACA;QACA4R,OAAA,CAAAC,KAAA;QACAD,OAAA,CAAA/a,IAAA,GAAAA,IAAA;QAEA,KAAAkb,QAAA,EAAAC,OAAA;UACAC,OAAA,OAAAlb,KAAA,CAAAiJ,GAAA;UACAnJ;QACA;MACA;MACA,MAAAjD,OAAA,iBAAAmD,KAAA,CAAAiJ,GAAA,aAAA4R,OAAA;MACA,KAAAxY,YAAA,OAAAC,GAAA;MACA,SAAAuF,OAAA,OAAAkU,OAAA,CAAAC,OAAA;QAAAlc,IAAA;MAAA,QACA,KAAAyb,YAAA;IACA;IACA;;IAEA;IACA;IACA;IACAU,gBAAA;MACA;MACA,MAAAC,UAAA,GAAAC,QAAA,CAAAC,aAAA;MACA,IAAAF,UAAA;QACA;QAAA;UAAAhX,KAAA,OAAAD,QAAA,CAAAC,KAAA;UAAAC,MAAA,OAAAF,QAAA,CAAAE;QAAA,IACA+W,UAAA,CAAAG,qBAAA;MACA;IACA;IACA;IACArI,0BAAA1J,GAAA,EAAAU,IAAA,EAAAwC,CAAA,EAAAgE,CAAA;MACA,MAAA1O,GAAA,GAAA0O,CAAA;MACA,MAAAzO,GAAA,GAAAyK,CAAA;MACA,MAAAzC,IAAA,QAAA6J,iBAAA,CAAA9R,GAAA,EAAAC,GAAA;MACA,MAAAuZ,UAAA,QAAAC,qBAAA,CAAAxR,IAAA,EAAAjI,GAAA,EAAAC,GAAA;;MAEA;MACA,MAAA8S,YAAA,GAAArE,CAAA,QAAApB,UAAA,IAAA/G,MAAA;MACA,MAAAmT,UAAA,IAAAzR,IAAA;;MAEA;MACA,SAAA5J,qBAAA,SAAAuB,uBAAA;QACA4Z,UAAA,CAAAG,KAAA;MACA;;MAEA;MACAH,UAAA,CAAArM,KAAA,CAAA9K,MAAA,WAAAmL,cAAA;;MAEA;MACA,IACA,MAAAd,WAAA,CAAAnG,MAAA,QACA,KAAAwF,OAAA,IACA,KAAAzM,KAAA,UAAAT,MAAA,CAAAQ,kBAAA,KACA,KAAAU,WAAA,CAAAC,GAAA,KAAAA,GAAA,IACA,KAAAD,WAAA,CAAAE,GAAA,KAAAA,GAAA,IACA,CAAAyZ,UAAA,EACA;QACA;QACAF,UAAA,CAAAG,KAAA,IACA;MACA;QACA;QACA,IAAA1R,IAAA;UACA,MAAAoB,SAAA,OAAA1I,IAAA,CACAsH,IAAA,CAAArH,OAAA,UAAAiF,cAAA,YACA;UACA,MAAA+T,cAAA,GAAAvQ,SAAA,CAAA6L,UAAA;UACA,IAAA0E,cAAA;YACAJ,UAAA,CAAAG,KAAA;UACA,WAAAC,cAAA;YACAJ,UAAA,CAAAG,KAAA;YACAH,UAAA,CAAArM,KAAA,CAAA0M,cAAA;UACA;QACA;QAEAL,UAAA,CAAAG,KAAA;QACA,IAAA1Z,GAAA,gBAAA2S,gBAAA,CAAA3S,GAAA,GACAuZ,UAAA,CAAAG,KAAA;QACA,IAAA1Z,GAAA,UAAAuI,IAAA,CAAAjC,MAAA,cAAAqM,gBAAA,CAAA3S,GAAA,OACAuZ,UAAA,CAAAG,KAAA;QACA,IAAA5G,YAAA,IAAA/S,GAAA,QACAwZ,UAAA,CAAAG,KAAA;QACA,KAAA5G,YAAA,IAAA/S,GAAA,UAAAsN,UAAA,IAAA/G,MAAA,EACAiT,UAAA,CAAAG,KAAA;QACA,IAAA5G,YAAA,IAAA/S,GAAA,UAAAsN,UAAA,IAAA/G,MAAA,MACAiT,UAAA,CAAAG,KAAA;QACA,IACA,CAAA5G,YAAA,IACA/S,GAAA,UAAAsN,UAAA,IAAA/G,MAAA,QAAA+G,UAAA,IAAA/G,MAAA,MAEAiT,UAAA,CAAAG,KAAA;QAEA,MAAAG,gBAAA,GACA,KAAAxa,KAAA,UAAAT,MAAA,CAAAG,mBAAA,GACA,KAAAqB,cAAA,CAAAkG,MAAA,GACA,KAAAmG,WAAA,CAAAnG,MAAA;QACA,IACA,KAAAjH,KAAA,UAAAT,MAAA,CAAAK,iBAAA,IACA,KAAAI,KAAA,UAAAT,MAAA,CAAAE,mBAAA,IACA+a,gBAAA,QACA;UACAN,UAAA,CAAAG,KAAA;QACA;UACAH,UAAA,CAAAG,KAAA;QACA;MACA;;MAEA;MACA,IAAAD,UAAA;QACAF,UAAA,CAAAG,KAAA,IACA;MACA;;MAEA;MACA,IAAAH,UAAA,CAAArM,KAAA,CAAA4M,eAAA;QACAP,UAAA,CAAArM,KAAA,CAAA4M,eAAA;MACA;MAEA,OAAAP,UAAA;IACA;IACA;IACAC,sBAAAxR,IAAA,EAAAjI,GAAA,EAAAC,GAAA;MACA,IAAA+Z,CAAA;MACA,MAAAC,CAAA;MACA,KAAAhS,IAAA;QAAA0R,KAAA,EAAAK,CAAA;QAAA7M,KAAA,EAAA8M;MAAA;MAEA,MAAAC,mBAAA,GACA,KAAArZ,kBAAA,CAAA7G,GAAA,CAAAiO,IAAA,CAAArH,OAAA,WAAApB,GAAA;;MAEA;;MAEA,SAAA2E,QAAA;QACA6V,CAAA;QACA;UAAAL,KAAA,EAAAK,CAAA;UAAA7M,KAAA,EAAA8M;QAAA;MACA;MAEA,IACA,MAAA1Y,mBAAA,IACA,KAAAjC,KAAA,UAAAT,MAAA,CAAAK,iBAAA,IACA,KAAAI,KAAA,UAAAT,MAAA,CAAAQ,kBAAA,EACA;QACA;QACA4a,CAAA,CAAAF,eAAA;;QAEA;QACA,MAAA/H,WAAA,QAAAA,WAAA,CAAAhS,GAAA,EAAAC,GAAA;QACA,IAAA+R,WAAA;UACA;UACA,SAAAzP,QAAA,UAAAV,UAAA,CAAAC,GAAA;YACA,SAAAxC,KAAA,UAAAT,MAAA,CAAAQ,kBAAA;cACA2a,CAAA;YACA;cACA,SAAA3Y,gBAAA,KAAAvG,iBAAA,CAAAwG,SAAA;gBACA2Y,CAAA,CAAAF,eAAA;cACA,WACA,KAAA1Y,gBAAA,KAAAvG,iBAAA,CAAA8V,SAAA,EACA;gBACAoJ,CAAA;cACA;YACA;UACA,gBAAAzX,QAAA,UAAAV,UAAA,CAAAE,MAAA;YACA,SAAAzC,KAAA,UAAAT,MAAA,CAAAQ,kBAAA;cACA2a,CAAA;YACA;UACA;QACA;UACA;UACA;UACA,SAAA1a,KAAA,UAAAT,MAAA,CAAAQ,kBAAA;YACA,SAAAK,SAAA,CAAAoI,GAAA,CAAAG,IAAA,CAAArH,OAAA;cACAoZ,CAAA;YACA;cACAA,CAAA;YACA;UACA;YACA,SAAAza,YAAA,CAAAuI,GAAA,CAAAG,IAAA,CAAArH,OAAA;cACAqZ,CAAA,CAAAF,eAAA;YACA,gBAAAta,QAAA,CAAAqI,GAAA,CAAAG,IAAA,CAAArH,OAAA;cACAoZ,CAAA;YACA;UACA;QACA;MACA;MAEA,SAAA1a,KAAA,UAAAT,MAAA,CAAAE,mBAAA;QACA;QACA,MAAAwW,UAAA,QAAAnV,aAAA;QACA,IAAA8Z,mBAAA,CAAApS,GAAA,CAAAyN,UAAA;UACA,SAAA3I,eAAA,CAAA2I,UAAA,GAAA9V,QAAA,EAAAqI,GAAA,CAAAG,IAAA,CAAArH,OAAA;YACAoZ,CAAA;UACA;YACAC,CAAA,CAAAF,eAAA;UACA;QACA;UACAE,CAAA,CAAAF,eAAA;QACA;QACA;UAAAJ,KAAA,EAAAK,CAAA;UAAA7M,KAAA,EAAA8M;QAAA;MACA;MAEA,IACA,KAAA1Y,mBAAA,IACA,KAAAjC,KAAA,UAAAT,MAAA,CAAAI,UAAA,IACA,KAAAK,KAAA,UAAAT,MAAA,CAAAC,OAAA,IACA,KAAAQ,KAAA,UAAAT,MAAA,CAAAO,cAAA,IACA,KAAAE,KAAA,UAAAT,MAAA,CAAAG,mBAAA,EACA;QACA,IAAAmb,cAAA;QACA,IAAA7S,GAAA;QAEA,IACA,KAAAhI,KAAA,UAAAT,MAAA,CAAAI,UAAA,IACA,KAAAK,KAAA,UAAAT,MAAA,CAAAC,OAAA,IACA,KAAAQ,KAAA,UAAAT,MAAA,CAAAO,cAAA,EACA;UACA+a,cAAA,GAAAD,mBAAA,CAAA1L,IAAA;UACAlH,GAAA,QAAAA,GAAA;QACA,gBAAAhI,KAAA,UAAAT,MAAA,CAAAG,mBAAA;UACAmb,cAAA,OAAAD,mBAAA,EAAAtS,MAAA,CAAAC,CAAA,IACA,KAAAzB,iBAAA,CAAA0B,GAAA,CAAAD,CAAA,CACA,EAAAtB,MAAA;UAEAe,GAAA,QAAAD,iBAAA;QACA,gBAAA9F,mBAAA;UACA,IACA,MAAA0O,gBAAA,SAAA1R,UAAA,EAAAgI,MAAA,SACA2T,mBAAA,CAAApS,GAAA,MAAAlD,QAAA,EAAAuB,GAAA,SAAA5H,UAAA,GACA;YACA;YACA4b,cAAA,GAAAD,mBAAA,CAAA1L,IAAA;YACAlH,GAAA,QAAAA,GAAA;UACA;YACA6S,cAAA,GAAAD,mBAAA,CAAA1L,IAAA;YACAlH,GAAA,QAAAA,GAAA;UACA;QACA;QAEA,MAAAwS,gBAAA,GACA,KAAAxa,KAAA,UAAAT,MAAA,CAAAG,mBAAA,GACA,KAAAqB,cAAA,CAAAkG,MAAA,GACA,KAAAmG,WAAA,CAAAnG,MAAA;QAEA,SAAAuF,YAAA,UAAAjN,MAAA,CAAAI,UAAA;UACA,IAAAqI,GAAA,QAAA6S,cAAA,KAAA7S,GAAA;YACA;YACA,IAAAwS,gBAAA,eAAAvY,mBAAA;cACA;cACA,MAAA6Y,KAAA;cACAH,CAAA,CAAAF,eAAA,GAAAK,KAAA;YACA;cACA,MAAAA,KAAA;cACAH,CAAA,CAAAF,eAAA,GAAAK,KAAA;YACA;UACA;QACA,gBAAAtO,YAAA,UAAAjN,MAAA,CAAAC,OAAA;UACA,IAAAqb,cAAA;YACA,IAAAL,gBAAA;cACA,MAAAO,YAAA,GACA,KAAA/a,KAAA,UAAAT,MAAA,CAAAG,mBAAA,GACA,KAAAqB,cAAA,MACA,KAAAqM,WAAA,IAAAvG,GAAA;cACA,IACA,KAAAyG,eAAA,CAAAyN,YAAA,GAAA5a,QAAA,EAAAqI,GAAA,CACAG,IAAA,CAAArH,OAAA,EACA,GACA;gBACAoZ,CAAA;cACA;gBACA,MAAAI,KAAA;gBACAH,CAAA,CAAAF,eAAA,GAAAK,KAAA;cACA;YACA;cACA;cACA,MAAAE,IAAA,GAAAH,cAAA,GAAA7S,GAAA;cACA,MAAA8S,KAAA;cACA,IAAAG,KAAA;cACA,UAAAhZ,mBAAA;gBACAgZ,KAAA,GAAAxT,IAAA,CAAAuB,KAAA,CAAAgS,IAAA,eACAE,QAAA,KACAC,WAAA,GACAC,SAAA,OACAC,QAAA;gBACA,IACAL,IAAA,UACA,KAAAja,cAAA,CAAAkG,MAAA,QACAe,GAAA,UAAAjH,cAAA,CAAAkG,MAAA,IACA,KAAAlG,cAAA,CAAAkG,MAAA,UACAe,GAAA,UAAAoF,WAAA,CAAAnG,MAAA,GACA;kBACAgU,KAAA;gBACA;cACA;gBACAA,KAAA,GAAAxT,IAAA,CAAAuB,KAAA,CAAAgS,IAAA,eACAE,QAAA,KACAC,WAAA,GACAC,SAAA,OACAC,QAAA;cACA;cAEAV,CAAA,CAAAF,eAAA,GAAAK,KAAA,GAAAG,KAAA;YACA;UACA,WAAAT,gBAAA;YACA,MAAAc,GAAA;YACAX,CAAA,CAAAF,eAAA,GAAAa,GAAA;UACA;QACA;MACA;MAEA;QAAAjB,KAAA,EAAAK,CAAA;QAAA7M,KAAA,EAAA8M;MAAA;IACA;IACA7I,yBAAAnJ,IAAA,EAAAF,CAAA;MACA,MAAA/H,GAAA,GAAA+G,IAAA,CAAAuB,KAAA,CAAAP,CAAA;MACA,MAAA9H,GAAA,GAAA8H,CAAA;MAEA,IAAAyR,UAAA;MACA;MACA,SAAA/N,gBAAA,CAAAzR,GAAA,CAAAiO,IAAA,CAAArH,OAAA;QACA4Y,UAAA,QAAAC,qBAAA,CAAAxR,IAAA,EAAAjI,GAAA,EAAAC,GAAA;QACA,SAAAX,KAAA,UAAAT,MAAA,CAAAK,iBAAA;UACAsa,UAAA,CAAAG,KAAA;QACA;QAEA,MAAAI,eAAA,GAAAP,UAAA,CAAArM,KAAA,CAAA4M,eAAA;QACA,IACAA,eAAA,IACAzf,WAAA,CAAAC,yBAAA,CAAAwf,eAAA,eACA;UACAP,UAAA,CAAAG,KAAA;QACA;MACA;QACAH,UAAA;UACAG,KAAA;UACAxM,KAAA;QACA;MACA;;MAEA;MACA,IAAAqM,UAAA,CAAArM,KAAA,CAAA4M,eAAA;QACAP,UAAA,CAAArM,KAAA,CAAA4M,eAAA;MACA;;MAEA;MACA;MACA;MACA;;MAEA;MACA,IACA,MAAArN,WAAA,CAAAnG,MAAA,QACA,KAAAjH,KAAA,UAAAT,MAAA,CAAAK,iBAAA,KACA,KAAAa,WAAA,CAAAC,GAAA,KAAAA,GAAA,IACA,KAAAD,WAAA,CAAAE,GAAA,KAAAA,GAAA,IACA,KAAAwL,gBAAA,CAAAzR,GAAA,CAAAiO,IAAA,CAAArH,OAAA,KACA;QACA;QACA4Y,UAAA,CAAAG,KAAA,IACA;MACA;QACA;QACA,IAAA1Z,GAAA,QAAAuZ,UAAA,CAAAG,KAAA;QACAH,UAAA,CAAAG,KAAA;QACA,IAAA1Z,GAAA;UACAuZ,UAAA,CAAArM,KAAA,CAAA0N,gBAAA;QACA;QAEA,IAAA7a,GAAA,QAAAwZ,UAAA,CAAAG,KAAA;QACAH,UAAA,CAAAG,KAAA;QACA,IAAA3Z,GAAA,KAAA+G,IAAA,CAAAuB,KAAA,MAAAkC,SAAA,CAAAjE,MAAA;UACAiT,UAAA,CAAArM,KAAA,CAAA2N,iBAAA;QACA;MACA;MAEA,OAAAtB,UAAA;IACA;IACAjI,eAAAvR,GAAA,EAAAC,GAAA;MACA,SAAA9B,YAAA;QACA;UACA4c,KAAA,EAAAA,CAAA;YACA,SAAA7a,gBAAA;cACA;cACA,IACAF,GAAA,UAAAD,WAAA,CAAAC,GAAA,IACAC,GAAA,UAAAF,WAAA,CAAAE,GAAA,EACA;gBACA,KAAAC,gBAAA;cACA;YACA,WACA,KAAAZ,KAAA,UAAAT,MAAA,CAAAK,iBAAA,KACA,KAAA+Q,gBAAA,SAAAlD,sBAAA,GACA;cACA;cACA,KAAA7M,gBAAA;YACA;YAEA,KAAAmV,gBAAA,CAAArV,GAAA,EAAAC,GAAA;UACA;UACA+a,SAAA,EAAAA,CAAA;YACA;YACA,IACA,KAAA1b,KAAA,UAAAwM,YAAA,KACA,MAAApS,OAAA,IACA,OAAAuW,gBAAA,SAAAlD,sBAAA,KACA,KAAAL,WAAA,CAAAnG,MAAA,QAEA,KAAA0U,wBAAA;UACA;UACAC,SAAA,EAAAA,CAAA;YACA;YACA,UAAAhb,gBAAA;cACA,KAAAmV,gBAAA,CAAArV,GAAA,EAAAC,GAAA;cACA,UAAA/C,KAAA,CAAAqK,QAAA;gBACA,MAAAU,IAAA,QAAA6J,iBAAA,CAAA9R,GAAA,EAAAC,GAAA;gBACA,IAAAgI,IAAA;kBACAA,IAAA,CAAAc,OAAA,CAAAd,IAAA,CAAArH,OAAA,UAAAiF,cAAA;kBACA,MAAA6Q,SAAA,GAAApa,KAAA,CAAA2L,IAAA,EAAAkT,GAAA;kBACA,MAAAnF,OAAA,GAAA1Z,KAAA,CAAA2L,IAAA,EACAkT,GAAA,GACA5R,GAAA,MAAA4F,gBAAA;kBACA,MAAAiM,UAAA,GACA,KAAAxY,QAAA,KAAA3H,SAAA,CAAA4H,MAAA;kBACA,IAAAwY,UAAA;kBACA,SAAAjP,eAAA;oBACAiP,UAAA;kBACA;oBACAA,UAAA;kBACA;kBACA,KAAAta,cAAA,MAAA2V,SAAA,CAAAxN,MAAA,CACAmS,UACA,KAAA3E,SAAA,CAAAxN,MAAA,CAAAkS,UAAA,QAAApF,OAAA,CAAA9M,MAAA,CACAkS,UACA;gBACA;cACA;YACA;UACA;UACAE,UAAA,EAAAA,CAAA;YACA,KAAAva,cAAA;UACA;QACA;MACA;MACA;IACA;IACA6S,iBAAA;MACA;MACA,SAAA1T,gBAAA;MAEA,KAAAC,uBAAA;MACA,WAAAoV,UAAA,SAAA7I,WAAA;QACA,KAAAvM,uBAAA,CAAAoV,UAAA,CAAApP,GAAA;MACA;MACA,KAAApG,WAAA;QAAAC,GAAA;QAAAC,GAAA;MAAA;;MAEA;MACA,KAAAsb,OAAA;IACA;IACA;;IAEA;IACA;IACA;IACAC,aAAA;MACA,KAAAlc,KAAA,QAAA6E,QAAA,GACA,KAAAtF,MAAA,CAAAM,mBAAA,GACA,KAAAN,MAAA,CAAAK,iBAAA;MACA,KAAAmC,gBAAA,GAAAvG,iBAAA,CAAAwG,SAAA;MACA,KAAA/B,YAAA,OAAAC,GAAA;MACA,KAAAC,QAAA,OAAAD,GAAA;MAEA,SAAAoF,QAAA,UAAAnG,yBAAA;QACA,KAAAgX,wBAAA;MACA;MACA,KAAAG,SAAA,YAAA9V,cAAA;MACA,KAAA8D,cAAA;IACA;IACA6X,YAAA;MACA,KAAAnc,KAAA,QAAAwM,YAAA;MACA,KAAA4L,oBAAA;;MAEA;MACA,KAAArW,gBAAA,GAAAvG,iBAAA,CAAAwG,SAAA;MACA,KAAAC,mBAAA;IACA;IACA0Z,yBAAA;MACA,KAAAS,KAAA;IACA;IACAC,sBAAA3W,EAAA;MACA,SAAAJ,QAAA;QACA,KAAA8W,KAAA;MACA;QACA,KAAAF,YAAA;MACA;MAEA,KAAA5F,SAAA;QACA,KAAAD,wBAAA,CAAA3Q,EAAA;QACA,KAAA0W,KAAA,kBAAA1W,EAAA;MACA;IACA;IACAyT,aAAA;MACA,KAAAiD,KAAA;IACA;IACA;;IAEA;IACA;IACA;IACAE,cAAA;MACA,KAAAtc,KAAA,QAAAT,MAAA,CAAAO,cAAA;MACA,KAAA8Y,QAAA,EAAAC,OAAA;IACA;IACA0D,oBAAA;MACA,KAAAvc,KAAA,QAAAwM,YAAA;IACA;IAEA;IACAgQ,qBAAAC,cAAA;MACA,UAAApZ,iBAAA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;;MAEA,KAAAuV,QAAA,EAAAC,OAAA;MACA;MACA;QAAAlY,GAAA;QAAAD,GAAA;QAAAuN;MAAA,SAAA5K,iBAAA;MACA,IAAA+T,SAAA,QAAA5E,iBAAA,CAAA9R,GAAA,EAAAC,GAAA;MACA,IAAA+V,OAAA,OAAArV,IAAA,CAAA+V,SAAA;MACAV,OAAA,CAAAf,UAAA,CACAyB,SAAA,CAAAxB,UAAA,UAAA/F,gBAAA,GAAA5B,OACA;MAEA,SAAAjB,QAAA,SAAAvH,OAAA;QACA;QACA;QACA,IAAA8K,MAAA;QACA,SAAA9K,OAAA;UACA8K,MAAA,QAAA/R,UAAA;QACA,gBAAAwO,QAAA;UACA,QAAA3L,IAAA,GAAAqb,MAAA,KAAAtF,SAAA,CAAAsF,MAAA;YACAnM,MAAA;UACA;QACA;;QAEA;QACA6G,SAAA,GAAA5c,aAAA,MAAAoD,KAAA,CAAA8K,KAAA,EAAA0O,SAAA,EAAA7G,MAAA;QACAmG,OAAA,GAAAlc,aAAA,MAAAoD,KAAA,CAAA8K,KAAA,EAAAgO,OAAA,EAAAnG,MAAA;MACA;;MAEA;MACA,MAAAoM,MAAA,QAAAvP,WAAA,CAAAnI,GAAA,CAAAsD,CAAA;QACA;QACA,IAAAA,CAAA,CAAAiQ,KAAA,CAAAvR,MAAA;UACA,OAAAsB,CAAA,CAAAiQ,KAAA;QACA;UACA;UACA;QACA;MACA;MACA,MAAAoE,YAAA,GAAAC,kBAAA,CAAAF,MAAA,CAAArU,MAAA,CAAArK,OAAA,EAAA6e,IAAA;MAEA,MAAAhE,OAAA,QAAAlb,KAAA,CAAAmf,OAAA,SAAAnf,KAAA,CAAAiJ,GAAA;MAEA,IAAA8N,GAAA;MACA,IAAA8H,cAAA;QACA;QACA,MAAAO,KAAA,GAAA5F,SAAA,CAAAxC,WAAA,GAAAgF,OAAA;QACA,MAAAqD,GAAA,GAAAvG,OAAA,CAAA9B,WAAA,GAAAgF,OAAA;;QAEA;QACAjF,GAAA,uEAAAkI,kBAAA,CACA,KAAAjf,KAAA,CAAAF,IACA,WAAAsf,KAAA,IAAAC,GAAA,YAAAJ,kBAAA,CACA,8DACA,IAAA/D,OAAA,aAAA1V,WAAA,CAAAqN,KAAA,QAAAmM,YAAA;MACA;QACAjI,GAAA,mEAAAkI,kBAAA,CACA,KAAAjf,KAAA,CAAAF,IACA,UAAAmf,kBAAA,CACA,iEACA/D,OACA,aAAA1B,SAAA,CAAAxC,WAAA,YAAA8B,OAAA,CAAA9B,WAAA,eAAAiI,kBAAA,CACA,KAAAjf,KAAA,CAAAsf,QAAA,MACA,iDAAA9Z,WAAA,CAAAqN,KAAA;MACA;;MAEA;MACA0M,MAAA,CAAAC,IAAA,CAAAzI,GAAA;MACA,KAAA3U,KAAA,QAAAwM,YAAA;IACA;IACA;;IAEA;IACA;IACA;IACA6Q,YAAAzJ,CAAA;MACA;MACA,IAAA0J,KAAA,EAAAC,KAAA;MACA,iBAAA3J,CAAA;QACA;QACA;QAAA;UAAA0J,KAAA;UAAAC;QAAA,IAAA3J,CAAA,CAAA4J,OAAA;MACA;QACA;QACA;QAAA;UAAAF,KAAA;UAAAC;QAAA,IAAA3J,CAAA;MACA;MACA;QAAA6J,IAAA;QAAA3P;MAAA,IAAA8F,CAAA,CAAA8J,aAAA,CAAAzD,qBAAA;MACA,MAAA0D,CAAA,GAAAL,KAAA,GAAAG,IAAA;MACA,MAAAG,CAAA,GAAAL,KAAA,GAAAzP,GAAA,GAAAqP,MAAA,CAAAU,OAAA;MACA;QAAAF,CAAA;QAAAC;MAAA;IACA;IACAE,SAAApd,GAAA;MACA,SAAA9C,KAAA,CAAAqK,QAAA;QACAvH,GAAA,GAAAvG,KAAA,CAAAuG,GAAA,KAAA+G,IAAA,CAAAuB,KAAA,MAAAkC,SAAA,CAAAjE,MAAA;MACA;QACAvG,GAAA,GAAAvG,KAAA,CAAAuG,GAAA,UAAAmI,KAAA,CAAA5B,MAAA;MACA;MACA,OAAAvG,GAAA;IACA;IACAqd,SAAApd,GAAA;MACA,SAAA/C,KAAA,CAAAqK,QAAA;QACAtH,GAAA,GAAAxG,KAAA,CAAAwG,GAAA;MACA;QACAA,GAAA,GAAAxG,KAAA,CAAAwG,GAAA,UAAAuI,IAAA,CAAAjC,MAAA;MACA;MACA,OAAAtG,GAAA;IACA;IACA;IACAqd,gBAAAL,CAAA,EAAAC,CAAA;MACA;QAAA9a,KAAA;QAAAC;MAAA,SAAAF,QAAA;MACA,IAAAlC,GAAA,GAAA8G,IAAA,CAAAuB,KAAA,CAAA2U,CAAA,GAAA7a,KAAA;MACA,UAAAlF,KAAA,CAAAqK,QAAA;QACAtH,GAAA,QAAAqS,aAAA,CAAA/L,MAAA;QACA,SAAAwB,CAAA,MAAAA,CAAA,QAAAuK,aAAA,CAAA/L,MAAA,IAAAwB,CAAA;UACA,IAAAkV,CAAA,QAAA3K,aAAA,CAAAvK,CAAA;YACA9H,GAAA,GAAA8H,CAAA;YACA;UACA;QACA;MACA;MACA,IAAA/H,GAAA,GAAA+G,IAAA,CAAAuB,KAAA,CAAA4U,CAAA,GAAA7a,MAAA;;MAEA;MACA,UAAAnF,KAAA,CAAAqK,QAAA,IAAAvH,GAAA,QAAAsN,UAAA,IAAA/G,MAAA;QACA,MAAAgX,WAAA,GAAAxW,IAAA,CAAAuB,KAAA,EAAA4U,CAAA,QAAAlb,gBAAA,IAAAK,MAAA;QACA,IAAAkb,WAAA,SAAAjQ,UAAA,IAAA/G,MAAA;UACA;UACAvG,GAAA,GAAAud,WAAA;QACA;MACA;MAEAvd,GAAA,QAAAod,QAAA,CAAApd,GAAA;MACAC,GAAA,QAAAod,QAAA,CAAApd,GAAA;MACA;QACAD,GAAA;QACAC;MACA;IACA;IACAsb,QAAA;MACA,UAAA7W,SAAA;MAEA,UAAAlC,SAAA,UAAAC,OAAA;;MAEA;MACA,IACA,KAAAnD,KAAA,UAAAT,MAAA,CAAAK,iBAAA,IACA,KAAAI,KAAA,UAAAT,MAAA,CAAAQ,kBAAA,EACA;QACA;QACA,IAAAme,MAAA,GACA,MAAA/a,OAAA,CAAAxC,GAAA,QAAAuC,SAAA,CAAAvC,GAAA,IACA8G,IAAA,CAAA0W,GAAA,MAAAhb,OAAA,CAAAxC,GAAA,QAAAuC,SAAA,CAAAvC,GAAA;QACA,IAAAyd,MAAA,GACA,MAAAjb,OAAA,CAAAzC,GAAA,QAAAwC,SAAA,CAAAxC,GAAA,IACA+G,IAAA,CAAA0W,GAAA,MAAAhb,OAAA,CAAAzC,GAAA,QAAAwC,SAAA,CAAAxC,GAAA;QACA,IAAA2d,KAAA,CAAAH,MAAA,GAAAA,MAAA;QACA,IAAAG,KAAA,CAAAD,MAAA,GAAAA,MAAA;;QAEA;QACA,IAAAE,QAAA,QAAApb,SAAA,CAAAxC,GAAA;QACA,IAAA6d,MAAA,QAAApb,OAAA,CAAAzC,GAAA,GAAA0d,MAAA;QACA,IAAAI,QAAA,QAAAtb,SAAA,CAAAvC,GAAA;QACA,IAAA8d,MAAA,QAAAtb,OAAA,CAAAxC,GAAA,GAAAud,MAAA;;QAEA;QACA,SAAAtgB,KAAA,CAAAqK,QAAA;UACAuW,QAAA;UACAC,MAAA;UACAP,MAAA;QACA;;QAEA;QACA,SAAA3V,CAAA,GAAA+V,QAAA,EAAA/V,CAAA,IAAAgW,MAAA,EAAAhW,CAAA,IAAA6V,MAAA;UACA,SAAA1D,CAAA,GAAA8D,QAAA,EAAA9D,CAAA,IAAA+D,MAAA,EAAA/D,CAAA,IAAAwD,MAAA;YACA,MAAAvV,IAAA,QAAA6J,iBAAA,CAAAjK,CAAA,EAAAmS,CAAA;YACA,KAAA/R,IAAA;YAEA,SAAA/K,KAAA,CAAAqK,QAAA;cACA;cACA,MAAAyW,kBAAA,GACA,KAAAvS,gBAAA,CAAAzR,GAAA,CAAAiO,IAAA,CAAArH,OAAA,OACA,KAAAoR,WAAA,CAAAnK,CAAA,EAAAmS,CAAA;cACA,KAAAgE,kBAAA;YACA;YAEA,SAAAzb,QAAA,UAAAV,UAAA,CAAAC,GAAA;cACA,SAAAxC,KAAA,UAAAT,MAAA,CAAAQ,kBAAA;gBACA,KAAAK,SAAA,CAAA6J,GAAA,CAAAtB,IAAA,CAAArH,OAAA;cACA;gBACA;gBACA,SAAAS,gBAAA,KAAAvG,iBAAA,CAAAwG,SAAA;kBACA,KAAA/B,YAAA,CAAAgK,GAAA,CAAAtB,IAAA,CAAArH,OAAA;kBACA,KAAAnB,QAAA,CAAAwe,MAAA,CAAAhW,IAAA,CAAArH,OAAA;gBACA,WACA,KAAAS,gBAAA,KAAAvG,iBAAA,CAAA8V,SAAA,EACA;kBACA,KAAAnR,QAAA,CAAA8J,GAAA,CAAAtB,IAAA,CAAArH,OAAA;kBACA,KAAArB,YAAA,CAAA0e,MAAA,CAAAhW,IAAA,CAAArH,OAAA;gBACA;cACA;YACA,gBAAA2B,QAAA,UAAAV,UAAA,CAAAE,MAAA;cACA,SAAAzC,KAAA,UAAAT,MAAA,CAAAQ,kBAAA;gBACA,KAAAK,SAAA,CAAAue,MAAA,CAAAhW,IAAA,CAAArH,OAAA;cACA;gBACA;gBACA,KAAArB,YAAA,CAAA0e,MAAA,CAAAhW,IAAA,CAAArH,OAAA;gBACA,KAAAnB,QAAA,CAAAwe,MAAA,CAAAhW,IAAA,CAAArH,OAAA;cACA;YACA;;YAEA;YACA,SAAA1D,KAAA,CAAAC,IAAA,KAAAnC,UAAA,CAAA+K,KAAA;cACA,MAAAmY,YAAA,GAAApkB,aAAA,CACA,KAAAoD,KAAA,CAAA8K,KAAA,EACAC,IAAA,EACA,KAAAnK,UAAA,EACA,IACA;cACA,MAAAqgB,cAAA,GAAArkB,aAAA,CACA,KAAAoD,KAAA,CAAA8K,KAAA,EACA,KAAAQ,IAAA,CAAAwR,CAAA,EAAArS,UAAA,EACA,KAAA7J,UAAA,EACA,IACA;;cAEA;cACA,MAAAqgB,cAAA,CAAAvd,OAAA,WAAAmD,kBAAA;gBACA;gBACA,KAAAA,kBAAA,CAAAoa,cAAA,CAAAvd,OAAA,UAAApB,GAAA;;gBAEA;gBACA,MAAA4e,oBAAA,QAAAC,wBAAA,CAAArE,CAAA;gBACA,WAAA7L,CAAA,IAAAiQ,oBAAA;kBACA,MAAAE,aAAA,GAAAxkB,aAAA,CACA,KAAAoD,KAAA,CAAA8K,KAAA,EACA,IAAArH,IAAA,CAAAwN,CAAA,GACA,KAAArQ,UAAA,EACA,IACA;kBACA,KAAAiG,kBAAA,CAAAoa,cAAA,CAAAvd,OAAA,IAAA2I,GAAA,CACA+U,aAAA,CAAA1d,OAAA,EACA;gBACA;cACA;;cAEA;cACA,SAAA2B,QAAA,UAAAV,UAAA,CAAAC,GAAA;gBACA,KAAAiC,kBAAA,CAAAoa,cAAA,CAAAvd,OAAA,IAAA2I,GAAA,CACA2U,YAAA,CAAAtd,OAAA,EACA;cACA,gBAAA2B,QAAA,UAAAV,UAAA,CAAAE,MAAA;gBACA,KAAAgC,kBAAA,CAAAoa,cAAA,CAAAvd,OAAA,IAAAqd,MAAA,CACAC,YAAA,CAAAtd,OAAA,EACA;cACA;YACA;UACA;QACA;QACA,KAAArB,YAAA,OAAAC,GAAA,MAAAD,YAAA;MACA,gBAAAD,KAAA,UAAAT,MAAA,CAAAO,cAAA;QACA;QACA,MAAAa,GAAA,QAAAuC,SAAA,CAAAvC,GAAA;QACA,MAAAD,GAAA,QAAAwC,SAAA,CAAAxC,GAAA;QACA,MAAAuN,OAAA,QAAA9K,OAAA,CAAAzC,GAAA,QAAAwC,SAAA,CAAAxC,GAAA;QAEA,IAAAuN,OAAA;UACA,KAAA5K,iBAAA;YAAA1C,GAAA;YAAAD,GAAA;YAAAuN;UAAA;QACA;UACA,KAAA5K,iBAAA;QACA;MACA,gBAAArD,KAAA,UAAAT,MAAA,CAAAM,mBAAA;QACA;QACA,MAAAuK,QAAA,QAAAlH,SAAA,CAAAvC,GAAA;QACA,MAAA6G,WAAA,QAAAtE,SAAA,CAAAxC,GAAA;QACA,MAAAkS,WAAA,SAAAzP,OAAA,CAAAzC,GAAA,QAAAwC,SAAA,CAAAxC,GAAA;QACA,IAAAkS,WAAA;UACA,KAAAjR,sBAAA,CAAAyI,QAAA,EAAAnE,IAAA,CACA,KAAAgZ,iBAAA,CAAA7U,QAAA,EAAA5C,WAAA,EAAAoL,WAAA,CACA;QACA;MACA;;MAEA;MACA,KAAA5P,QAAA;MACA,KAAAE,SAAA;MACA,KAAAC,OAAA;IACA;IACAuP,YAAAhS,GAAA,EAAAC,GAAA;MACA;MACA,SAAAqC,QAAA;QACA,SAAApF,KAAA,CAAAqK,QAAA;UACA,IACA/N,SAAA,CAAAwG,GAAA,OAAAwC,SAAA,CAAAxC,GAAA,OAAAyC,OAAA,CAAAzC,GAAA,KACAxG,SAAA,CAAAwG,GAAA,OAAAyC,OAAA,CAAAzC,GAAA,OAAAwC,SAAA,CAAAxC,GAAA,GACA;YACA,SAAAyC,OAAA,CAAAzC,GAAA,QAAAwC,SAAA,CAAAxC,GAAA;cACA,OACA,KAAAyC,OAAA,CAAAzC,GAAA,KAAAA,GAAA,SAAAyC,OAAA,CAAAxC,GAAA,IAAAA,GAAA,IACA,KAAAuC,SAAA,CAAAxC,GAAA,KAAAA,GAAA,SAAAwC,SAAA,CAAAvC,GAAA,IAAAA,GAAA,IACA,KAAAuC,SAAA,CAAAxC,GAAA,KAAAA,GAAA,SAAAyC,OAAA,CAAAzC,GAAA,KAAAA,GAAA;YAEA,gBAAAyC,OAAA,CAAAzC,GAAA,QAAAwC,SAAA,CAAAxC,GAAA;cACA,OACA,KAAAyC,OAAA,CAAAzC,GAAA,KAAAA,GAAA,SAAAyC,OAAA,CAAAxC,GAAA,IAAAA,GAAA,IACA,KAAAuC,SAAA,CAAAxC,GAAA,KAAAA,GAAA,SAAAwC,SAAA,CAAAvC,GAAA,IAAAA,GAAA,IACA,KAAAuC,SAAA,CAAAxC,GAAA,KAAAA,GAAA,SAAAyC,OAAA,CAAAzC,GAAA,KAAAA,GAAA;YAEA;cACA;cACA,OACAxG,SAAA,CAAAyG,GAAA,OAAAuC,SAAA,CAAAvC,GAAA,OAAAwC,OAAA,CAAAxC,GAAA,KACAzG,SAAA,CAAAyG,GAAA,OAAAwC,OAAA,CAAAxC,GAAA,OAAAuC,SAAA,CAAAvC,GAAA;YAEA;UACA;UACA;QACA;QAEA,OACA,CAAAzG,SAAA,CAAAwG,GAAA,OAAAwC,SAAA,CAAAxC,GAAA,OAAAyC,OAAA,CAAAzC,GAAA,KACAxG,SAAA,CAAAwG,GAAA,OAAAyC,OAAA,CAAAzC,GAAA,OAAAwC,SAAA,CAAAxC,GAAA,OACAxG,SAAA,CAAAyG,GAAA,OAAAuC,SAAA,CAAAvC,GAAA,OAAAwC,OAAA,CAAAxC,GAAA,KACAzG,SAAA,CAAAyG,GAAA,OAAAwC,OAAA,CAAAxC,GAAA,OAAAuC,SAAA,CAAAvC,GAAA;MAEA;MACA;IACA;IACAue,SAAAtL,CAAA;MACA,UAAAxO,SAAA;MACA,IAAAwO,CAAA,CAAA4J,OAAA,EAAAvW,MAAA;MACA,UAAA/D,SAAA;MAEA0Q,CAAA,CAAAuL,cAAA;MACA;QAAAze,GAAA;QAAAC;MAAA,SAAAqd,eAAA,CACA,GAAAlgB,MAAA,CAAAuP,MAAA,MAAAgQ,WAAA,CAAAzJ,CAAA,EACA;MAEA,IACA,KAAA1M,qBAAA,IACAxG,GAAA,SAAAwC,SAAA,CAAAxC,GAAA,QAAAwG,qBAAA,EACA;QACAxG,GAAA,QAAAwC,SAAA,CAAAxC,GAAA,QAAAwG,qBAAA;MACA,gBAAAlH,KAAA,UAAAT,MAAA,CAAAO,cAAA;QACA,MAAA2T,YAAA,QAAAvQ,SAAA,CAAAxC,GAAA,QAAAsN,UAAA,IAAA/G,MAAA;QACA,IAAAwM,YAAA;UACA/S,GAAA,GAAA+G,IAAA,CAAAC,GAAA,CAAAhH,GAAA,OAAAsN,UAAA,IAAA/G,MAAA;QACA;MACA;MAEA,KAAA9D,OAAA;QAAAzC,GAAA;QAAAC;MAAA;IACA;IACAye,UAAAxL,CAAA;MACA;QAAAlT,GAAA;QAAAC;MAAA,SAAAqd,eAAA,CACA,GAAAlgB,MAAA,CAAAuP,MAAA,MAAAgQ,WAAA,CAAAzJ,CAAA,EACA;;MAEA;MACA,SAAA/O,QAAA;QACA,WAAA0C,KAAA,SAAA7F,iBAAA,CAAAf,GAAA,EAAA0Y,MAAA,CACA,KAAA1X,sBAAA,CAAAhB,GAAA,CACA;UACA,IACAzG,SAAA,CACAwG,GAAA,EACA6G,KAAA,CAAAC,WAAA,MACA,CAAAD,KAAA,CAAAC,WAAA,GAAAD,KAAA,CAAAqL,WAAA,SACA,GACA;YACA,KAAAyM,KAAA,CAAAC,gBAAA,CAAAC,mBAAA,CAAAhY,KAAA,CAAAV,GAAA;YACA;UACA;QACA;MACA;MAEA,UAAAzB,SAAA;MACA,IAAAwO,CAAA,CAAA4J,OAAA,EAAAvW,MAAA;;MAEA,MAAA0B,IAAA,QAAA6J,iBAAA,CAAA9R,GAAA,EAAAC,GAAA;MACA,KAAAgI,IAAA;;MAEA;MACA,SAAA/K,KAAA,CAAAqK,QAAA,UAAAkE,gBAAA,CAAAzR,GAAA,CAAAiO,IAAA,CAAArH,OAAA;QACA;MACA;MAEA,KAAA0B,QAAA;MACA,KAAAE,SAAA;QAAAxC,GAAA;QAAAC;MAAA;MACA,KAAAwC,OAAA;QAAAzC,GAAA;QAAAC;MAAA;;MAEA;MACAiT,CAAA,CAAAuL,cAAA;;MAEA;MACA,SAAAta,QAAA;QACA,KAAA5B,QAAA,QAAAV,UAAA,CAAAC,GAAA;MACA,WACA,KAAAxC,KAAA,UAAAT,MAAA,CAAAQ,kBAAA,IACA,KAAAK,SAAA,CAAAoI,GAAA,CAAAG,IAAA,CAAArH,OAAA,OACA,KAAAS,gBAAA,KAAAvG,iBAAA,CAAAwG,SAAA,IACA,KAAA/B,YAAA,CAAAuI,GAAA,CAAAG,IAAA,CAAArH,OAAA,OACA,KAAAS,gBAAA,KAAAvG,iBAAA,CAAA8V,SAAA,IACA,KAAAnR,QAAA,CAAAqI,GAAA,CAAAG,IAAA,CAAArH,OAAA,KACA;QACA,KAAA2B,QAAA,QAAAV,UAAA,CAAAE,MAAA;MACA;QACA,KAAAQ,QAAA,QAAAV,UAAA,CAAAC,GAAA;MACA;IACA;IACA;;IAEA;IACA;IACA;IACAgd,iBAAA;MACA,MAAAC,KAAA,OAAApe,IAAA,MAAAzD,KAAA,CAAA8K,KAAA,KACAgX,kBAAA;QAAAC,YAAA;MAAA,GACAF,KAAA;MACA,MAAAG,aAAA,GAAAH,KAAA,CAAAA,KAAA,CAAAxY,MAAA;MAEA,OAAA2Y,aAAA;IACA;IACAC,sBAAA;MACAhe,YAAA,yBAAAQ,aAAA;MACA,IACA,KAAArC,KAAA,SAAAT,MAAA,CAAAI,UAAA,IACA,KAAAK,KAAA,SAAAT,MAAA,CAAAC,OAAA,EAEA,KAAAQ,KAAA,QAAAwM,YAAA;IACA;IACAsT,sBAAA;MACA,KAAAle,eAAA,SAAAA,eAAA;MACAC,YAAA,2BAAAD,eAAA;IACA;IACAme,uBAAA;MACA,KAAA3d,gBAAA,SAAAA,gBAAA;MACAP,YAAA,4BAAAO,gBAAA;IACA;IACA4d,0BAAAC,GAAA;MACA,KAAAhe,mBAAA,KAAAge,GAAA;MACA,KAAArH,QAAA,EAAAC,OAAA;QACAlT,OAAA,IAAAsa;MACA;IACA;IACA;;IAEA;IACA;IACA;IACAC,iBAAAtM,CAAA;MACA,KAAA7P,iBAAA,GAAA6P,CAAA,CAAAK,MAAA,CAAAkM,WAAA,GAAAvM,CAAA,CAAAK,MAAA,CAAAmM,WAAA;MACA,KAAAtc,kBAAA,GAAA8P,CAAA,CAAAK,MAAA,CAAAoM,UAAA;IACA;IACAC,SAAA1M,CAAA;MACA,KAAA2M,oBAAA;IACA;IACA;IACAA,qBAAA;MACA,MAAAC,gBAAA,QAAAnB,KAAA,CAAAoB,cAAA;MACA,IAAAD,gBAAA;QACA,KAAA3c,cAAA,GAAA9I,mBAAA,CAAAylB,gBAAA;UACAE,YAAA;QACA;MACA;MAEA,MAAAC,iBAAA,QAAAtB,KAAA,CAAAuB,eAAA,EAAAC,GAAA;MACA,IAAAF,iBAAA;QACA,KAAA3c,qBAAA,GAAAjJ,mBAAA,CAAA4lB,iBAAA;UACAD,YAAA;QACA;MACA;IACA;IACA;;IAEA;IACA;IACA;IACAI,SAAAlN,CAAA;MACAA,CAAA,CAAAmN,wBAAA;MACA,SAAAnjB,KAAA,CAAAC,IAAA,KAAAnC,UAAA,CAAA+K,KAAA;QACA;QACA;QACA,UAAAtC,IAAA,aAAA8G,cAAA,QAAA9C,OAAA,CAAAlB,MAAA;UACA,KAAA9C,IAAA;QACA;UACA,KAAAA,IAAA;UACA,KAAAiY,KAAA,2BAAA5d,UAAA;QACA;MACA;QACA,KAAA2F,IAAA;MACA;MACA,KAAAG,cAAA;IACA;IACA0c,SAAApN,CAAA;MACAA,CAAA,CAAAmN,wBAAA;MACA,SAAAnjB,KAAA,CAAAC,IAAA,KAAAnC,UAAA,CAAA+K,KAAA;QACA;QACA;QACA,SAAAtC,IAAA;UACA,KAAAA,IAAA;QACA;UACA,KAAAA,IAAA,GAAAsD,IAAA,CAAAqJ,IAAA,MAAA3I,OAAA,CAAAlB,MAAA,QAAAgE,cAAA;UACA,KAAAmR,KAAA,2BAAA5d,UAAA;QACA;MACA;QACA,KAAA2F,IAAA;MACA;MACA,KAAAG,cAAA;IACA;IACA;;IAEA;IACA;IACA;IACA2c,SAAA;MACA,KAAApH,eAAA;IACA;IACA;;IAEA;IACA;IACA;IACAqH,UAAA;MACA,KAAA1c,SAAA;MACA3C,YAAA,MAAA2P,wBAAA;IACA;IACA;;IAEA;IACA;IACA;;IAEA;IACA2P,sBAAA1I,OAAA;MACA,KAAAzX,sBAAA,CACA7F,qBAAA,CAAAsd,OAAA,CAAAD,KAAA,EAAAC,OAAA,CAAA2I,YAAA,EACA,CAAAzb,OAAA,GAAA8S,OAAA,CAAA9S,OAAA;MACA,KAAA3E,sBAAA,GAAAoF,IAAA,CAAAC,KAAA,CACAD,IAAA,CAAAE,SAAA,MAAAtF,sBAAA,CACA;IACA;IAEA;IACAqgB,yBAAA5I,OAAA;MACA,KAAAzX,sBAAA,CACA7F,qBAAA,CAAAsd,OAAA,CAAAD,KAAA,EAAAC,OAAA,CAAA2I,YAAA,EACA,CAAArb,YAAA,CAAA0S,OAAA,CAAA6I,aAAA,EAAA3b,OAAA,GAAA8S,OAAA,CAAA9S,OAAA;MACA,KAAA3E,sBAAA,GAAAoF,IAAA,CAAAC,KAAA,CACAD,IAAA,CAAAE,SAAA,MAAAtF,sBAAA,CACA;IACA;IAEA;IACAoV,2BAAA;MACA,UAAA9Q,QAAA;;MAEA;MACA,KAAAtE,sBAAA,GAAAoF,IAAA,CAAAC,KAAA,CACAD,IAAA,CAAAE,SAAA,MAAAhB,QAAA,CAAAE,gBAAA,CACA;;MAEA;MACA,WAAAE,EAAA,SAAA1E,sBAAA;QACA,KAAAA,sBAAA,CAAA0E,EAAA,EAAAC,OAAA;QACA,SAAA3E,sBAAA,CAAA0E,EAAA,EAAAK,YAAA;UACA,WAAAub,aAAA,SAAAtgB,sBAAA,CAAA0E,EAAA,EACAK,YAAA;YACA,KAAA/E,sBAAA,CAAA0E,EAAA,EAAAK,YAAA,CACAub,aAAA,CACA,CAAA3b,OAAA;UACA;QACA;MACA;;MAEA;MACA,SAAAL,QAAA,CAAAuB,GAAA,SAAAjJ,KAAA,CAAAgJ,SAAA;QACA,MAAA2a,gBAAA,GACA,KAAA3jB,KAAA,CAAAgJ,SAAA,MAAAtB,QAAA,CAAAuB,GAAA,EAAA0a,gBAAA;QAEA,WAAA7b,EAAA,IAAA6b,gBAAA;UACA,KAAAvgB,sBAAA,CAAA0E,EAAA,EAAAC,OAAA;UAEA4b,gBAAA,CAAA7b,EAAA,EAAA2M,OAAA,CAAAiP,aAAA;YACA,KAAAtgB,sBAAA,CAAA0E,EAAA,EAAAK,YAAA,CACAub,aAAA,CACA,CAAA3b,OAAA;UACA;QACA;MACA;IACA;IAEA;IACA6b,UAAA7Y,IAAA,EAAA1I,YAAA,YAAAA,YAAA;MACA,MAAA+c,KAAA,OAAA3b,IAAA,CAAAsH,IAAA;MACA,MAAAsU,GAAA,OAAA5b,IAAA,CAAAsH,IAAA;MACAsU,GAAA,CAAAxH,QAAA,CAAAwH,GAAA,CAAAvH,QAAA,UAAA9X,KAAA,CAAA2M,QAAA;MAEA,WAAAsE,CAAA,IAAA5O,YAAA;QACA,MAAAwhB,aAAA,OAAApgB,IAAA,CAAAwN,CAAA,EAAAvN,OAAA;QACA,IACA0b,KAAA,CAAA1b,OAAA,MAAAmgB,aAAA,IACAA,aAAA,IAAAxE,GAAA,CAAA3b,OAAA,IACA;UACA;QACA;MACA;MAEA;IACA;IAEA;IACAyd,yBAAA2C,MAAA,EAAAzhB,YAAA,YAAAA,YAAA;MACA,MAAA0hB,MAAA,OAAAzhB,GAAA;MACA,MAAA0hB,eAAA,OAAA1hB,GAAA,CAAAD,YAAA;MACA,KACA,IAAAsI,CAAA,MACAA,CAAA,QAAAyF,UAAA,IAAA/G,MAAA,QAAA+G,UAAA,IAAA/G,MAAA,EACA,EAAAsB,CAAA,EACA;QACA,MAAAI,IAAA,QAAA6J,iBAAA,CAAAjK,CAAA,EAAAmZ,MAAA;QACA,KAAA/Y,IAAA;QAEA,IAAAiZ,eAAA,CAAApZ,GAAA,CAAAG,IAAA,CAAArH,OAAA;UACAqgB,MAAA,CAAA1X,GAAA,CAAAtB,IAAA,CAAArH,OAAA;QACA;MACA;MAEA,OAAAqgB,MAAA;IACA;IAEA;IACArT,yBAAA7J,kBAAA,QAAAA,kBAAA;MACA,KAAAA,kBAAA;MAEA,MAAAod,qBAAA;MACA,WAAAjZ,IAAA,IAAAnE,kBAAA;QACA,MAAAqd,OAAA,GAAAtnB,aAAA,CACA,KAAAoD,KAAA,CAAA8K,KAAA,EACA,IAAArH,IAAA,CAAAgD,QAAA,CAAAuE,IAAA,IACA,KAAApK,UACA,EAAA8C,OAAA;QACAugB,qBAAA,CAAAC,OAAA,QAAArd,kBAAA,CAAAmE,IAAA,GAAA3D,GAAA,CACA4J,CAAA,IAAArU,aAAA,MAAAoD,KAAA,CAAA8K,KAAA,MAAArH,IAAA,CAAAwN,CAAA,QAAArQ,UAAA,CACA;MACA;MACA,OAAAqjB,qBAAA;IACA;IACA;;IAEA;IACA;IACA;;IAEA;IACA5C,kBAAA7U,QAAA,EAAA5C,WAAA,EAAAoL,WAAA;MACA,MAAA4D,SAAA,GAAAjc,YAAA,CACA,KAAA2O,IAAA,CAAAkB,QAAA,EAAA/B,UAAA,EACAb,WAAA,EACAoL,WACA;MAEA;QACA/L,GAAA,EAAA3J,QAAA,GAAAge,QAAA;QACA3B,QAAA;QACA7b,IAAA,OAAAqJ,kBAAA;QACA,GAAAyP,SAAA;QACAhP,WAAA;QACAoL;MACA;IACA;IAEA;IACAmP,gBAAAC,WAAA;MACA,KAAAtgB,iBAAA,CAAA2Q,OAAA,EAAA4P,WAAA,EAAA7X,QAAA;QACA6X,WAAA,CAAA5P,OAAA,EAAA9K,KAAA,EAAA2a,UAAA;UACA,IAAAF,WAAA,CAAAnb,GAAA,KAAAU,KAAA,CAAAV,GAAA;YACA,KAAAnF,iBAAA,CAAA0I,QAAA,EAAA8X,UAAA,IAAAF,WAAA;YACA,KAAAtgB,iBAAA,YAAAA,iBAAA;YACA;UACA;QACA;MACA;MAEA,KAAAC,sBAAA,CAAA0Q,OAAA,EAAA4P,WAAA,EAAA7X,QAAA;QACA6X,WAAA,CAAA5P,OAAA,EAAA9K,KAAA,EAAA2a,UAAA;UACA,IAAAF,WAAA,CAAAnb,GAAA,KAAAU,KAAA,CAAAV,GAAA;YACA,KAAAlF,sBAAA,CAAAyI,QAAA,EAAA8X,UAAA,IAAAF,WAAA;YACA,KAAArgB,sBAAA,YAAAA,sBAAA;YACA;UACA;QACA;MACA;IACA;IAEA;IACAwgB,kBAAAC,aAAA;MACA,KAAA1gB,iBAAA,CAAA2Q,OAAA,EAAA4P,WAAA,EAAA7X,QAAA;QACA6X,WAAA,CAAA5P,OAAA,EAAA9K,KAAA,EAAA2a,UAAA;UACA,IAAAE,aAAA,KAAA7a,KAAA,CAAAV,GAAA;YACA,KAAAnF,iBAAA,CAAA0I,QAAA,EAAAU,MAAA,CAAAoX,UAAA;YACA;UACA;QACA;MACA;MAEA,KAAAvgB,sBAAA,CAAA0Q,OAAA,EAAA4P,WAAA,EAAA7X,QAAA;QACA6X,WAAA,CAAA5P,OAAA,EAAA9K,KAAA,EAAA2a,UAAA;UACA,IAAAE,aAAA,KAAA7a,KAAA,CAAAV,GAAA;YACA,KAAAlF,sBAAA,CAAAyI,QAAA,EAAAU,MAAA,CAAAoX,UAAA;YACA;UACA;QACA;MACA;IACA;IAEA;IACAG,gBAAA;MACA;MACA,KAAA3gB,iBAAA,GAAApH,oBAAA,CACA,KAAAsD,KAAA,EACA,KAAAA,KAAA,CAAA0b,YAAA,MACA;MAEA,KAAAgJ,2BAAA;;MAEA;MACA,WAAA3b,MAAA,SAAA/I,KAAA,CAAA2kB,eAAA;QACA,MAAAC,cAAA,QAAA5kB,KAAA,CAAA2kB,eAAA,CAAA5b,MAAA;QACA,WAAAyb,aAAA,IAAAI,cAAA,CAAAC,cAAA;UACA,MAAAT,WAAA,QAAAtgB,iBAAA,CACAsF,IAAA,GACA0b,IAAA,CAAAV,WAAA,IAAAA,WAAA,CAAAnb,GAAA,KAAAub,aAAA;UAEA,KAAAJ,WAAA,CAAApb,SAAA,EAAAob,WAAA,CAAApb,SAAA;UACAob,WAAA,CAAApb,SAAA,CAAAX,IAAA,CAAAuc,cAAA;QACA;MACA;IACA;IAEA;IACAF,4BAAA;MACA,KAAA3gB,sBAAA;MACA,WAAAuG,GAAA,SAAAxG,iBAAA;QACA,KAAAC,sBAAA,CAAAsE,IAAA;MACA;IACA;IAEA;IACA0c,uBAAApb,KAAA;MACA,UAAAI,4BAAA,UAAAiF,OAAA,EACA,KAAAwP,KAAA,mBAAA7U,KAAA;IACA;IAEA;;IAEA;IACA;IACA;;IAEA;IACAqb,cAAA;MACA;MACA,KAAAhlB,KAAA,CAAAiL,KAAA,YAAAzI,SAAA,EACA6E,GAAA,CAAAmK,CAAA,QAAA/N,IAAA,CAAA+N,CAAA,GACAyT,IAAA,EAAAhU,CAAA,EAAAiU,CAAA,KAAAjU,CAAA,CAAAvN,OAAA,KAAAwhB,CAAA,CAAAxhB,OAAA;MAEA;QAAAyhB,QAAA;QAAAC;MAAA,SAAAC,uBAAA,CACA,KAAArlB,KAAA,CAAAiL,KACA;;MAEA;MACA,SAAAJ,CAAA,MAAAA,CAAA,QAAA7K,KAAA,CAAA8K,KAAA,CAAAzB,MAAA,IAAAwB,CAAA;QACA,MAAAE,IAAA,OAAAtH,IAAA,MAAAzD,KAAA,CAAA8K,KAAA,CAAAD,CAAA;QACAE,IAAA,CAAAc,OAAA,CAAAd,IAAA,CAAArH,OAAA,UAAAiF,cAAA;QACAoC,IAAA,CAAAqB,WAAA,CAAA+Y,QAAA;QACApa,IAAA,CAAAc,OAAA,CAAAd,IAAA,CAAArH,OAAA,UAAAiF,cAAA;QACA,KAAA3I,KAAA,CAAA8K,KAAA,CAAAD,CAAA,IAAAE,IAAA,CAAAiM,WAAA;MACA;;MAEA;MACA,KAAAhX,KAAA,CAAA2M,QAAA,GAAAyY,QAAA,GAAAD,QAAA;;MAEA;MACA9oB,GAAA,iBAAA2D,KAAA,CAAAiJ,GAAA,SAAAjJ,KAAA,EACAiX,IAAA;QACA,KAAA7U,KAAA,QAAAwM,YAAA;MACA,GACAuI,KAAA,CAAAC,GAAA;QACA,KAAAC,SAAA,CAAAD,GAAA;MACA;IACA;IAEA;IACAiO,wBAAApa,KAAA;MACA,IAAAka,QAAA;MACA,IAAAC,QAAA;MACA,WAAApa,IAAA,IAAAC,KAAA;QACA,MAAAqa,QAAA,OAAA7hB,IAAA,CAAAuH,IAAA;QACA,MAAAD,IAAA,OAAAtH,IAAA,CACA6hB,QAAA,CAAA5hB,OAAA,UAAAiF,cAAA,YACA;QACA,MAAA4c,UAAA,GAAAxa,IAAA,CAAA8B,WAAA;QACA,IAAA0Y,UAAA,GAAAJ,QAAA;UACAA,QAAA,GAAAI,UAAA;QACA,WAAAA,UAAA,GAAAH,QAAA;UACAA,QAAA,GAAAG,UAAA;QACA;MACA;MACA;QAAAJ,QAAA;QAAAC;MAAA;IACA;IAEA;;IAEA;IACAI,sBAAA;MACA,IACA,KAAApjB,KAAA,UAAAT,MAAA,CAAAK,iBAAA,IACA,KAAA0F,QAAA,IACA,OAAAA,QAAA,EAAAuB,GAAA,SAAAjJ,KAAA,CAAAgJ,SAAA;MAAA;MACA,MAAAzI,qBAAA,KACA,MAAAqC,cAAA,SAAAF,uBAAA,GACA;QACA,WAAA2X,OAAA,SAAA5X,wBAAA;UACAgY,YAAA,CAAAJ,OAAA;QACA;QACA,KAAAP,4BAAA;MACA;IACA;EACA;EACA2L,KAAA;IACApjB,aAAA;MACA,SAAAD,KAAA,UAAAT,MAAA,CAAAK,iBAAA;QACA,KAAAY,cAAA;MACA;IACA;IACA5C,KAAA;MACA0lB,SAAA;MACAC,QAAA;QACA,KAAAnN,0BAAA;QACA,KAAA5B,cAAA;MACA;IACA;IACAxU,MAAAwjB,SAAA,EAAAC,SAAA;MACA,KAAAnN,SAAA,YAAAiK,oBAAA;;MAEA;MACA,IAAAkD,SAAA,UAAAlkB,MAAA,CAAAO,cAAA;QACA,KAAAuD,iBAAA;MACA,WAAAogB,SAAA,UAAAlkB,MAAA,CAAAK,iBAAA;QACA,KAAAY,cAAA;MACA;MAEA,IAAAgjB,SAAA,UAAAjkB,MAAA,CAAAQ,kBAAA;QACA,KAAAuW,SAAA;UACA,MAAAoN,KAAA,GAAA3J,QAAA,CAAA4J,cAAA;UACA,IAAAD,KAAA;YACA,MAAAE,OAAA;YACA,MAAAhG,CAAA,GACA8F,KAAA,CAAAzJ,qBAAA,GAAAnM,GAAA,GAAAqP,MAAA,CAAAU,OAAA,GAAA+F,OAAA;YACAzG,MAAA,CAAA0G,QAAA;cAAA/V,GAAA,EAAA8P,CAAA;cAAAkG,QAAA;YAAA;UACA;QACA;MACA;IACA;IACA1W,WAAA;MACAkW,SAAA;MACAC,QAAA;QACA,KAAA1iB,uBAAA;QACA,WAAAoV,UAAA,SAAA7I,WAAA;UACA,KAAAvM,uBAAA,CAAAoV,UAAA,CAAApP,GAAA;QACA;MACA;IACA;IACAxB,oBAAA4a,GAAA,EAAA8D,MAAA;MACA,IAAA3d,IAAA,CAAAE,SAAA,CAAA2Z,GAAA,MAAA7Z,IAAA,CAAAE,SAAA,CAAAyd,MAAA;QACA,KAAAX,qBAAA;MACA;IACA;IACAjf,KAAA;MACA,KAAAmS,SAAA;QACA,KAAAuD,eAAA;MACA;IACA;IACA1R,QAAA;MACA,KAAAmO,SAAA;QACA,KAAAuD,eAAA;MACA;IACA;IACA1I,qBAAA;MACAmS,SAAA;MACAC,QAAAS,GAAA;QACA3L,YAAA,MAAAnU,mCAAA;QACA,KAAAA,mCAAA,GAAAgU,UAAA;UACA,KAAAjU,4BAAA,GAAA+f,GAAA;QACA;MACA;IACA;IACA/Y,eAAA;MACA;MACA;MACA,SAAA9G,IAAA,QAAA8G,cAAA,SAAA9C,OAAA,CAAAlB,MAAA;QACA,KAAA9C,IAAA;MACA;IACA;IACAC,cAAA;MACA;MACAvC,YAAA,yBAAAuC,aAAA;;MAEA;MACA,KAAAkS,SAAA;QACA,KAAAuD,eAAA;MACA;IACA;IACArb,WAAA;MACA,SAAAZ,KAAA,CAAAC,IAAA,KAAAnC,UAAA,CAAA+K,KAAA;QACA,KAAA+N,cAAA;MACA;IACA;IACAlS,aAAA;MACA,KAAAwS,qBAAA;IACA;IACAxH,gBAAA;MACA;MACA,KAAAwH,qBAAA;;MAEA;MACA,IACA,KAAAlX,KAAA,CAAAC,IAAA,KAAAnC,UAAA,CAAA+K,KAAA,IACA,KAAAzG,KAAA,UAAAT,MAAA,CAAAK,iBAAA,IACA,KAAA0F,QAAA,EACA;QACA,KAAArF,YAAA,OAAAC,GAAA;QACA,KAAAmW,wBAAA,MAAA/Q,QAAA,CAAAuB,GAAA;MACA;IACA;IACAxE,cAAA;MACA,KAAAwd,qBAAA;IACA;IACAnc,sBAAA;MACA7B,YAAA,iCAAA6B,qBAAA;IACA;IACAxB,WAAA8hB,GAAA,EAAAC,IAAA;MACA,IAAAD,GAAA,CAAAre,OAAA,KAAAse,IAAA,CAAAte,OAAA,IAAAqe,GAAA,CAAAre,OAAA;QACA,KAAAyd,qBAAA;MACA;IACA;IACAjhB,aAAA6hB,GAAA,EAAAC,IAAA;MACA,IAAAD,GAAA,CAAAre,OAAA,KAAAse,IAAA,CAAAte,OAAA,IAAAqe,GAAA,CAAAre,OAAA;QACA,KAAAyd,qBAAA;MACA;IACA;IACA9f,SAAA;MACAzB,YAAA,oBAAAyB,QAAA;IACA;IACAtF,cAAA;MACA,SAAAA,aAAA,SAAAwL,eAAA;QACA,KAAApJ,SAAA,OAAAF,GAAA,CACA,KAAAtC,KAAA,CAAAiL,KAAA,CAAA5D,GAAA,CAAAmK,CAAA,QAAA/N,IAAA,CAAA+N,CAAA,EAAA9N,OAAA,GACA;QACA,KAAAtB,KAAA,QAAAT,MAAA,CAAAQ,kBAAA;MACA;IACA;EACA;EACAmkB,QAAA;IACA,KAAA/N,wBAAA;IAEAgO,gBAAA,eAAAnQ,mBAAA;EACA;EACAoQ,QAAA;IACA;IACA,MAAAC,SAAA,OAAAC,eAAA,CAAAnH,MAAA,CAAAD,QAAA,CAAAqH,MAAA;;IAEA;IACA,IACA,KAAA3mB,KAAA,CAAAuP,gBAAA,KACA,KAAAnP,aAAA,UAAAJ,KAAA,CAAAiL,KAAA,SAAAjL,KAAA,CAAAiL,KAAA,CAAA5B,MAAA,SACA;MACA,KAAAjH,KAAA,QAAAT,MAAA,CAAAQ,kBAAA;IACA,WAAAskB,SAAA,CAAA3pB,GAAA;MACA,MAAA8pB,cAAA,GAAApe,IAAA,CAAAC,KAAA,CAAAge,SAAA,CAAA3pB,GAAA;MACA,KAAA2I,iBAAA,GAAAmhB,cAAA;MACA,KAAAxkB,KAAA,QAAAT,MAAA,CAAAO,cAAA;;MAEA;MACA,MAAA2kB,MAAA,OAAAC,GAAA,CAAAvH,MAAA,CAAAD,QAAA,CAAAyH,IAAA;MACAF,MAAA,CAAAG,YAAA,CAAAjG,MAAA;MACAxB,MAAA,CAAA0H,OAAA,CAAAC,YAAA,KAAA/K,QAAA,CAAAgL,KAAA,EAAAN,MAAA,CAAAvJ,QAAA;IACA,gBAAA7Y,aAAA;MACA,KAAArC,KAAA;IACA;MACA,KAAAA,KAAA;IACA;;IAEA;IACA,SAAAsF,QAAA;MACA,KAAApD,UAAA,GACA,KAAAoD,QAAA,EAAAoJ,eAAA,EAAAxM,UAAA,IACAzG,uBAAA,CAAAyG,UAAA;MACA,KAAAC,YAAA,GACA,KAAAmD,QAAA,EAAAoJ,eAAA,EAAAvM,YAAA,IACA1G,uBAAA,CAAA0G,YAAA;MACA,SAAAsD,OAAA;QACA,SAAA7H,KAAA,CAAAgJ,SAAA,MAAAtB,QAAA,CAAAuB,GAAA,GAAA6H,eAAA;UACA;UACA;YAAAxM,UAAA;YAAAC;UAAA,IACA,KAAAvE,KAAA,CAAAgJ,SAAA,MAAAtB,QAAA,CAAAuB,GAAA,GAAA6H,eAAA;UACA,IAAAxM,UAAA,OAAAA,UAAA,GAAAA,UAAA;UACA,IAAAC,YAAA,OAAAA,YAAA,GAAAA,YAAA;QACA;UACA,KAAAD,UAAA,GAAAzG,uBAAA,CAAAyG,UAAA;UACA,KAAAC,YAAA,GAAA1G,uBAAA,CAAA0G,YAAA;QACA;MACA;IACA;;IAEA;IACA;IACA;;IAEA;IACA,KAAA0X,eAAA;IACAsK,gBAAA,gBAAAlD,QAAA;IACAkD,gBAAA,gBAAA7D,QAAA;IACA,UAAA1hB,YAAA;MACA,MAAAomB,OAAA,GAAAjL,QAAA,CAAA4J,cAAA;MACA,IAAA7oB,cAAA;QACAkqB,OAAA,CAAAb,gBAAA,oBAAA/E,SAAA;QACA4F,OAAA,CAAAb,gBAAA,mBAAAjF,QAAA;QACA8F,OAAA,CAAAb,gBAAA,kBAAAlI,OAAA;QACA+I,OAAA,CAAAb,gBAAA,qBAAAlI,OAAA;MACA;MACA+I,OAAA,CAAAb,gBAAA,mBAAA/E,SAAA;MACA4F,OAAA,CAAAb,gBAAA,mBAAAjF,QAAA;MACA8F,OAAA,CAAAb,gBAAA,iBAAAlI,OAAA;IACA;;IAEA;IACA,KAAAoG,eAAA;EACA;EACA4C,cAAA;IACAC,mBAAA,eAAAlR,mBAAA;IACAkR,mBAAA,gBAAAjE,QAAA;IACAiE,mBAAA,gBAAA5E,QAAA;EACA;EACA6E,UAAA;IACAroB,SAAA;IACAO,sBAAA;IACAT,iBAAA;IACAU,gBAAA;IACArB,iBAAA;IACAM,MAAA;IACAC,oBAAA;IACAC,OAAA;IACAP,gBAAA;IACAQ,eAAA;IACAP,aAAA;IACAQ,gBAAA;IACAE,kBAAA;IACAT,WAAA;IACAC,mBAAA;IACAC,gBAAA;IACAiB,kBAAA;IAAA;IACAC,yBAAA;IAAA;IACAT;EACA;AACA"},"metadata":{},"sourceType":"module","externalDependencies":[]}