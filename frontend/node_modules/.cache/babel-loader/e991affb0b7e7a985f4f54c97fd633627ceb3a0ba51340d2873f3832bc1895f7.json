{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/web.url-search-params.delete.js\";\nimport \"core-js/modules/web.url-search-params.has.js\";\nimport \"core-js/modules/web.url-search-params.size.js\";\nimport { timeNumToTimeText, dateCompare, getDateHoursOffset, post, put, isBetween, clamp, isPhone, utcTimeToLocalTime, splitTimeBlocksByDay, getTimeBlock, dateToDowDate, _delete, get, getDateDayOffset, isDateBetween, generateEnabledCalendarsPayload, isTouchEnabled, isElementInViewport, lightOrDark, removeTransparencyFromHex, userPrefers12h, getCalendarAccountKey, getISODateString, getDateWithTimezone, timeNumToTimeString, isPremiumUser } from \"@/utils\";\nimport { availabilityTypes, calendarOptionsDefaults, eventTypes, timeTypes, timeslotDurations, upgradeDialogTypes } from \"@/constants\";\nimport { mapMutations, mapActions, mapState } from \"vuex\";\nimport UserAvatarContent from \"@/components/UserAvatarContent.vue\";\nimport CalendarAccounts from \"@/components/settings/CalendarAccounts.vue\";\nimport Advertisement from \"@/components/event/Advertisement.vue\";\nimport SignUpBlock from \"@/components/sign_up_form/SignUpBlock.vue\";\nimport SignUpCalendarBlock from \"@/components/sign_up_form/SignUpCalendarBlock.vue\";\nimport SignUpBlocksList from \"@/components/sign_up_form/SignUpBlocksList.vue\";\nimport ZigZag from \"./ZigZag.vue\";\nimport ConfirmDetailsDialog from \"./ConfirmDetailsDialog.vue\";\nimport ToolRow from \"./ToolRow.vue\";\nimport RespondentsList from \"./RespondentsList.vue\";\nimport GCalWeekSelector from \"./GCalWeekSelector.vue\";\nimport ExpandableSection from \"../ExpandableSection.vue\";\nimport WorkingHoursToggle from \"./WorkingHoursToggle.vue\";\nimport AlertText from \"../AlertText.vue\";\nimport Tooltip from \"../Tooltip.vue\";\nimport dayjs from \"dayjs\";\nimport ObjectID from \"bson-objectid\";\nimport utcPlugin from \"dayjs/plugin/utc\";\nimport timezonePlugin from \"dayjs/plugin/timezone\";\nimport AvailabilityTypeToggle from \"./AvailabilityTypeToggle.vue\";\nimport BufferTimeSwitch from \"./BufferTimeSwitch.vue\";\nimport CalendarEventBlock from \"./CalendarEventBlock.vue\"; // Added import\nimport SpecificTimesInstructions from \"./SpecificTimesInstructions.vue\";\ndayjs.extend(utcPlugin);\ndayjs.extend(timezonePlugin);\nexport default {\n  name: \"ScheduleOverlap\",\n  props: {\n    event: {\n      type: Object,\n      required: true\n    },\n    fromEditEvent: {\n      type: Boolean,\n      default: false\n    },\n    loadingCalendarEvents: {\n      type: Boolean,\n      default: false\n    },\n    // Whether we are currently loading the calendar events\n    calendarEventsMap: {\n      type: Object,\n      default: () => {}\n    },\n    // Object of different users' calendar events\n    sampleCalendarEventsByDay: {\n      type: Array,\n      required: false\n    },\n    // Sample calendar events to use for example calendars\n    calendarPermissionGranted: {\n      type: Boolean,\n      default: false\n    },\n    // Whether user has granted google calendar permissions\n\n    weekOffset: {\n      type: Number,\n      default: 0\n    },\n    // Week offset used for displaying calendar events on weekly schejs\n\n    alwaysShowCalendarEvents: {\n      type: Boolean,\n      default: false\n    },\n    // Whether to show calendar events all the time\n    noEventNames: {\n      type: Boolean,\n      default: false\n    },\n    // Whether to show \"busy\" instead of the event name\n    calendarOnly: {\n      type: Boolean,\n      default: false\n    },\n    // Whether to only show calendar and not respondents or any other controls\n    interactable: {\n      type: Boolean,\n      default: true\n    },\n    // Whether to allow user to interact with component\n    showSnackbar: {\n      type: Boolean,\n      default: true\n    },\n    // Whether to show snackbar when availability is automatically filled in\n    animateTimeslotAlways: {\n      type: Boolean,\n      default: false\n    },\n    // Whether to animate timeslots all the time\n    showHintText: {\n      type: Boolean,\n      default: true\n    },\n    // Whether to show the hint text telling user what to do\n\n    curGuestId: {\n      type: String,\n      default: \"\"\n    },\n    // Id of the current guest being edited\n    addingAvailabilityAsGuest: {\n      type: Boolean,\n      default: false\n    },\n    // Whether the signed in user is adding availability as a guest\n\n    initialTimezone: {\n      type: Object,\n      default: () => ({})\n    },\n    // Availability Groups\n    calendarAvailabilities: {\n      type: Object,\n      default: () => ({})\n    }\n  },\n  data() {\n    return {\n      states: {\n        HEATMAP: \"heatmap\",\n        // Display heatmap of availabilities\n        SINGLE_AVAILABILITY: \"single_availability\",\n        // Show one person's availability\n        SUBSET_AVAILABILITY: \"subset_availability\",\n        // Show availability for a subset of people\n        BEST_TIMES: \"best_times\",\n        // Show only the times that work for most people\n        EDIT_AVAILABILITY: \"edit_availability\",\n        // Edit current user's availability\n        EDIT_SIGN_UP_BLOCKS: \"edit_sign_up_blocks\",\n        // Edit the slots on a sign up form\n        SCHEDULE_EVENT: \"schedule_event\",\n        // Schedule event on gcal\n        SET_SPECIFIC_TIMES: \"set_specific_times\" // Set specific times for the event\n      },\n      state: \"best_times\",\n      availability: new Set(),\n      // The current user's availability\n      ifNeeded: new Set(),\n      // The current user's \"if needed\" availability\n      tempTimes: new Set(),\n      // The specific times that the user has selected for the event (pending save)\n      availabilityAnimTimeouts: [],\n      // Timeouts for availability animation\n      availabilityAnimEnabled: false,\n      // Whether to animate timeslots changing colors\n      maxAnimTime: 1200,\n      // Max amount of time for availability animation\n      unsavedChanges: false,\n      // If there are unsaved availability changes\n      curTimeslot: {\n        row: -1,\n        col: -1\n      },\n      // The currently highlighted timeslot\n      timeslotSelected: false,\n      // Whether a timeslot is selected (used to persist selection on desktop)\n      curTimeslotAvailability: {},\n      // The users available for the current timeslot\n      curRespondent: \"\",\n      // Id of the active respondent (set on hover)\n      curRespondents: [],\n      // Id of currently selected respondents (set on click)\n      sharedCalendarAccounts: {},\n      // The user's calendar accounts for changing calendar options for groups\n      fetchedResponses: {},\n      // Responses fetched from the server for the dates currently shown\n      loadingResponses: {\n        loading: false,\n        lastFetched: new Date().getTime()\n      },\n      // Whether we're currently fetching the responses\n      responsesFormatted: new Map(),\n      // Map where date/time is mapped to the people that are available then\n      tooltipContent: \"\",\n      // The content of the tooltip\n\n      /* Sign up form */\n      signUpBlocksByDay: [],\n      // The current event's sign up blocks by day\n      signUpBlocksToAddByDay: [],\n      // The sign up blocks to be added after hitting 'save'\n\n      /* Edit options */\n      showEditOptions: localStorage[\"showEditOptions\"] == undefined ? false : localStorage[\"showEditOptions\"] == \"true\",\n      availabilityType: availabilityTypes.AVAILABLE,\n      // The current availability type\n      overlayAvailability: false,\n      // Whether to overlay everyone's availability when editing\n      bufferTime: calendarOptionsDefaults.bufferTime,\n      // Set in mounted()\n      workingHours: calendarOptionsDefaults.workingHours,\n      // Set in mounted()\n\n      /* Event Options */\n      showEventOptions: localStorage[\"showEventOptions\"] == undefined ? false : localStorage[\"showEventOptions\"] == \"true\",\n      showBestTimes: localStorage[\"showBestTimes\"] == undefined ? false : localStorage[\"showBestTimes\"] == \"true\",\n      hideIfNeeded: false,\n      /* Variables for drag stuff */\n      DRAG_TYPES: {\n        ADD: \"add\",\n        REMOVE: \"remove\"\n      },\n      SPLIT_GAP_HEIGHT: 40,\n      SPLIT_GAP_WIDTH: 20,\n      HOUR_HEIGHT: 60,\n      timeslot: {\n        width: 0,\n        height: 0\n      },\n      dragging: false,\n      dragType: \"add\",\n      dragStart: null,\n      dragCur: null,\n      /* Variables for options */\n      curTimezone: this.initialTimezone,\n      curScheduledEvent: null,\n      // The scheduled event represented in the form {hoursOffset, hoursLength, dayIndex}\n      timeType: localStorage[\"timeType\"] ?? (userPrefers12h() ? timeTypes.HOUR12 : timeTypes.HOUR24),\n      // Whether 12-hour or 24-hour\n      showCalendarEvents: false,\n      startCalendarOnMonday: false,\n      // localStorage[\"startCalendarOnMonday\"] == undefined\n      //   ? false\n      //   : localStorage[\"startCalendarOnMonday\"] == \"true\",\n\n      /* Dialogs */\n      deleteAvailabilityDialog: false,\n      calendarOptionsDialog: false,\n      /* Variables for scrolling */\n      optionsVisible: false,\n      calendarScrollLeft: 0,\n      // The current scroll position of the calendar\n      calendarMaxScroll: 0,\n      // The maximum scroll amount of the calendar, scrolling to this point means we have scrolled to the end\n      scrolledToRespondents: false,\n      // whether we have scrolled to the respondents section\n      delayedShowStickyRespondents: false,\n      // showStickyRespondents variable but changes 100ms after the actual variable changes (to add some delay)\n      delayedShowStickyRespondentsTimeout: null,\n      // Timeout that sets delayedShowStickyRespondents\n\n      /* Variables for pagination */\n      page: 0,\n      mobileNumDays: localStorage[\"mobileNumDays\"] ? parseInt(localStorage[\"mobileNumDays\"]) : 3,\n      // The number of days to show at a time on mobile\n      pageHasChanged: false,\n      hasRefreshedAuthUser: false,\n      /* Variables for hint */\n      hintState: true,\n      /** Groups */\n      manualAvailability: {},\n      /** Constants */\n      months: [\"jan\", \"feb\", \"mar\", \"apr\", \"may\", \"jun\", \"jul\", \"aug\", \"sep\", \"oct\", \"nov\", \"dec\"]\n    };\n  },\n  computed: {\n    ...mapState([\"authUser\", \"overlayAvailabilitiesEnabled\"]),\n    /** Returns the width of the right side of the calendar */\n    rightSideWidth() {\n      if (this.isPhone) return \"100%\";\n      return this.isSignUp ? \"18rem\" : \"13rem\";\n    },\n    /** Returns the days of the week in the correct order */\n    daysOfWeek() {\n      // 返回带“周”的中文星期标题\n      return !this.startCalendarOnMonday ? [\"周日\", \"周一\", \"周二\", \"周三\", \"周四\", \"周五\", \"周六\"] : [\"周一\", \"周二\", \"周三\", \"周四\", \"周五\", \"周六\", \"周日\"];\n    },\n    /** Only allow scheduling when a curScheduledEvent exists */\n    allowScheduleEvent() {\n      return !!this.curScheduledEvent;\n    },\n    /** Returns the availability as an array */\n    availabilityArray() {\n      return [...this.availability].map(item => new Date(item));\n    },\n    /** Returns the if needed availability as an array */\n    ifNeededArray() {\n      return [...this.ifNeeded].map(item => new Date(item));\n    },\n    allowDrag() {\n      return this.state === this.states.EDIT_AVAILABILITY || this.state === this.states.EDIT_SIGN_UP_BLOCKS || this.state === this.states.SCHEDULE_EVENT || this.state === this.states.SET_SPECIFIC_TIMES;\n    },\n    /** Returns an array of calendar events for all of the authUser's enabled calendars, separated by the day they occur on */\n    calendarEventsByDay() {\n      // If this is an example calendar\n      if (this.sampleCalendarEventsByDay) return this.sampleCalendarEventsByDay;\n\n      // If the user isn't logged in or is adding availability as a guest\n      if (!this.authUser || this.addingAvailabilityAsGuest) return [];\n      let events = [];\n      let event;\n      const calendarAccounts = this.isGroup ? this.sharedCalendarAccounts : this.authUser.calendarAccounts;\n\n      // Adds events from calendar accounts that are enabled\n      for (const id in calendarAccounts) {\n        if (!calendarAccounts[id].enabled) continue;\n        if (this.calendarEventsMap.hasOwnProperty(id)) {\n          for (const index in this.calendarEventsMap[id].calendarEvents) {\n            event = this.calendarEventsMap[id].calendarEvents[index];\n\n            // Check if we need to update authUser (to get latest subcalendars)\n            const subCalendars = calendarAccounts[id].subCalendars;\n            if (!subCalendars || !(event.calendarId in subCalendars)) {\n              // authUser doesn't contain the subCalendar, so push event to events without checking if subcalendar is enabled\n              // and queue the authUser to be refreshed\n              events.push(event);\n              if (!this.hasRefreshedAuthUser && !this.isGroup) {\n                this.refreshAuthUser();\n              }\n              continue;\n            }\n\n            // Push event to events if subcalendar is enabled\n            if (subCalendars[event.calendarId].enabled) {\n              events.push(event);\n            }\n          }\n        }\n      }\n      const eventsCopy = JSON.parse(JSON.stringify(events));\n      const calendarEventsByDay = splitTimeBlocksByDay(this.event, eventsCopy, this.weekOffset, this.timezoneOffset);\n      return calendarEventsByDay;\n    },\n    /** [SPECIFIC TO GROUPS] Returns an object mapping user ids to their calendar events separated by the day they occur on */\n    groupCalendarEventsByDay() {\n      if (this.event.type !== eventTypes.GROUP) return {};\n      const userIdToEventsByDay = {};\n      for (const userId in this.event.responses) {\n        if (userId === this.authUser._id) {\n          userIdToEventsByDay[userId] = this.calendarEventsByDay;\n        } else if (userId in this.calendarAvailabilities) {\n          userIdToEventsByDay[userId] = splitTimeBlocksByDay(this.event, this.calendarAvailabilities[userId], this.weekOffset, this.timezoneOffset);\n        }\n      }\n      return userIdToEventsByDay;\n    },\n    curRespondentsSet() {\n      return new Set(this.curRespondents);\n    },\n    // -----------------------------------\n    //#region Sign up form\n    // -----------------------------------\n\n    /** Returns the name of the new sign up block being dragged */\n    newSignUpBlockName() {\n      return `Slot #${this.signUpBlocksByDay.flat().length + this.signUpBlocksToAddByDay.flat().length + 1}`;\n    },\n    /** Returns the max allowable drag */\n    maxSignUpBlockRowSize() {\n      if (!this.dragStart || !this.isSignUp) return null;\n      const selectedDay = this.signUpBlocksByDay[this.dragStart.col];\n      const selectedDayToAdd = this.signUpBlocksToAddByDay[this.dragStart.col];\n      if (selectedDay.length === 0 && selectedDayToAdd.length === 0) return null;\n      let maxSize = Infinity;\n      for (const block of [...selectedDay, ...selectedDayToAdd]) {\n        if (block.hoursOffset * 4 > this.dragStart.row) {\n          maxSize = Math.min(maxSize, block.hoursOffset * 4 - this.dragStart.row);\n        }\n      }\n      return maxSize;\n    },\n    /** Whether the current user has already responded to the sign up form */\n    alreadyRespondedToSignUpForm() {\n      if (!this.authUser || !this.signUpBlocksByDay) return false;\n      return this.signUpBlocksByDay.some(dayBlocks => dayBlocks.some(block => block.responses?.some(response => response.userId === this.authUser._id)));\n    },\n    //#endregion\n\n    /** Returns the max number of people in the curRespondents array available at any given time */\n    curRespondentsMax() {\n      let max = 0;\n      if (this.event.daysOnly) {\n        for (const day of this.allDays) {\n          const num = [...(this.responsesFormatted.get(day.dateObject.getTime()) ?? new Set())].filter(r => this.curRespondentsSet.has(r)).length;\n          if (num > max) max = num;\n        }\n      } else {\n        for (let i = 0; i < this.event.dates.length; i++) {\n          const date = new Date(this.event.dates[i]);\n          for (const time of this.times) {\n            const num = [...this.getRespondentsForHoursOffset(date, time.hoursOffset)].filter(r => this.curRespondentsSet.has(r)).length;\n            if (num > max) max = num;\n          }\n        }\n      }\n      return max;\n    },\n    /** Returns the day offset caused by the timezone offset. If the timezone offset changes the date, dayOffset != 0 */\n    dayOffset() {\n      return Math.floor((this.event.startTime - this.timezoneOffset / 60) / 24);\n    },\n    /** Returns all the days that are encompassed by startDate and endDate */\n    allDays() {\n      const days = [];\n      const datesSoFar = new Set();\n      const getDateString = date => {\n        let dateString = \"\";\n        let dayString = \"\";\n        const offsetDate = new Date(date);\n        if (this.isSpecificTimes) {\n          offsetDate.setTime(offsetDate.getTime() - this.timezoneOffset * 60 * 1000);\n        } else {\n          offsetDate.setDate(offsetDate.getDate() + this.dayOffset);\n        }\n        if (this.isSpecificDates) {\n          dateString = `${this.months[offsetDate.getUTCMonth()]} ${offsetDate.getUTCDate()}`;\n          dayString = this.daysOfWeek[offsetDate.getUTCDay()];\n        } else if (this.isGroup || this.isWeekly) {\n          const tmpDate = dateToDowDate(this.event.dates, offsetDate, this.weekOffset, true);\n          dateString = `${this.months[tmpDate.getUTCMonth()]} ${tmpDate.getUTCDate()}`;\n          dayString = this.daysOfWeek[tmpDate.getUTCDay()];\n        }\n        return {\n          dateString,\n          dayString\n        };\n      };\n      if (this.isSpecificTimes && (this.state === this.states.SET_SPECIFIC_TIMES || this.event.times?.length === 0)) {\n        let prevDate = null; // Stores the prevDate to check if the current date is consecutive to the previous date\n        for (let i = 0; i < this.event.dates.length; ++i) {\n          const date = new Date(this.event.dates[i]);\n          const localDate = new Date(date.getTime() - this.timezoneOffset * 60 * 1000);\n          localDate.setUTCHours(0, 0, 0, 0);\n          localDate.setTime(localDate.getTime() + this.timezoneOffset * 60 * 1000);\n          if (!datesSoFar.has(localDate.getTime())) {\n            datesSoFar.add(localDate.getTime());\n            let isConsecutive = true;\n            if (prevDate) {\n              isConsecutive = prevDate.getTime() === localDate.getTime() - 24 * 60 * 60 * 1000;\n            }\n            const {\n              dayString,\n              dateString\n            } = getDateString(localDate);\n            days.push({\n              dayText: dayString,\n              dateString,\n              dateObject: localDate,\n              isConsecutive\n            });\n            prevDate = new Date(localDate);\n          }\n        }\n        return days;\n      }\n      for (let i = 0; i < this.event.dates.length; ++i) {\n        const date = new Date(this.event.dates[i]);\n        datesSoFar.add(date.getTime());\n        const {\n          dayString,\n          dateString\n        } = getDateString(date);\n        days.push({\n          dayText: dayString,\n          dateString,\n          dateObject: date\n        });\n      }\n      let dayIndex = 0;\n      for (let i = 0; i < this.event.dates.length; ++i) {\n        const date = new Date(this.event.dates[i]);\n        // See if the date goes into the next day\n        const localStart = new Date(date.getTime() - this.timezoneOffset * 60 * 1000);\n        const localEnd = new Date(date.getTime() + this.event.duration * 60 * 60 * 1000 - this.timezoneOffset * 60 * 1000);\n        const localEndIsMidnight = localEnd.getUTCHours() === 0 && localEnd.getUTCMinutes() === 0;\n        if (localStart.getUTCDate() !== localEnd.getUTCDate() && !localEndIsMidnight) {\n          // The date goes into the next day. Split the date into two dates\n          let nextDate = new Date(date);\n          nextDate.setUTCDate(nextDate.getUTCDate() + 1);\n          if (!datesSoFar.has(nextDate.getTime())) {\n            datesSoFar.add(nextDate.getTime());\n            const {\n              dayString,\n              dateString\n            } = getDateString(nextDate);\n            days.splice(dayIndex + 1, 0, {\n              dayText: dayString,\n              dateString,\n              dateObject: nextDate,\n              excludeTimes: true\n            });\n            dayIndex++;\n          }\n        }\n        dayIndex++;\n      }\n      let prevDate = null; // Stores the prevDate to check if the current date is consecutive to the previous date\n      for (let i = 0; i < days.length; ++i) {\n        let isConsecutive = true;\n        if (prevDate) {\n          isConsecutive = prevDate.getTime() === days[i].dateObject.getTime() - 24 * 60 * 60 * 1000;\n        }\n        days[i].isConsecutive = isConsecutive;\n        prevDate = new Date(days[i].dateObject);\n      }\n      return days;\n    },\n    /** Returns a subset of all days based on the page number */\n    days() {\n      const slice = this.allDays.slice(this.page * this.maxDaysPerPage, (this.page + 1) * this.maxDaysPerPage);\n      slice[0] = {\n        ...slice[0],\n        isConsecutive: true\n      };\n      return slice;\n    },\n    /** Returns all the days of the month */\n    monthDays() {\n      const monthDays = [];\n      const allDaysSet = new Set(this.allDays.map(d => d.dateObject.getTime()));\n\n      // Calculate monthIndex and year from event start date and page num\n      const date = new Date(this.event.dates[0]);\n      const monthIndex = date.getUTCMonth() + this.page;\n      const year = date.getUTCFullYear();\n      const lastDayOfPrevMonth = new Date(Date.UTC(year, monthIndex, 0));\n      const lastDayOfCurMonth = new Date(Date.UTC(year, monthIndex + 1, 0));\n\n      // Calculate num days from prev month, cur month, and next month to show\n      const curDate = new Date(lastDayOfPrevMonth);\n      let numDaysFromPrevMonth = 0;\n      const numDaysInCurMonth = lastDayOfCurMonth.getUTCDate();\n      const numDaysFromNextMonth = 6 - lastDayOfCurMonth.getUTCDay();\n      const hasDaysFromPrevMonth = !this.startCalendarOnMonday ? lastDayOfPrevMonth.getUTCDay() < 6 : lastDayOfPrevMonth.getUTCDay() != 0;\n      if (hasDaysFromPrevMonth) {\n        curDate.setUTCDate(curDate.getUTCDate() - (lastDayOfPrevMonth.getUTCDay() - (this.startCalendarOnMonday ? 1 : 0)));\n        numDaysFromPrevMonth = lastDayOfPrevMonth.getUTCDay() + 1;\n      } else {\n        curDate.setUTCDate(curDate.getUTCDate() + 1);\n      }\n      curDate.setUTCHours(this.event.startTime);\n\n      // Add all days from prev month, cur month, and next month\n      const totalDays = numDaysFromPrevMonth + numDaysInCurMonth + numDaysFromNextMonth;\n      for (let i = 0; i < totalDays; ++i) {\n        // Only include days from the current month\n        if (curDate.getUTCMonth() === lastDayOfCurMonth.getUTCMonth()) {\n          monthDays.push({\n            date: curDate.getUTCDate(),\n            time: curDate.getTime(),\n            dateObject: new Date(curDate),\n            included: allDaysSet.has(curDate.getTime())\n          });\n        } else {\n          monthDays.push({\n            date: \"\",\n            time: curDate.getTime(),\n            dateObject: new Date(curDate),\n            included: false\n          });\n        }\n        curDate.setUTCDate(curDate.getUTCDate() + 1);\n      }\n      return monthDays;\n    },\n    /** Map from datetime to whether that month day is included  */\n    monthDayIncluded() {\n      const includedMap = new Map();\n      for (const monthDay of this.monthDays) {\n        includedMap.set(monthDay.dateObject.getTime(), monthDay.included);\n      }\n      return includedMap;\n    },\n    /** Returns the text to show for the current month */\n    curMonthText() {\n      const date = new Date(this.event.dates[0]);\n      const monthIndex = date.getUTCMonth() + this.page;\n      const year = date.getUTCFullYear();\n      const lastDayOfCurMonth = new Date(Date.UTC(year, monthIndex + 1, 0));\n      const monthText = this.months[lastDayOfCurMonth.getUTCMonth()];\n      const yearText = lastDayOfCurMonth.getUTCFullYear();\n      return `${monthText} ${yearText}`;\n    },\n    defaultState() {\n      // Either the heatmap or the best_times state, depending on the toggle\n      return this.showBestTimes ? this.states.BEST_TIMES : this.states.HEATMAP;\n    },\n    editing() {\n      // Returns whether currently in the editing state\n      return this.state === this.states.EDIT_AVAILABILITY || this.state === this.states.EDIT_SIGN_UP_BLOCKS;\n    },\n    scheduling() {\n      // Returns whether currently in the scheduling state\n      return this.state === this.states.SCHEDULE_EVENT;\n    },\n    isPhone() {\n      return isPhone(this.$vuetify);\n    },\n    isOwner() {\n      return this.authUser?._id === this.event.ownerId;\n    },\n    isSpecificDates() {\n      return this.event.type === eventTypes.SPECIFIC_DATES || !this.event.type;\n    },\n    isWeekly() {\n      return this.event.type === eventTypes.DOW;\n    },\n    isGroup() {\n      return this.event.type === eventTypes.GROUP;\n    },\n    isSignUp() {\n      return this.event.isSignUpForm;\n    },\n    isSpecificTimes() {\n      return this.event.hasSpecificTimes;\n    },\n    respondents() {\n      return Object.values(this.parsedResponses).map(r => r.user).filter(Boolean);\n    },\n    selectedGuestRespondent() {\n      if (this.guestAddedAvailability) return this.guestName;\n      if (this.curRespondents.length !== 1) return \"\";\n      const user = this.parsedResponses[this.curRespondents[0]].user;\n      return this.isGuest(user) ? user._id : \"\";\n    },\n    scheduledEventStyle() {\n      const style = {};\n      let top, height, isSecondSplit;\n      if (this.dragging) {\n        top = this.dragStart.row;\n        height = this.dragCur.row - this.dragStart.row + 1;\n        isSecondSplit = this.dragStart.row >= this.splitTimes[0].length;\n      } else {\n        top = this.curScheduledEvent.row;\n        height = this.curScheduledEvent.numRows;\n        isSecondSplit = this.curScheduledEvent.row >= this.splitTimes[0].length;\n      }\n      if (isSecondSplit) {\n        style.top = `calc(${top} * ${this.timeslotHeight}px + ${this.SPLIT_GAP_HEIGHT}px)`;\n      } else {\n        style.top = `calc(${top} * ${this.timeslotHeight}px)`;\n      }\n      style.height = `calc(${height} * ${this.timeslotHeight}px)`;\n      return style;\n    },\n    signUpBlockBeingDraggedStyle() {\n      const style = {};\n      let top = 0,\n        height = 0;\n      if (this.dragging) {\n        top = this.dragStart.row;\n        height = this.dragCur.row - this.dragStart.row + 1;\n      }\n      style.top = `calc(${top} * 1rem)`;\n      style.height = `calc(${height} * 1rem)`;\n      return style;\n    },\n    /** Parses the responses to the Schej, makes necessary changes based on the type of event, and returns it */\n    parsedResponses() {\n      const parsed = {};\n\n      // Return calendar availability if group\n      if (this.event.type === eventTypes.GROUP) {\n        for (const userId in this.event.responses) {\n          const calendarEventsByDay = this.groupCalendarEventsByDay[userId];\n          if (calendarEventsByDay) {\n            // Get manual availability and convert to DOW dates\n            const fetchedManualAvailability = this.getManualAvailabilityDow(this.fetchedResponses[userId]?.manualAvailability);\n            const curManualAvailability = userId === this.authUser._id ? this.getManualAvailabilityDow(this.manualAvailability) : {};\n\n            // Get availability from calendar events and use manual availability on the\n            // \"touched\" days\n            const availability = this.getAvailabilityFromCalendarEvents({\n              calendarEventsByDay,\n              includeTouchedAvailability: true,\n              fetchedManualAvailability: fetchedManualAvailability ?? {},\n              curManualAvailability: curManualAvailability ?? {},\n              calendarOptions: userId === this.authUser._id ? {\n                bufferTime: this.bufferTime,\n                workingHours: this.workingHours\n              } : this.fetchedResponses[userId]?.calendarOptions ?? undefined\n            });\n            parsed[userId] = {\n              ...this.event.responses[userId],\n              availability: availability\n            };\n          } else {\n            parsed[userId] = {\n              ...this.event.responses[userId],\n              availability: new Set()\n            };\n          }\n        }\n        return parsed;\n      }\n\n      // Return only current user availability if using blind availabilities and user is not owner\n      if (this.event.blindAvailabilityEnabled && !this.isOwner) {\n        const guestName = localStorage[this.guestNameKey];\n        const userId = this.authUser?._id ?? guestName;\n        if (userId in this.event.responses) {\n          const user = {\n            ...this.event.responses[userId].user,\n            _id: userId\n          };\n          parsed[userId] = {\n            ...this.event.responses[userId],\n            availability: new Set(this.fetchedResponses[userId]?.availability?.map(a => new Date(a).getTime())),\n            ifNeeded: new Set(this.fetchedResponses[userId]?.ifNeeded?.map(a => new Date(a).getTime())),\n            user: user\n          };\n        }\n        return parsed;\n      }\n\n      // Otherwise, parse responses so that if _id is null (i.e. guest user), then it is set to the guest user's name\n      for (const k of Object.keys(this.event.responses)) {\n        const newUser = {\n          ...this.event.responses[k].user,\n          _id: k\n        };\n        parsed[k] = {\n          ...this.event.responses[k],\n          availability: new Set(this.fetchedResponses[k]?.availability?.map(a => new Date(a).getTime())),\n          ifNeeded: new Set(this.fetchedResponses[k]?.ifNeeded?.map(a => new Date(a).getTime())),\n          user: newUser\n        };\n      }\n      return parsed;\n    },\n    max() {\n      let max = 0;\n      for (const [dateTime, availability] of this.responsesFormatted) {\n        if (availability.size > max) {\n          max = availability.size;\n        }\n      }\n      return max;\n    },\n    /** Returns a set containing the times for the event if it has specific times */\n    specificTimesSet() {\n      return new Set(this.event.times?.map(t => new Date(t).getTime()) ?? []);\n    },\n    /**\n     * Returns a two dimensional array of times\n     * IF endTime < startTime:\n     * the first element is an array of times between 12am and end time and the second element is an array of times between start time and 12am\n     * ELSE:\n     * the first element is an array of times between start time and end time. the second element is an empty array\n     * */\n    splitTimes() {\n      const splitTimes = [[], []];\n      const utcStartTime = this.event.startTime;\n      const utcEndTime = this.event.startTime + this.event.duration;\n      const localStartTime = utcTimeToLocalTime(utcStartTime, this.timezoneOffset);\n      const localEndTime = utcTimeToLocalTime(utcEndTime, this.timezoneOffset);\n\n      // Weird timezones are timezones that are not a multiple of 60 minutes (e.g. GMT-2:30)\n      const isWeirdTimezone = this.timezoneOffset % 60 !== 0;\n      const startTimeIsWeird = utcStartTime % 1 !== 0;\n      let timeOffset = 0;\n      if (isWeirdTimezone !== startTimeIsWeird) {\n        timeOffset = -0.5;\n      }\n      const getExtraTimes = hoursOffset => {\n        if (this.timeslotDuration === timeslotDurations.FIFTEEN_MINUTES) {\n          return [{\n            hoursOffset: hoursOffset + 0.25\n          }, {\n            hoursOffset: hoursOffset + 0.5\n          }, {\n            hoursOffset: hoursOffset + 0.75\n          }];\n        } else if (this.timeslotDuration === timeslotDurations.THIRTY_MINUTES) {\n          return [{\n            hoursOffset: hoursOffset + 0.5\n          }];\n        }\n        return [];\n      };\n      if (this.state === this.states.SET_SPECIFIC_TIMES) {\n        // Hours offset for specific times starts from minHours\n        for (let i = 0; i <= 23; ++i) {\n          const hoursOffset = i;\n          if (i === 9) {\n            // add an id so we can scroll to it\n            splitTimes[0].push({\n              id: \"time-9\",\n              hoursOffset,\n              text: timeNumToTimeText(i, this.timeType === timeTypes.HOUR12)\n            });\n          } else {\n            splitTimes[0].push({\n              hoursOffset,\n              text: timeNumToTimeText(i, this.timeType === timeTypes.HOUR12)\n            });\n          }\n          splitTimes[0].push(...getExtraTimes(hoursOffset));\n        }\n        return splitTimes;\n      }\n      if (localEndTime <= localStartTime && localEndTime !== 0) {\n        for (let i = 0; i < localEndTime; ++i) {\n          splitTimes[0].push({\n            hoursOffset: this.event.duration - (localEndTime - i),\n            text: timeNumToTimeText(i, this.timeType === timeTypes.HOUR12)\n          });\n          splitTimes[0].push(...getExtraTimes(this.event.duration - (localEndTime - i)));\n        }\n        for (let i = 0; i < 24 - localStartTime; ++i) {\n          const adjustedI = i + timeOffset;\n          splitTimes[1].push({\n            hoursOffset: adjustedI,\n            text: timeNumToTimeText(localStartTime + adjustedI, this.timeType === timeTypes.HOUR12)\n          });\n          splitTimes[1].push(...getExtraTimes(adjustedI));\n        }\n      } else {\n        for (let i = 0; i < this.event.duration; ++i) {\n          const adjustedI = i + timeOffset;\n          const utcTimeNum = this.event.startTime + adjustedI;\n          const localTimeNum = utcTimeToLocalTime(utcTimeNum, this.timezoneOffset);\n          splitTimes[0].push({\n            hoursOffset: adjustedI,\n            text: timeNumToTimeText(localTimeNum, this.timeType === timeTypes.HOUR12)\n          });\n          splitTimes[0].push(...getExtraTimes(adjustedI));\n        }\n        if (timeOffset !== 0) {\n          const localTimeNum = utcTimeToLocalTime(this.event.startTime + this.event.duration - 0.5, this.timezoneOffset);\n          splitTimes[0].push({\n            hoursOffset: this.event.duration - 0.5,\n            text: timeNumToTimeText(localTimeNum, this.timeType === timeTypes.HOUR12)\n          });\n          splitTimes[0].push(...getExtraTimes(this.event.duration - 0.5));\n        }\n        splitTimes[1] = [];\n      }\n      return splitTimes;\n    },\n    /** Returns the times that are encompassed by startTime and endTime */\n    times() {\n      return [...this.splitTimes[1], ...this.splitTimes[0]];\n    },\n    timeslotDuration() {\n      return this.event.timeIncrement ?? timeslotDurations.FIFTEEN_MINUTES;\n    },\n    timeslotHeight() {\n      if (this.timeslotDuration === timeslotDurations.FIFTEEN_MINUTES) {\n        return Math.floor(this.HOUR_HEIGHT / 4);\n      } else if (this.timeslotDuration === timeslotDurations.THIRTY_MINUTES) {\n        return Math.floor(this.HOUR_HEIGHT / 2);\n      } else if (this.timeslotDuration === timeslotDurations.ONE_HOUR) {\n        return this.HOUR_HEIGHT;\n      }\n      return Math.floor(this.HOUR_HEIGHT / 4);\n    },\n    timezoneOffset() {\n      if (!(\"offset\" in this.curTimezone)) {\n        return new Date().getTimezoneOffset();\n      }\n      if (this.event.type === eventTypes.DOW) {\n        return this.curTimezone.offset * -1;\n      }\n\n      // Can't just get the offset directly from curTimezone because it doesn't account for dates in the future\n      // when daylight savings might be in or out of effect, so instead, we get the timezone for the first date\n      // of the event\n      return dayjs(this.event.dates[0]).tz(this.curTimezone.value).utcOffset() * -1 // Multiply by -1 because offset is flipped\n      ;\n    },\n    userHasResponded() {\n      return this.authUser && this.authUser._id in this.parsedResponses;\n    },\n    showLeftZigZag() {\n      return this.calendarScrollLeft > 0;\n    },\n    showRightZigZag() {\n      return Math.ceil(this.calendarScrollLeft) < this.calendarMaxScroll;\n    },\n    maxDaysPerPage() {\n      return this.isPhone ? this.mobileNumDays : 7;\n    },\n    hasNextPage() {\n      if (this.event.daysOnly) {\n        const lastDay = new Date(this.event.dates[this.event.dates.length - 1]);\n        const curDate = new Date(this.event.dates[0]);\n        const monthIndex = curDate.getUTCMonth() + this.page;\n        const year = curDate.getUTCFullYear();\n        const lastDayOfCurMonth = new Date(Date.UTC(year, monthIndex + 1, 0));\n        return lastDayOfCurMonth.getTime() < lastDay.getTime();\n      }\n      return this.allDays.length - (this.page + 1) * this.maxDaysPerPage > 0 || this.event.type === eventTypes.GROUP;\n    },\n    hasPrevPage() {\n      return this.page > 0 || this.event.type === eventTypes.GROUP;\n    },\n    /** Returns whether the event has more than one page */\n    hasPages() {\n      return this.hasNextPage || this.hasPrevPage;\n    },\n    showStickyRespondents() {\n      return this.isPhone && !this.scrolledToRespondents && (this.curTimeslot.row !== -1 || this.curRespondent.length > 0 || this.curRespondents.length > 0);\n    },\n    // Hint stuff\n    hintText() {\n      if (this.isPhone) {\n        switch (this.state) {\n          case this.isGroup && this.states.EDIT_AVAILABILITY:\n            return \"Toggle which calendars are used. Tap and drag to edit your availability.\";\n          case this.states.EDIT_AVAILABILITY:\n            const daysOrTimes = this.event.daysOnly ? \"days\" : \"times\";\n            if (this.availabilityType === availabilityTypes.IF_NEEDED) {\n              return `Tap and drag to add your \"if needed\" ${daysOrTimes} in yellow.`;\n            }\n            return `Tap and drag to add your \"available\" ${daysOrTimes} in green.`;\n          case this.states.SCHEDULE_EVENT:\n            return \"Tap and drag on the calendar to schedule a Google Calendar event during those times.\";\n          default:\n            return \"\";\n        }\n      }\n      switch (this.state) {\n        case this.isGroup && this.states.EDIT_AVAILABILITY:\n          return \"Toggle which calendars are used. Click and drag to edit your availability.\";\n        case this.states.EDIT_AVAILABILITY:\n          const daysOrTimes = this.event.daysOnly ? \"days\" : \"times\";\n          if (this.availabilityType === availabilityTypes.IF_NEEDED) {\n            return `Click and drag to add your \"if needed\" ${daysOrTimes} in yellow.`;\n          }\n          return `Click and drag to add your \"available\" ${daysOrTimes} in green.`;\n        case this.states.SCHEDULE_EVENT:\n          return \"Click and drag on the calendar to schedule a Google Calendar event during those times.\";\n        default:\n          return \"\";\n      }\n    },\n    hintClosed() {\n      return !this.hintState || localStorage[this.hintStateLocalStorageKey];\n    },\n    hintStateLocalStorageKey() {\n      return `closedHintText${this.state}` + (\"&isGroup\" ? this.isGroup : \"\");\n    },\n    hintTextShown() {\n      return this.showHintText && this.hintText != \"\" && !this.hintClosed;\n    },\n    timeslotClassStyle() {\n      const classStyles = [];\n      for (let d = 0; d < this.days.length; ++d) {\n        const day = this.days[d];\n        for (let t = 0; t < this.splitTimes[0].length; ++t) {\n          const time = this.splitTimes[0][t];\n          classStyles.push(this.getTimeTimeslotClassStyle(day, time, d, t));\n        }\n        for (let t = 0; t < this.splitTimes[1].length; ++t) {\n          const time = this.splitTimes[1][t];\n          classStyles.push(this.getTimeTimeslotClassStyle(day, time, d, t + this.splitTimes[0].length));\n        }\n      }\n      return classStyles;\n    },\n    dayTimeslotClassStyle() {\n      const classStyles = [];\n      for (let i = 0; i < this.monthDays.length; ++i) {\n        classStyles.push(this.getDayTimeslotClassStyle(this.monthDays[i].dateObject, i));\n      }\n      return classStyles;\n    },\n    timeslotVon() {\n      const vons = [];\n      for (let d = 0; d < this.days.length; ++d) {\n        for (let t = 0; t < this.times.length; ++t) {\n          vons.push(this.getTimeslotVon(t, d));\n        }\n      }\n      return vons;\n    },\n    dayTimeslotVon() {\n      const vons = [];\n      for (let i = 0; i < this.monthDays.length; ++i) {\n        const row = Math.floor(i / 7);\n        const col = i % 7;\n        vons.push(this.getTimeslotVon(row, col));\n      }\n      return vons;\n    },\n    /** Whether to show spinner on top of availability grid */\n    showLoader() {\n      return (\n        // Loading calendar events\n        (this.isGroup || this.alwaysShowCalendarEvents || this.editing) && this.loadingCalendarEvents ||\n        // Loading responses\n        this.loadingResponses.loading\n      );\n    },\n    /** Localstorage key containing the guest's name */\n    guestNameKey() {\n      return `${this.event._id}.guestName`;\n    },\n    /** The guest name stored in localstorage */\n    guestName() {\n      return localStorage[this.guestNameKey];\n    },\n    /** Whether a guest has added their availability (saved in localstorage) */\n    guestAddedAvailability() {\n      return this.guestName?.length > 0 && this.guestName in this.parsedResponses;\n    },\n    /** Returns an array of time blocks representing the current user's availability\n     * (used for displaying current user's availability on top of everybody else's availability)\n     */\n    overlaidAvailability() {\n      const overlaidAvailability = [];\n      this.days.forEach((day, d) => {\n        overlaidAvailability.push([]);\n        let curBlockIndex = 0;\n        const addOverlaidAvailabilityBlocks = (time, t) => {\n          const date = this.getDateFromRowCol(t, d);\n          if (!date) return;\n          const dragAdd = this.dragging && this.inDragRange(t, d) && this.dragType === this.DRAG_TYPES.ADD;\n          const dragRemove = this.dragging && this.inDragRange(t, d) && this.dragType === this.DRAG_TYPES.REMOVE;\n\n          // Check if timeslot is available or if needed or in the drag region\n          if (dragAdd || !dragRemove && (this.availability.has(date.getTime()) || this.ifNeeded.has(date.getTime()))) {\n            // Determine whether to render as available or if needed block\n            let type = availabilityTypes.AVAILABLE;\n            if (dragAdd) {\n              type = this.availabilityType;\n            } else {\n              type = this.availability.has(date.getTime()) ? availabilityTypes.AVAILABLE : availabilityTypes.IF_NEEDED;\n            }\n            if (curBlockIndex in overlaidAvailability[d]) {\n              if (overlaidAvailability[d][curBlockIndex].type === type) {\n                // Increase block length if matching type and curBlockIndex exists\n                overlaidAvailability[d][curBlockIndex].hoursLength += 0.25;\n              } else {\n                // Add a new block because type is different\n                overlaidAvailability[d].push({\n                  hoursOffset: time.hoursOffset,\n                  hoursLength: 0.25,\n                  type\n                });\n                curBlockIndex++;\n              }\n            } else {\n              // Add a new block because block doesn't exist for current index\n              overlaidAvailability[d].push({\n                hoursOffset: time.hoursOffset,\n                hoursLength: 0.25,\n                type\n              });\n            }\n          } else if (curBlockIndex in overlaidAvailability[d]) {\n            // Only increment cur block index if block already exists at the current index\n            curBlockIndex++;\n          }\n        };\n        for (let t = 0; t < this.splitTimes[0].length; ++t) {\n          addOverlaidAvailabilityBlocks(this.splitTimes[0][t], t);\n        }\n        if (curBlockIndex in overlaidAvailability[d]) {\n          curBlockIndex++;\n        }\n        for (let t = 0; t < this.splitTimes[1].length; ++t) {\n          addOverlaidAvailabilityBlocks(this.splitTimes[1][t], t + this.splitTimes[0].length);\n        }\n      });\n      return overlaidAvailability;\n    },\n    // Options\n    showOverlayAvailabilityToggle() {\n      return this.respondents.length > 0 && this.overlayAvailabilitiesEnabled;\n    },\n    showCalendarOptions() {\n      return !this.addingAvailabilityAsGuest && this.calendarPermissionGranted && (this.isGroup || !this.isGroup && !this.userHasResponded);\n    },\n    /** Returns an array of the x-offsets of the columns, taking into account the split gaps from non-consecutive days */\n    columnOffsets() {\n      const offsets = [];\n      let accumulatedOffset = 0;\n      for (let i = 0; i < this.days.length; ++i) {\n        offsets.push(accumulatedOffset);\n        if (!this.days[i].isConsecutive) {\n          accumulatedOffset += this.SPLIT_GAP_WIDTH;\n        }\n        accumulatedOffset += this.timeslot.width;\n      }\n      return offsets;\n    }\n  },\n  methods: {\n    ...mapMutations([\"setAuthUser\"]),\n    ...mapActions([\"showInfo\", \"showError\", \"showUpgradeDialog\"]),\n    // -----------------------------------\n    //#region Date\n    // -----------------------------------\n\n    /** Returns a date object from the dayindex and hoursoffset given */\n    getDateFromDayHoursOffset(dayIndex, hoursOffset) {\n      return getDateHoursOffset(this.days[dayIndex].dateObject, hoursOffset);\n    },\n    /** Returns a date object from the row and column given on the current page */\n    getDateFromRowCol(row, col) {\n      if (this.event.daysOnly) {\n        const dateObject = this.monthDays[row * 7 + col]?.dateObject;\n        if (!dateObject) return null;\n        return new Date(dateObject);\n      } else {\n        return this.getDateFromDayTimeIndex(this.maxDaysPerPage * this.page + col, row);\n      }\n    },\n    isColConsecutive(col) {\n      return Boolean(this.days[col]?.isConsecutive);\n    },\n    /** Returns a date object from the day index and time index given */\n    getDateFromDayTimeIndex(dayIndex, timeIndex) {\n      const hasSecondSplit = this.splitTimes[1].length > 0;\n      const isFirstSplit = timeIndex < this.splitTimes[0].length;\n      const time = isFirstSplit ? this.splitTimes[0][timeIndex] : this.splitTimes[1][timeIndex - this.splitTimes[0].length];\n      let adjustedDayIndex = dayIndex;\n      if (hasSecondSplit) {\n        if (isFirstSplit) {\n          adjustedDayIndex = dayIndex - 1;\n        } else if (dayIndex === this.allDays.length - 1) {\n          return null;\n        }\n      }\n      const day = this.allDays[adjustedDayIndex];\n      if (!day || !time) return null;\n      if (day.excludeTimes) {\n        return null;\n      }\n      const date = getDateHoursOffset(day.dateObject, time.hoursOffset);\n      if (this.isSpecificTimes) {\n        // TODO: see if we need to do anything for 0.5 timezones\n        if (this.state !== this.states.SET_SPECIFIC_TIMES && this.event.times?.length > 0) {\n          if (!this.specificTimesSet.has(date.getTime())) {\n            return null;\n          }\n        }\n      } else {\n        // Return null for times outside of the correct range\n        if (time.hoursOffset < 0 || time.hoursOffset >= this.event.duration) {\n          return null;\n        }\n      }\n      return date;\n    },\n    //#endregion\n\n    // -----------------------------------\n    //#region Respondent\n    // -----------------------------------\n    mouseOverRespondent(e, id) {\n      if (this.curRespondents.length === 0) {\n        if (this.state === this.defaultState) {\n          this.state = this.states.SINGLE_AVAILABILITY;\n        }\n        this.curRespondent = id;\n      }\n    },\n    mouseLeaveRespondent(e) {\n      if (this.curRespondents.length === 0) {\n        if (this.state === this.states.SINGLE_AVAILABILITY) {\n          this.state = this.defaultState;\n        }\n        this.curRespondent = \"\";\n      }\n    },\n    clickRespondent(e, id) {\n      this.state = this.states.SUBSET_AVAILABILITY;\n      this.curRespondent = \"\";\n      if (this.curRespondentsSet.has(id)) {\n        // Remove id\n        this.curRespondents = this.curRespondents.filter(r => r != id);\n\n        // Go back to default state if all users deselected\n        if (this.curRespondents.length === 0) {\n          this.state = this.defaultState;\n        }\n      } else {\n        // Add id\n        this.curRespondents.push(id);\n      }\n      e.stopPropagation();\n    },\n    deselectRespondents(e) {\n      // Don't deselect respondents if toggled best times\n      // or if this was fired by clicking on a timeslot\n      if (e?.target?.previousElementSibling?.id === \"show-best-times-toggle\" || e?.target?.firstChild?.firstChild?.id === \"show-best-times-toggle\" || e?.target?.classList?.contains(\"timeslot\") //&& this.isPhone)\n      ) return;\n      if (this.state === this.states.SUBSET_AVAILABILITY) {\n        this.state = this.defaultState;\n      }\n      this.curRespondents = [];\n\n      // Stop persisting timeslot\n      this.timeslotSelected = false;\n      this.resetCurTimeslot();\n    },\n    isGuest(user) {\n      return user._id == user.firstName;\n    },\n    //#endregion\n\n    // -----------------------------------\n    //#region Aggregate user availability\n    // -----------------------------------\n\n    /** Fetches responses from server */\n    fetchResponses() {\n      if (this.calendarOnly) {\n        this.fetchedResponses = this.event.responses;\n        return;\n      }\n      let timeMin, timeMax;\n      if (this.event.type === eventTypes.GROUP) {\n        if (this.event.dates.length > 0) {\n          // Fetch the date range for the current week\n          timeMin = new Date(this.event.dates[0]);\n          timeMax = new Date(this.event.dates[this.event.dates.length - 1]);\n          timeMax.setDate(timeMax.getDate() + 1);\n\n          // Convert dow dates to discrete dates\n          timeMin = dateToDowDate(this.event.dates, timeMin, this.weekOffset, true);\n          timeMax = dateToDowDate(this.event.dates, timeMax, this.weekOffset, true);\n        }\n      } else {\n        if (this.allDays.length > 0) {\n          // Fetch the entire time range of availabilities\n          timeMin = new Date(this.allDays[0].dateObject);\n          timeMax = new Date(this.allDays[this.allDays.length - 1].dateObject);\n          timeMax.setDate(timeMax.getDate() + 1);\n        }\n      }\n      if (!timeMin || !timeMax) return;\n\n      // Fetch responses between timeMin and timeMax\n      const url = `/events/${this.event._id}/responses?timeMin=${timeMin.toISOString()}&timeMax=${timeMax.toISOString()}`;\n      get(url).then(responses => {\n        this.fetchedResponses = responses;\n        this.getResponsesFormatted();\n      }).catch(err => {\n        this.showError(\"There was an error fetching availability! Please refresh the page.\");\n      });\n    },\n    /** Formats the responses in a map where date/time is mapped to the people that are available then */\n    getResponsesFormatted() {\n      const lastFetched = new Date().getTime();\n      this.loadingResponses.loading = true;\n      this.loadingResponses.lastFetched = lastFetched;\n      this.$worker.run((days, times, parsedResponses, daysOnly, hideIfNeeded) => {\n        // Define functions locally because we can't import functions\n        const splitTimeNum = timeNum => {\n          const hours = Math.floor(timeNum);\n          const minutes = Math.floor((timeNum - hours) * 60);\n          return {\n            hours,\n            minutes\n          };\n        };\n        const getDateHoursOffset = (date, hoursOffset) => {\n          const {\n            hours,\n            minutes\n          } = splitTimeNum(hoursOffset);\n          const newDate = new Date(date);\n          newDate.setHours(newDate.getHours() + hours);\n          newDate.setMinutes(newDate.getMinutes() + minutes);\n          return newDate;\n        };\n\n        // Create array of all dates in the event\n        const dates = [];\n        if (daysOnly) {\n          for (const day of days) {\n            dates.push(day.dateObject);\n          }\n        } else {\n          for (const day of days) {\n            for (const time of times) {\n              // Iterate through all the times\n              const date = getDateHoursOffset(day.dateObject, time.hoursOffset);\n              dates.push(date);\n            }\n          }\n        }\n\n        // Create a map mapping time to the respondents available during that time\n        const formatted = new Map();\n        for (const date of dates) {\n          formatted.set(date.getTime(), new Set());\n\n          // Check every response and see if they are available for the given time\n          for (const response of Object.values(parsedResponses)) {\n            // Check availability array\n            if (response.availability?.has(date.getTime()) || response.ifNeeded?.has(date.getTime()) && !hideIfNeeded) {\n              formatted.get(date.getTime()).add(response.user._id);\n              continue;\n            }\n          }\n        }\n        return formatted;\n      }, [this.allDays, this.times, this.parsedResponses, this.event.daysOnly, this.hideIfNeeded]).then(formatted => {\n        // Only set responses formatted for the latest request\n        if (lastFetched >= this.loadingResponses.lastFetched) {\n          this.responsesFormatted = formatted;\n        }\n      }).finally(() => {\n        if (this.loadingResponses.lastFetched === lastFetched) {\n          this.loadingResponses.loading = false;\n        }\n      });\n    },\n    /** Returns a set of respondents for the given date/time */\n    getRespondentsForHoursOffset(date, hoursOffset) {\n      const d = getDateHoursOffset(date, hoursOffset);\n      return this.responsesFormatted.get(d.getTime()) ?? new Set();\n    },\n    showAvailability(row, col) {\n      if (this.state === this.states.EDIT_AVAILABILITY && this.isPhone) {\n        // Don't show currently selected timeslot when on phone and editing\n        return;\n      }\n\n      // Update current timeslot (the timeslot that has a dotted border around it)\n      this.curTimeslot = {\n        row,\n        col\n      };\n      if (this.state === this.states.EDIT_AVAILABILITY || this.curRespondent) {\n        // Don't show availability when editing or when respondent is selected\n        return;\n      }\n      const date = this.getDateFromRowCol(row, col);\n      if (!date) return;\n\n      // Update current timeslot availability to show who is available for the given timeslot\n      const available = this.responsesFormatted.get(date.getTime()) ?? new Set();\n      for (const respondent of this.respondents) {\n        if (available.has(respondent._id)) {\n          this.curTimeslotAvailability[respondent._id] = true;\n        } else {\n          this.curTimeslotAvailability[respondent._id] = false;\n        }\n      }\n    },\n    //#endregion\n\n    // -----------------------------------\n    //#region Current user availability\n    // -----------------------------------\n    async refreshAuthUser() {\n      this.hasRefreshedAuthUser = true;\n      await get(\"/user/profile\").then(authUser => {\n        this.setAuthUser(authUser);\n      });\n    },\n    /** resets cur user availability to the response stored on the server */\n    resetCurUserAvailability() {\n      if (this.event.type === eventTypes.GROUP) {\n        this.initSharedCalendarAccounts();\n        this.manualAvailability = {};\n      }\n      this.availability = new Set();\n      this.ifNeeded = new Set();\n      if (this.userHasResponded) {\n        this.populateUserAvailability(this.authUser._id);\n      }\n    },\n    /** Populates the availability set for the auth user from the responses object stored on the server */\n    populateUserAvailability(id) {\n      this.availability = new Set(this.parsedResponses[id]?.availability) ?? new Set();\n      this.ifNeeded = new Set(this.parsedResponses[id]?.ifNeeded) ?? new Set();\n      this.$nextTick(() => this.unsavedChanges = false);\n    },\n    /** Returns true if the calendar event is in the first split */\n    getIsTimeBlockInFirstSplit(timeBlock) {\n      return timeBlock.hoursOffset >= this.splitTimes[0][0].hoursOffset && timeBlock.hoursOffset <= this.splitTimes[0][this.splitTimes[0].length - 1].hoursOffset;\n    },\n    /** Returns the style for the calendar event block */\n    getTimeBlockStyle(timeBlock) {\n      const style = {};\n      const hasSecondSplit = this.splitTimes[1].length > 0;\n      if (!hasSecondSplit || this.getIsTimeBlockInFirstSplit(timeBlock)) {\n        style.top = `calc(${timeBlock.hoursOffset - this.splitTimes[0][0].hoursOffset} * ${this.HOUR_HEIGHT}px)`;\n        style.height = `calc(${timeBlock.hoursLength} * ${this.HOUR_HEIGHT}px)`;\n      } else {\n        style.top = `calc(${this.splitTimes[0].length} * ${this.timeslotHeight}px + ${this.SPLIT_GAP_HEIGHT}px + ${timeBlock.hoursOffset - this.splitTimes[1][0].hoursOffset} * ${this.HOUR_HEIGHT}px)`;\n        style.height = `calc(${timeBlock.hoursLength} * ${this.HOUR_HEIGHT}px)`;\n      }\n      return style;\n    },\n    /** Returns a set containing the available times based on the given calendar events object */\n    getAvailabilityFromCalendarEvents({\n      calendarEventsByDay = [],\n      includeTouchedAvailability = false,\n      // Whether to include manual availability for touched days\n      fetchedManualAvailability = {},\n      // Object mapping unix timestamp to array of manual availability (fetched from server)\n      curManualAvailability = {},\n      // Manual availability with edits (takes precedence over fetchedManualAvailability)\n      calendarOptions = calendarOptionsDefaults // User id of the user we are getting availability for\n    }) {\n      const availability = new Set();\n      for (let i = 0; i < this.allDays.length; ++i) {\n        const day = this.allDays[i];\n        const date = day.dateObject;\n        if (includeTouchedAvailability) {\n          const endDate = getDateHoursOffset(date, this.times.length * (this.timeslotDuration / 60));\n\n          // Check if manual availability has been added for the current date\n          let manualAvailabilityAdded = false;\n          for (const time in curManualAvailability) {\n            if (date.getTime() <= time && time <= endDate.getTime()) {\n              curManualAvailability[time].forEach(a => {\n                availability.add(new Date(a).getTime());\n              });\n              delete curManualAvailability[time];\n              manualAvailabilityAdded = true;\n              break;\n            }\n          }\n          if (manualAvailabilityAdded) continue;\n          for (const time in fetchedManualAvailability) {\n            if (date.getTime() <= time && time <= endDate.getTime()) {\n              fetchedManualAvailability[time].forEach(a => {\n                availability.add(new Date(a).getTime());\n              });\n              delete fetchedManualAvailability[time];\n              manualAvailabilityAdded = true;\n              break;\n            }\n          }\n          if (manualAvailabilityAdded) continue;\n        }\n\n        // Calculate buffer time\n        const bufferTimeInMS = calendarOptions.bufferTime.enabled ? calendarOptions.bufferTime.time * 1000 * 60 : 0;\n\n        // Calculate working hours\n        const startTimeString = timeNumToTimeString(calendarOptions.workingHours.startTime);\n        const isoDateString = getISODateString(getDateWithTimezone(date), true);\n        const workingHoursStartDate = dayjs.tz(`${isoDateString} ${startTimeString}`, this.curTimezone.value).toDate();\n        let duration = calendarOptions.workingHours.endTime - calendarOptions.workingHours.startTime;\n        if (duration <= 0) duration += 24;\n        const workingHoursEndDate = getDateHoursOffset(workingHoursStartDate, duration);\n        for (let j = 0; j < this.times.length; ++j) {\n          const startDate = this.getDateFromDayTimeIndex(i, j);\n          if (!startDate) continue;\n          const endDate = getDateHoursOffset(startDate, this.timeslotDuration / 60);\n\n          // Working hours\n          if (calendarOptions.workingHours.enabled) {\n            if (endDate.getTime() <= workingHoursStartDate.getTime() || startDate.getTime() >= workingHoursEndDate.getTime()) {\n              continue;\n            }\n          }\n\n          // Check if there exists a calendar event that overlaps [startDate, endDate]\n          const index = calendarEventsByDay[i]?.findIndex(e => {\n            const startDateBuffered = new Date(e.startDate.getTime() - bufferTimeInMS);\n            const endDateBuffered = new Date(e.endDate.getTime() + bufferTimeInMS);\n            const notIntersect = dateCompare(endDate, startDateBuffered) <= 0 || dateCompare(startDate, endDateBuffered) >= 0;\n            return !notIntersect && !e.free;\n          });\n          if (index === -1) {\n            availability.add(startDate.getTime());\n          }\n        }\n      }\n      return availability;\n    },\n    /** Constructs the availability array using calendarEvents array */\n    setAvailabilityAutomatically() {\n      // This is not a computed property because we should be able to change it manually from what it automatically fills in\n      this.availability = new Set();\n      const tmpAvailability = this.getAvailabilityFromCalendarEvents({\n        calendarEventsByDay: this.calendarEventsByDay,\n        calendarOptions: {\n          bufferTime: this.bufferTime,\n          workingHours: this.workingHours\n        }\n      });\n      const pageStartDate = getDateDayOffset(new Date(this.event.dates[0]), this.page * this.maxDaysPerPage);\n      const pageEndDate = getDateDayOffset(pageStartDate, this.maxDaysPerPage);\n      this.animateAvailability(tmpAvailability, pageStartDate, pageEndDate);\n    },\n    /** Animate the filling out of availability using setTimeout, between startDate and endDate */\n    animateAvailability(availability, startDate, endDate) {\n      this.availabilityAnimEnabled = true;\n      this.availabilityAnimTimeouts = [];\n      let msPerGroup = 25;\n      let blocksPerGroup = 2;\n      if (availability.size / blocksPerGroup * msPerGroup > this.maxAnimTime) {\n        blocksPerGroup = availability.size * msPerGroup / this.maxAnimTime;\n      }\n      let availabilityArray = [...availability];\n      availabilityArray = availabilityArray.filter(a => isDateBetween(a, startDate, endDate));\n      for (let i = 0; i < availabilityArray.length / blocksPerGroup + 1; ++i) {\n        const timeout = setTimeout(() => {\n          for (const a of availabilityArray.slice(i * blocksPerGroup, i * blocksPerGroup + blocksPerGroup)) {\n            this.availability.add(a);\n          }\n          this.availability = new Set(this.availability);\n          if (i >= availabilityArray.length / blocksPerGroup) {\n            // Make sure the entire availability has been added (will not be guaranteed when only animating a portion of availability)\n            this.availability = new Set(availability);\n            this.availabilityAnimTimeouts.push(setTimeout(() => {\n              this.availabilityAnimEnabled = false;\n              if (this.showSnackbar) {\n                this.showInfo(\"Your availability has been autofilled!\");\n              }\n              this.unsavedChanges = false;\n            }, 500));\n          }\n        }, i * msPerGroup);\n        this.availabilityAnimTimeouts.push(timeout);\n      }\n    },\n    stopAvailabilityAnim() {\n      for (const timeout of this.availabilityAnimTimeouts) {\n        clearTimeout(timeout);\n      }\n      this.availabilityAnimEnabled = false;\n    },\n    async submitAvailability(guestPayload = {\n      name: \"\",\n      email: \"\"\n    }) {\n      let payload = {};\n      let type = \"\";\n      // If this is a group submit enabled calendars, otherwise submit availability\n      if (this.isGroup) {\n        type = \"group availability and calendars\";\n        payload = generateEnabledCalendarsPayload(this.sharedCalendarAccounts);\n        payload.manualAvailability = {};\n        for (const day of Object.keys(this.manualAvailability)) {\n          payload.manualAvailability[day] = [...this.manualAvailability[day]].map(a => new Date(a));\n        }\n        payload.calendarOptions = {\n          bufferTime: this.bufferTime,\n          workingHours: this.workingHours\n        };\n      } else {\n        type = \"availability\";\n        payload.availability = this.availabilityArray;\n        payload.ifNeeded = this.ifNeededArray;\n        if (this.authUser && !this.addingAvailabilityAsGuest) {\n          payload.guest = false;\n        } else {\n          payload.guest = true;\n          payload.name = guestPayload.name;\n          payload.email = guestPayload.email;\n          localStorage[this.guestNameKey] = guestPayload.name;\n        }\n      }\n      await post(`/events/${this.event._id}/response`, payload);\n\n      // Update analytics\n      const addedIfNeededTimes = this.ifNeededArray.length > 0;\n      if (this.authUser) {\n        if (this.authUser._id in this.parsedResponses) {\n          this.$posthog?.capture(`Edited ${type}`, {\n            eventId: this.event._id,\n            addedIfNeededTimes\n          });\n        } else {\n          this.$posthog?.capture(`Added ${type}`, {\n            eventId: this.event._id,\n            addedIfNeededTimes,\n            // bufferTime: this.bufferTime,\n            bufferTime: this.bufferTime.time,\n            bufferTimeActive: this.bufferTime.enabled,\n            workingHoursEnabled: this.workingHours.enabled,\n            workingHoursStartTime: this.workingHours.startTime,\n            workingHoursEndTime: this.workingHours.endTime\n          });\n        }\n      } else {\n        if (guestPayload.name in this.parsedResponses) {\n          this.$posthog?.capture(`Edited ${type} as guest`, {\n            eventId: this.event._id,\n            addedIfNeededTimes\n          });\n        } else {\n          this.$posthog?.capture(`Added ${type} as guest`, {\n            eventId: this.event._id,\n            addedIfNeededTimes\n          });\n        }\n      }\n      this.refreshEvent();\n      this.unsavedChanges = false;\n    },\n    async submitNewSignUpBlocks() {\n      if (this.signUpBlocksToAddByDay.flat().length + this.signUpBlocksByDay.flat().length === 0) {\n        this.showError(\"Please add at least one sign-up block!\");\n        return false;\n      }\n      for (let i = 0; i < this.signUpBlocksToAddByDay.length; ++i) {\n        this.signUpBlocksByDay[i] = this.signUpBlocksByDay[i].concat(this.signUpBlocksToAddByDay[i]);\n        this.signUpBlocksToAddByDay[i] = [];\n      }\n      const payload = {\n        name: this.event.name,\n        duration: this.event.duration,\n        dates: this.event.dates,\n        type: this.event.type,\n        signUpBlocks: this.signUpBlocksByDay.flat().map(block => {\n          return {\n            _id: block._id,\n            name: block.name,\n            capacity: block.capacity,\n            startDate: block.startDate,\n            endDate: block.endDate\n          };\n        })\n      };\n      put(`/events/${this.event._id}`, payload).then(() => {\n        // window.location.reload()\n      }).catch(err => {\n        console.error(err);\n        this.showError(\"There was a problem editing this event! Please try again later.\");\n      });\n      return true;\n    },\n    async deleteAvailability(name = \"\") {\n      const payload = {};\n      if (this.authUser && !this.addingAvailabilityAsGuest) {\n        payload.guest = false;\n        payload.userId = this.authUser._id;\n        this.$posthog?.capture(\"Deleted availability\", {\n          eventId: this.event._id\n        });\n      } else {\n        payload.guest = true;\n        payload.name = name;\n        this.$posthog?.capture(\"Deleted availability as guest\", {\n          eventId: this.event._id,\n          name\n        });\n      }\n      await _delete(`/events/${this.event._id}/response`, payload);\n      this.availability = new Set();\n      if (this.isGroup) this.$router.replace({\n        name: \"home\"\n      });else this.refreshEvent();\n    },\n    //#endregion\n\n    // -----------------------------------\n    //#region Timeslot\n    // -----------------------------------\n    setTimeslotSize() {\n      /* Gets the dimensions of each timeslot and assigns it to the timeslot variable */\n      const timeslotEl = document.querySelector(\".timeslot\");\n      if (timeslotEl) {\n        ;\n        ({\n          width: this.timeslot.width,\n          height: this.timeslot.height\n        } = timeslotEl.getBoundingClientRect());\n      }\n    },\n    /** Returns a class string and style object for the given time timeslot div */\n    getTimeTimeslotClassStyle(day, time, d, t) {\n      const row = t;\n      const col = d;\n      const date = this.getDateFromRowCol(row, col);\n      const classStyle = this.getTimeslotClassStyle(date, row, col);\n\n      // Add time timeslot specific stuff\n      const isFirstSplit = t < this.splitTimes[0].length;\n      const isDisabled = !date;\n\n      // Animation\n      if (this.animateTimeslotAlways || this.availabilityAnimEnabled) {\n        classStyle.class += \"animate-bg-color \";\n      }\n\n      // Height\n      classStyle.style.height = `${this.timeslotHeight}px`;\n\n      // Border style\n      if ((this.respondents.length > 0 || this.editing || this.state === this.states.SET_SPECIFIC_TIMES) && this.curTimeslot.row === row && this.curTimeslot.col === col && !isDisabled) {\n        // Dashed border for currently selected timeslot\n        classStyle.class += \"tw-border tw-border-dashed tw-border-black tw-z-10 \";\n      } else {\n        // Normal border\n        if (date) {\n          const localDate = new Date(date.getTime() - this.timezoneOffset * 60 * 1000);\n          const fractionalTime = localDate.getMinutes();\n          if (fractionalTime === 0) {\n            classStyle.class += \"tw-border-t \";\n          } else if (fractionalTime === 30) {\n            classStyle.class += \"tw-border-t \";\n            classStyle.style.borderTopStyle = \"dashed\";\n          }\n        }\n        classStyle.class += \"tw-border-r \";\n        if (col === 0 || !this.isColConsecutive(col)) classStyle.class += \"tw-border-l tw-border-l-gray \";\n        if (col === this.days.length - 1 || !this.isColConsecutive(col + 1)) classStyle.class += \"tw-border-r-gray \";\n        if (isFirstSplit && row === 0) classStyle.class += \"tw-border-t tw-border-t-gray \";\n        if (!isFirstSplit && row === this.splitTimes[0].length) classStyle.class += \"tw-border-t tw-border-t-gray \";\n        if (isFirstSplit && row === this.splitTimes[0].length - 1) classStyle.class += \"tw-border-b tw-border-b-gray \";\n        if (!isFirstSplit && row === this.splitTimes[0].length + this.splitTimes[1].length - 1) classStyle.class += \"tw-border-b tw-border-b-gray \";\n        const totalRespondents = this.state === this.states.SUBSET_AVAILABILITY ? this.curRespondents.length : this.respondents.length;\n        if (this.state === this.states.EDIT_AVAILABILITY || this.state === this.states.SINGLE_AVAILABILITY || totalRespondents === 1) {\n          classStyle.class += \"tw-border-[#999999] \";\n        } else {\n          classStyle.class += \"tw-border-[#DDDDDD99] \";\n        }\n      }\n\n      // Edit fill color and border color if day is not interactable\n      if (isDisabled) {\n        classStyle.class += \"tw-bg-light-gray-stroke tw-border-light-gray-stroke \";\n      }\n\n      // Change default red:\n      if (classStyle.style.backgroundColor === \"#E523230D\") {\n        classStyle.style.backgroundColor = \"#E5232333\";\n      }\n      return classStyle;\n    },\n    /** Returns the shared class string and style object for the given timeslot (either time timeslot or day timeslot) */\n    getTimeslotClassStyle(date, row, col) {\n      let c = \"\";\n      const s = {};\n      if (!date) return {\n        class: c,\n        style: s\n      };\n      const timeslotRespondents = this.responsesFormatted.get(date.getTime()) ?? new Set();\n\n      // Fill style\n\n      if (this.isSignUp) {\n        c += \"tw-bg-light-gray \";\n        return {\n          class: c,\n          style: s\n        };\n      }\n      if (!this.overlayAvailability && this.state === this.states.EDIT_AVAILABILITY || this.state === this.states.SET_SPECIFIC_TIMES) {\n        // Set default background color to red (unavailable)\n        s.backgroundColor = \"#E523230D\";\n\n        // Show only current user availability\n        const inDragRange = this.inDragRange(row, col);\n        if (inDragRange) {\n          // Set style if drag range goes over the current timeslot\n          if (this.dragType === this.DRAG_TYPES.ADD) {\n            if (this.state === this.states.SET_SPECIFIC_TIMES) {\n              c += \"tw-bg-white \";\n            } else {\n              if (this.availabilityType === availabilityTypes.AVAILABLE) {\n                s.backgroundColor = \"#00994C77\";\n              } else if (this.availabilityType === availabilityTypes.IF_NEEDED) {\n                c += \"tw-bg-yellow \";\n              }\n            }\n          } else if (this.dragType === this.DRAG_TYPES.REMOVE) {\n            if (this.state === this.states.SET_SPECIFIC_TIMES) {\n              c += \"tw-bg-gray \";\n            }\n          }\n        } else {\n          // Otherwise just show the current availability\n          // Show current availability from availability set\n          if (this.state === this.states.SET_SPECIFIC_TIMES) {\n            if (this.tempTimes.has(date.getTime())) {\n              c += \"tw-bg-white \";\n            } else {\n              c += \"tw-bg-gray \";\n            }\n          } else {\n            if (this.availability.has(date.getTime())) {\n              s.backgroundColor = \"#00994C77\";\n            } else if (this.ifNeeded.has(date.getTime())) {\n              c += \"tw-bg-yellow \";\n            }\n          }\n        }\n      }\n      if (this.state === this.states.SINGLE_AVAILABILITY) {\n        // Show only the currently selected respondent's availability\n        const respondent = this.curRespondent;\n        if (timeslotRespondents.has(respondent)) {\n          if (this.parsedResponses[respondent]?.ifNeeded?.has(date.getTime())) {\n            c += \"tw-bg-yellow \";\n          } else {\n            s.backgroundColor = \"#00994C77\";\n          }\n        } else {\n          s.backgroundColor = \"#E523230D\";\n        }\n        return {\n          class: c,\n          style: s\n        };\n      }\n      if (this.overlayAvailability || this.state === this.states.BEST_TIMES || this.state === this.states.HEATMAP || this.state === this.states.SCHEDULE_EVENT || this.state === this.states.SUBSET_AVAILABILITY) {\n        let numRespondents;\n        let max;\n        if (this.state === this.states.BEST_TIMES || this.state === this.states.HEATMAP || this.state === this.states.SCHEDULE_EVENT) {\n          numRespondents = timeslotRespondents.size;\n          max = this.max;\n        } else if (this.state === this.states.SUBSET_AVAILABILITY) {\n          numRespondents = [...timeslotRespondents].filter(r => this.curRespondentsSet.has(r)).length;\n          max = this.curRespondentsMax;\n        } else if (this.overlayAvailability) {\n          if ((this.userHasResponded || this.curGuestId?.length > 0) && timeslotRespondents.has(this.authUser?._id ?? this.curGuestId)) {\n            // Subtract 1 because we do not want to include current user's availability\n            numRespondents = timeslotRespondents.size - 1;\n            max = this.max;\n          } else {\n            numRespondents = timeslotRespondents.size;\n            max = this.max;\n          }\n        }\n        const totalRespondents = this.state === this.states.SUBSET_AVAILABILITY ? this.curRespondents.length : this.respondents.length;\n        if (this.defaultState === this.states.BEST_TIMES) {\n          if (max > 0 && numRespondents === max) {\n            // Only set timeslot to green for the times that most people are available\n            if (totalRespondents === 1 || this.overlayAvailability) {\n              // Make single responses less saturated\n              const green = \"#00994C88\";\n              s.backgroundColor = green;\n            } else {\n              const green = \"#00994C\";\n              s.backgroundColor = green;\n            }\n          }\n        } else if (this.defaultState === this.states.HEATMAP) {\n          if (numRespondents > 0) {\n            if (totalRespondents === 1) {\n              const respondentId = this.state === this.states.SUBSET_AVAILABILITY ? this.curRespondents[0] : this.respondents[0]._id;\n              if (this.parsedResponses[respondentId]?.ifNeeded?.has(date.getTime())) {\n                c += \"tw-bg-yellow \";\n              } else {\n                const green = \"#00994C88\";\n                s.backgroundColor = green;\n              }\n            } else {\n              // Determine color of timeslot based on number of people available\n              const frac = numRespondents / max;\n              const green = \"#00994C\";\n              let alpha;\n              if (!this.overlayAvailability) {\n                alpha = Math.floor(frac * (255 - 30)).toString(16).toUpperCase().substring(0, 2).padStart(2, \"0\");\n                if (frac == 1 && (this.curRespondents.length > 0 && max === this.curRespondents.length || this.curRespondents.length === 0 && max === this.respondents.length)) {\n                  alpha = \"FF\";\n                }\n              } else {\n                alpha = Math.floor(frac * (255 - 85)).toString(16).toUpperCase().substring(0, 2).padStart(2, \"0\");\n              }\n              s.backgroundColor = green + alpha;\n            }\n          } else if (totalRespondents === 1) {\n            const red = \"#E523230D\";\n            s.backgroundColor = red;\n          }\n        }\n      }\n      return {\n        class: c,\n        style: s\n      };\n    },\n    getDayTimeslotClassStyle(date, i) {\n      const row = Math.floor(i / 7);\n      const col = i % 7;\n      let classStyle;\n      // Only compute class style for days that are included\n      if (this.monthDayIncluded.get(date.getTime())) {\n        classStyle = this.getTimeslotClassStyle(date, row, col);\n        if (this.state === this.states.EDIT_AVAILABILITY) {\n          classStyle.class += \"tw-cursor-pointer \";\n        }\n        const backgroundColor = classStyle.style.backgroundColor;\n        if (backgroundColor && lightOrDark(removeTransparencyFromHex(backgroundColor)) === \"dark\") {\n          classStyle.class += \"tw-text-white \";\n        }\n      } else {\n        classStyle = {\n          class: \"tw-bg-off-white tw-text-gray \",\n          style: {}\n        };\n      }\n\n      // Change default red:\n      if (classStyle.style.backgroundColor === \"#E523230D\") {\n        classStyle.style.backgroundColor = \"#E523233B\";\n      }\n\n      // Change edit green\n      // if (classStyle.style.backgroundColor === \"#00994C88\") {\n      //   classStyle.style.backgroundColor = \"#29BC6880\"\n      // }\n\n      // Border style\n      if ((this.respondents.length > 0 || this.state === this.states.EDIT_AVAILABILITY) && this.curTimeslot.row === row && this.curTimeslot.col === col && this.monthDayIncluded.get(date.getTime())) {\n        // Dashed border for currently selected timeslot\n        classStyle.class += \"tw-outline-2 tw-outline-dashed tw-outline-black tw-z-10 \";\n      } else {\n        // Normal border\n        if (col === 0) classStyle.class += \"tw-border-l tw-border-l-gray \";\n        classStyle.class += \"tw-border-r tw-border-r-gray \";\n        if (col !== 7 - 1) {\n          classStyle.style.borderRightStyle = \"dashed\";\n        }\n        if (row === 0) classStyle.class += \"tw-border-t tw-border-t-gray \";\n        classStyle.class += \"tw-border-b tw-border-b-gray \";\n        if (row !== Math.floor(this.monthDays.length / 7) - 1) {\n          classStyle.style.borderBottomStyle = \"dashed\";\n        }\n      }\n      return classStyle;\n    },\n    getTimeslotVon(row, col) {\n      if (this.interactable) {\n        return {\n          click: () => {\n            if (this.timeslotSelected) {\n              // Get rid of persistent timeslot selection if clicked on the same timeslot that is currently being persisted\n              if (row === this.curTimeslot.row && col === this.curTimeslot.col) {\n                this.timeslotSelected = false;\n              }\n            } else if (this.state !== this.states.EDIT_AVAILABILITY && (this.userHasResponded || this.guestAddedAvailability)) {\n              // Persist timeslot selection if user has already responded\n              this.timeslotSelected = true;\n            }\n            this.showAvailability(row, col);\n          },\n          mousedown: () => {\n            // Highlight availability button\n            if (this.state === this.defaultState && (!this.isPhone && !(this.userHasResponded || this.guestAddedAvailability) || this.respondents.length == 0)) this.highlightAvailabilityBtn();\n          },\n          mouseover: () => {\n            // Only show availability on hover if timeslot is not being persisted\n            if (!this.timeslotSelected) {\n              this.showAvailability(row, col);\n              if (!this.event.daysOnly) {\n                const date = this.getDateFromRowCol(row, col);\n                if (date) {\n                  date.setTime(date.getTime() - this.timezoneOffset * 60 * 1000);\n                  const startDate = dayjs(date).utc();\n                  const endDate = dayjs(date).utc().add(this.timeslotDuration, \"minutes\");\n                  const timeFormat = this.timeType === timeTypes.HOUR12 ? \"h:mm A\" : \"HH:mm\";\n                  let dateFormat;\n                  if (this.isSpecificDates) {\n                    dateFormat = \"ddd, MMM D, YYYY\";\n                  } else {\n                    dateFormat = \"ddd\";\n                  }\n                  this.tooltipContent = `${startDate.format(dateFormat)} ${startDate.format(timeFormat)} to ${endDate.format(timeFormat)}`;\n                }\n              }\n            }\n          },\n          mouseleave: () => {\n            this.tooltipContent = \"\";\n          }\n        };\n      }\n      return {};\n    },\n    resetCurTimeslot() {\n      // Only reset cur timeslot if it isn't being persisted\n      if (this.timeslotSelected) return;\n      this.curTimeslotAvailability = {};\n      for (const respondent of this.respondents) {\n        this.curTimeslotAvailability[respondent._id] = true;\n      }\n      this.curTimeslot = {\n        row: -1,\n        col: -1\n      };\n\n      // End drag if mouse left time grid\n      this.endDrag();\n    },\n    //#endregion\n\n    // -----------------------------------\n    //#region Editing\n    // -----------------------------------\n    startEditing() {\n      this.state = this.isSignUp ? this.states.EDIT_SIGN_UP_BLOCKS : this.states.EDIT_AVAILABILITY;\n      this.availabilityType = availabilityTypes.AVAILABLE;\n      this.availability = new Set();\n      this.ifNeeded = new Set();\n      if (this.authUser && !this.addingAvailabilityAsGuest) {\n        this.resetCurUserAvailability();\n      }\n      this.$nextTick(() => this.unsavedChanges = false);\n      this.pageHasChanged = false;\n    },\n    stopEditing() {\n      this.state = this.defaultState;\n      this.stopAvailabilityAnim();\n\n      // Reset options\n      this.availabilityType = availabilityTypes.AVAILABLE;\n      this.overlayAvailability = false;\n    },\n    highlightAvailabilityBtn() {\n      this.$emit(\"highlightAvailabilityBtn\");\n    },\n    editGuestAvailability(id) {\n      if (this.authUser) {\n        this.$emit(\"addAvailabilityAsGuest\");\n      } else {\n        this.startEditing();\n      }\n      this.$nextTick(() => {\n        this.populateUserAvailability(id);\n        this.$emit(\"setCurGuestId\", id);\n      });\n    },\n    refreshEvent() {\n      this.$emit(\"refreshEvent\");\n    },\n    //#endregion\n\n    // -----------------------------------\n    //#region Schedule event\n    // -----------------------------------\n    scheduleEvent() {\n      this.state = this.states.SCHEDULE_EVENT;\n      this.$posthog?.capture(\"schedule_event_button_clicked\");\n    },\n    cancelScheduleEvent() {\n      this.state = this.defaultState;\n    },\n    /** Redirect user to Google Calendar to finish the creation of the event */\n    confirmScheduleEvent(googleCalendar = true) {\n      if (!this.curScheduledEvent) return;\n      // if (!isPremiumUser(this.authUser)) {\n      //   this.showUpgradeDialog({\n      //     type: upgradeDialogTypes.SCHEDULE_EVENT,\n      //     data: {\n      //       scheduledEvent: this.curScheduledEvent,\n      //     },\n      //   })\n      //   return\n      // }\n\n      this.$posthog?.capture(\"schedule_event_confirmed\");\n      // Get start date, and end date from the area that the user has dragged out\n      const {\n        col,\n        row,\n        numRows\n      } = this.curScheduledEvent;\n      let startDate = this.getDateFromRowCol(row, col);\n      let endDate = new Date(startDate);\n      endDate.setMinutes(startDate.getMinutes() + this.timeslotDuration * numRows);\n      if (this.isWeekly || this.isGroup) {\n        // Determine offset based on current day of the week.\n        // People expect the event to be scheduled in the future, not the past, which is why this check exists\n        let offset = 0;\n        if (this.isGroup) {\n          offset = this.weekOffset;\n        } else if (this.isWeekly) {\n          if (new Date().getDay() > startDate.getDay()) {\n            offset = 1;\n          }\n        }\n\n        // Transform startDate and endDate to be the current week offset\n        startDate = dateToDowDate(this.event.dates, startDate, offset, true);\n        endDate = dateToDowDate(this.event.dates, endDate, offset, true);\n      }\n\n      // Format email string separated by commas\n      const emails = this.respondents.map(r => {\n        // Return email if they are not a guest, otherwise return their name\n        if (r.email.length > 0) {\n          return r.email;\n        } else {\n          // return `${r.firstName} (no email)`\n          return null;\n        }\n      });\n      const emailsString = encodeURIComponent(emails.filter(Boolean).join(\",\"));\n      const eventId = this.event.shortId ?? this.event._id;\n      let url = \"\";\n      if (googleCalendar) {\n        // Format start and end date to be in the format required by gcal (remove -, :, and .000)\n        const start = startDate.toISOString().replace(/([-:]|\\.000)/g, \"\");\n        const end = endDate.toISOString().replace(/([-:]|\\.000)/g, \"\");\n\n        // Construct Google Calendar event creation template url\n        url = `https://calendar.google.com/calendar/render?action=TEMPLATE&text=${encodeURIComponent(this.event.name)}&dates=${start}/${end}&details=${encodeURIComponent(\"\\n\\nThis event was scheduled with schej: https://schej.it/e/\")}${eventId}&ctz=${this.curTimezone.value}&add=${emailsString}`;\n      } else {\n        url = `https://outlook.live.com/calendar/0/deeplink/compose?subject=${encodeURIComponent(this.event.name)}&body=${encodeURIComponent(\"\\n\\nThis event was scheduled with schej: https://schej.it/e/\" + eventId)}&startdt=${startDate.toISOString()}&enddt=${endDate.toISOString()}&location=${encodeURIComponent(this.event.location || \"\")}&path=/calendar/action/compose&timezone=${this.curTimezone.value}`;\n      }\n\n      // Navigate to url and reset state\n      window.open(url, \"_blank\");\n      this.state = this.defaultState;\n    },\n    //#endregion\n\n    // -----------------------------------\n    //#region Drag Stuff\n    // -----------------------------------\n    normalizeXY(e) {\n      /* Normalize the touch event to be relative to element */\n      let pageX, pageY;\n      if (\"touches\" in e) {\n        // is a touch event\n        ;\n        ({\n          pageX,\n          pageY\n        } = e.touches[0]);\n      } else {\n        // is a mouse event\n        ;\n        ({\n          pageX,\n          pageY\n        } = e);\n      }\n      const {\n        left,\n        top\n      } = e.currentTarget.getBoundingClientRect();\n      const x = pageX - left;\n      const y = pageY - top - window.scrollY;\n      return {\n        x,\n        y\n      };\n    },\n    clampRow(row) {\n      if (this.event.daysOnly) {\n        row = clamp(row, 0, Math.floor(this.monthDays.length / 7) - 1);\n      } else {\n        row = clamp(row, 0, this.times.length - 1);\n      }\n      return row;\n    },\n    clampCol(col) {\n      if (this.event.daysOnly) {\n        col = clamp(col, 0, 7 - 1);\n      } else {\n        col = clamp(col, 0, this.days.length - 1);\n      }\n      return col;\n    },\n    /** Returns row, col for the timeslot we are currently hovering over given the x and y position */\n    getRowColFromXY(x, y) {\n      const {\n        width,\n        height\n      } = this.timeslot;\n      let col = Math.floor(x / width);\n      if (!this.event.daysOnly) {\n        col = this.columnOffsets.length;\n        for (let i = 0; i < this.columnOffsets.length; ++i) {\n          if (x < this.columnOffsets[i]) {\n            col = i - 1;\n            break;\n          }\n        }\n      }\n      let row = Math.floor(y / height);\n\n      // Account for split gap\n      if (!this.event.daysOnly && row > this.splitTimes[0].length) {\n        const adjustedRow = Math.floor((y - this.SPLIT_GAP_HEIGHT) / height);\n        if (adjustedRow >= this.splitTimes[0].length) {\n          // Make sure we don't go to a lesser index\n          row = adjustedRow;\n        }\n      }\n      row = this.clampRow(row);\n      col = this.clampCol(col);\n      return {\n        row,\n        col\n      };\n    },\n    endDrag() {\n      if (!this.allowDrag) return;\n      if (!this.dragStart || !this.dragCur) return;\n\n      // Update availability set based on drag region\n      if (this.state === this.states.EDIT_AVAILABILITY || this.state === this.states.SET_SPECIFIC_TIMES) {\n        // Determine colInc and rowInc\n        let colInc = (this.dragCur.col - this.dragStart.col) / Math.abs(this.dragCur.col - this.dragStart.col);\n        let rowInc = (this.dragCur.row - this.dragStart.row) / Math.abs(this.dragCur.row - this.dragStart.row);\n        if (isNaN(colInc)) colInc = 1;\n        if (isNaN(rowInc)) rowInc = 1;\n\n        // Determine iteration variables\n        let rowStart = this.dragStart.row;\n        let rowMax = this.dragCur.row + rowInc;\n        let colStart = this.dragStart.col;\n        let colMax = this.dragCur.col + colInc;\n\n        // Correct iteration variables if days only\n        if (this.event.daysOnly) {\n          colStart = 0;\n          colMax = 7;\n          colInc = 1;\n        }\n\n        // Iterate all selected time slots and either add or remove them\n        for (let r = rowStart; r != rowMax; r += rowInc) {\n          for (let c = colStart; c != colMax; c += colInc) {\n            const date = this.getDateFromRowCol(r, c);\n            if (!date) continue;\n            if (this.event.daysOnly) {\n              // Don't add to availability set if month day is not included\n              const isMonthDayIncluded = this.monthDayIncluded.get(date.getTime()) && this.inDragRange(r, c);\n              if (!isMonthDayIncluded) continue;\n            }\n            if (this.dragType === this.DRAG_TYPES.ADD) {\n              if (this.state === this.states.SET_SPECIFIC_TIMES) {\n                this.tempTimes.add(date.getTime());\n              } else {\n                // Add / remove time from availability set\n                if (this.availabilityType === availabilityTypes.AVAILABLE) {\n                  this.availability.add(date.getTime());\n                  this.ifNeeded.delete(date.getTime());\n                } else if (this.availabilityType === availabilityTypes.IF_NEEDED) {\n                  this.ifNeeded.add(date.getTime());\n                  this.availability.delete(date.getTime());\n                }\n              }\n            } else if (this.dragType === this.DRAG_TYPES.REMOVE) {\n              if (this.state === this.states.SET_SPECIFIC_TIMES) {\n                this.tempTimes.delete(date.getTime());\n              } else {\n                // Add / remove time from availability set\n                this.availability.delete(date.getTime());\n                this.ifNeeded.delete(date.getTime());\n              }\n            }\n\n            // Edit manualAvailability set if event is a GROUP\n            if (this.event.type === eventTypes.GROUP) {\n              const discreteDate = dateToDowDate(this.event.dates, date, this.weekOffset, true);\n              const startDateOfDay = dateToDowDate(this.event.dates, this.days[c].dateObject, this.weekOffset, true);\n\n              // If date not touched, then add all of the existing calendar availabilities and mark it as touched\n              if (!(startDateOfDay.getTime() in this.manualAvailability)) {\n                // Create new set\n                this.manualAvailability[startDateOfDay.getTime()] = new Set();\n\n                // Add the existing calendar availabilities\n                const existingAvailability = this.getAvailabilityForColumn(c);\n                for (const a of existingAvailability) {\n                  const convertedDate = dateToDowDate(this.event.dates, new Date(a), this.weekOffset, true);\n                  this.manualAvailability[startDateOfDay.getTime()].add(convertedDate.getTime());\n                }\n              }\n\n              // Add / remove time from manual availability set\n              if (this.dragType === this.DRAG_TYPES.ADD) {\n                this.manualAvailability[startDateOfDay.getTime()].add(discreteDate.getTime());\n              } else if (this.dragType === this.DRAG_TYPES.REMOVE) {\n                this.manualAvailability[startDateOfDay.getTime()].delete(discreteDate.getTime());\n              }\n            }\n          }\n        }\n        this.availability = new Set(this.availability);\n      } else if (this.state === this.states.SCHEDULE_EVENT) {\n        // Update scheduled event\n        const col = this.dragStart.col;\n        const row = this.dragStart.row;\n        const numRows = this.dragCur.row - this.dragStart.row + 1;\n        if (numRows > 0) {\n          this.curScheduledEvent = {\n            col,\n            row,\n            numRows\n          };\n        } else {\n          this.curScheduledEvent = null;\n        }\n      } else if (this.state === this.states.EDIT_SIGN_UP_BLOCKS) {\n        // Update sign up blocks\n        const dayIndex = this.dragStart.col;\n        const hoursOffset = this.dragStart.row / 4;\n        const hoursLength = (this.dragCur.row - this.dragStart.row + 1) / 4;\n        if (hoursLength > 0) {\n          this.signUpBlocksToAddByDay[dayIndex].push(this.createSignUpBlock(dayIndex, hoursOffset, hoursLength));\n        }\n      }\n\n      // Set dragging defaults\n      this.dragging = false;\n      this.dragStart = null;\n      this.dragCur = null;\n    },\n    inDragRange(row, col) {\n      /* Returns whether the given row and col is within the drag range */\n      if (this.dragging) {\n        if (this.event.daysOnly) {\n          if (isBetween(row, this.dragStart.row, this.dragCur.row) || isBetween(row, this.dragCur.row, this.dragStart.row)) {\n            if (this.dragCur.row < this.dragStart.row) {\n              return this.dragCur.row === row && this.dragCur.col <= col || this.dragStart.row === row && this.dragStart.col >= col || this.dragStart.row !== row && this.dragCur.row !== row;\n            } else if (this.dragCur.row > this.dragStart.row) {\n              return this.dragCur.row === row && this.dragCur.col >= col || this.dragStart.row === row && this.dragStart.col <= col || this.dragStart.row !== row && this.dragCur.row !== row;\n            } else {\n              // cur row == start row\n              return isBetween(col, this.dragStart.col, this.dragCur.col) || isBetween(col, this.dragCur.col, this.dragStart.col);\n            }\n          }\n          return false;\n        }\n        return (isBetween(row, this.dragStart.row, this.dragCur.row) || isBetween(row, this.dragCur.row, this.dragStart.row)) && (isBetween(col, this.dragStart.col, this.dragCur.col) || isBetween(col, this.dragCur.col, this.dragStart.col));\n      }\n      return false;\n    },\n    moveDrag(e) {\n      if (!this.allowDrag) return;\n      if (e.touches?.length > 1) return; // If dragging with more than one finger\n      if (!this.dragStart) return;\n      e.preventDefault();\n      let {\n        row,\n        col\n      } = this.getRowColFromXY(...Object.values(this.normalizeXY(e)));\n      if (this.maxSignUpBlockRowSize && row >= this.dragStart.row + this.maxSignUpBlockRowSize) {\n        row = this.dragStart.row + this.maxSignUpBlockRowSize - 1;\n      } else if (this.state === this.states.SCHEDULE_EVENT) {\n        const isFirstSplit = this.dragStart.row < this.splitTimes[0].length;\n        if (isFirstSplit) {\n          row = Math.min(row, this.splitTimes[0].length - 1);\n        }\n      }\n      this.dragCur = {\n        row,\n        col\n      };\n    },\n    startDrag(e) {\n      const {\n        row,\n        col\n      } = this.getRowColFromXY(...Object.values(this.normalizeXY(e)));\n\n      // If sign up form, check if trying to drag in a block\n      if (this.isSignUp) {\n        for (const block of this.signUpBlocksByDay[col].concat(this.signUpBlocksToAddByDay[col])) {\n          if (isBetween(row, block.hoursOffset * 4, (block.hoursOffset + block.hoursLength) * 4 - 1)) {\n            this.$refs.signUpBlocksList.scrollToSignUpBlock(block._id);\n            return;\n          }\n        }\n      }\n      if (!this.allowDrag) return;\n      if (e.touches?.length > 1) return; // If dragging with more than one finger\n\n      const date = this.getDateFromRowCol(row, col);\n      if (!date) return;\n\n      // Dont start dragging if day not included in daysonly event\n      if (this.event.daysOnly && !this.monthDayIncluded.get(date.getTime())) {\n        return;\n      }\n      this.dragging = true;\n      this.dragStart = {\n        row,\n        col\n      };\n      this.dragCur = {\n        row,\n        col\n      };\n\n      // Prevent scroll\n      e.preventDefault();\n\n      // Set drag type\n      if (this.isSignUp) {\n        this.dragType = this.DRAG_TYPES.ADD;\n      } else if (this.state === this.states.SET_SPECIFIC_TIMES && this.tempTimes.has(date.getTime()) || this.availabilityType === availabilityTypes.AVAILABLE && this.availability.has(date.getTime()) || this.availabilityType === availabilityTypes.IF_NEEDED && this.ifNeeded.has(date.getTime())) {\n        this.dragType = this.DRAG_TYPES.REMOVE;\n      } else {\n        this.dragType = this.DRAG_TYPES.ADD;\n      }\n    },\n    //#endregion\n\n    // -----------------------------------\n    //#region Options\n    // -----------------------------------\n    getLocalTimezone() {\n      const split = new Date(this.event.dates[0]).toLocaleTimeString(\"en-us\", {\n        timeZoneName: \"short\"\n      }).split(\" \");\n      const localTimezone = split[split.length - 1];\n      return localTimezone;\n    },\n    onShowBestTimesChange() {\n      localStorage[\"showBestTimes\"] = this.showBestTimes;\n      if (this.state == this.states.BEST_TIMES || this.state == this.states.HEATMAP) this.state = this.defaultState;\n    },\n    toggleShowEditOptions() {\n      this.showEditOptions = !this.showEditOptions;\n      localStorage[\"showEditOptions\"] = this.showEditOptions;\n    },\n    toggleShowEventOptions() {\n      this.showEventOptions = !this.showEventOptions;\n      localStorage[\"showEventOptions\"] = this.showEventOptions;\n    },\n    updateOverlayAvailability(val) {\n      this.overlayAvailability = !!val;\n      this.$posthog?.capture(\"overlay_availability_toggled\", {\n        enabled: !!val\n      });\n    },\n    //#endregion\n\n    // -----------------------------------\n    //#region Scroll\n    // -----------------------------------\n    onCalendarScroll(e) {\n      this.calendarMaxScroll = e.target.scrollWidth - e.target.offsetWidth;\n      this.calendarScrollLeft = e.target.scrollLeft;\n    },\n    onScroll(e) {\n      this.checkElementsVisible();\n    },\n    /** Checks whether certain elements are visible and sets variables accoringly */\n    checkElementsVisible() {\n      const optionsSectionEl = this.$refs.optionsSection;\n      if (optionsSectionEl) {\n        this.optionsVisible = isElementInViewport(optionsSectionEl, {\n          bottomOffset: -64\n        });\n      }\n      const respondentsListEl = this.$refs.respondentsList?.$el;\n      if (respondentsListEl) {\n        this.scrolledToRespondents = isElementInViewport(respondentsListEl, {\n          bottomOffset: -64\n        });\n      }\n    },\n    //#endregion\n\n    // -----------------------------------\n    //#region Pagination\n    // -----------------------------------\n    nextPage(e) {\n      e.stopImmediatePropagation();\n      if (this.event.type === eventTypes.GROUP) {\n        // Go to next page if there are still more days left to see\n        // Otherwise, update week offset\n        if ((this.page + 1) * this.maxDaysPerPage < this.allDays.length) {\n          this.page++;\n        } else {\n          this.page = 0;\n          this.$emit(\"update:weekOffset\", this.weekOffset + 1);\n        }\n      } else {\n        this.page++;\n      }\n      this.pageHasChanged = true;\n    },\n    prevPage(e) {\n      e.stopImmediatePropagation();\n      if (this.event.type === eventTypes.GROUP) {\n        // Go to prev page if there is a prev page\n        // Otherwise, update week offset\n        if (this.page > 0) {\n          this.page--;\n        } else {\n          this.page = Math.ceil(this.allDays.length / this.maxDaysPerPage) - 1;\n          this.$emit(\"update:weekOffset\", this.weekOffset - 1);\n        }\n      } else {\n        this.page--;\n      }\n      this.pageHasChanged = true;\n    },\n    //#endregion\n\n    // -----------------------------------\n    //#region Resize\n    // -----------------------------------\n    onResize() {\n      this.setTimeslotSize();\n    },\n    //#endregion\n\n    // -----------------------------------\n    //#region hint\n    // -----------------------------------\n    closeHint() {\n      this.hintState = false;\n      localStorage[this.hintStateLocalStorageKey] = true;\n    },\n    //#endregion\n\n    // -----------------------------------\n    //#region Group\n    // -----------------------------------\n\n    /** Toggles calendar account - in groups to enable/disable calendars */\n    toggleCalendarAccount(payload) {\n      this.sharedCalendarAccounts[getCalendarAccountKey(payload.email, payload.calendarType)].enabled = payload.enabled;\n      this.sharedCalendarAccounts = JSON.parse(JSON.stringify(this.sharedCalendarAccounts));\n    },\n    /** Toggles sub calendar account - in groups to enable/disable sub calendars */\n    toggleSubCalendarAccount(payload) {\n      this.sharedCalendarAccounts[getCalendarAccountKey(payload.email, payload.calendarType)].subCalendars[payload.subCalendarId].enabled = payload.enabled;\n      this.sharedCalendarAccounts = JSON.parse(JSON.stringify(this.sharedCalendarAccounts));\n    },\n    /** Sets the initial sharedCalendarAccounts object */\n    initSharedCalendarAccounts() {\n      if (!this.authUser) return;\n\n      // Init shared calendar accounts to current calendar accounts\n      this.sharedCalendarAccounts = JSON.parse(JSON.stringify(this.authUser.calendarAccounts));\n\n      // Disable all calendars\n      for (const id in this.sharedCalendarAccounts) {\n        this.sharedCalendarAccounts[id].enabled = false;\n        if (this.sharedCalendarAccounts[id].subCalendars) {\n          for (const subCalendarId in this.sharedCalendarAccounts[id].subCalendars) {\n            this.sharedCalendarAccounts[id].subCalendars[subCalendarId].enabled = false;\n          }\n        }\n      }\n\n      // Enable calendars based on responses\n      if (this.authUser._id in this.event.responses) {\n        const enabledCalendars = this.event.responses[this.authUser._id].enabledCalendars;\n        for (const id in enabledCalendars) {\n          this.sharedCalendarAccounts[id].enabled = true;\n          enabledCalendars[id].forEach(subCalendarId => {\n            this.sharedCalendarAccounts[id].subCalendars[subCalendarId].enabled = true;\n          });\n        }\n      }\n    },\n    /** Based on the date, determine whether it has been touched */\n    isTouched(date, availability = [...this.availability]) {\n      const start = new Date(date);\n      const end = new Date(date);\n      end.setHours(end.getHours() + this.event.duration);\n      for (const a of availability) {\n        const availableTime = new Date(a).getTime();\n        if (start.getTime() <= availableTime && availableTime <= end.getTime()) {\n          return true;\n        }\n      }\n      return false;\n    },\n    /** Returns a subset of availability for the current date */\n    getAvailabilityForColumn(column, availability = [...this.availability]) {\n      const subset = new Set();\n      const availabilitySet = new Set(availability);\n      for (let r = 0; r < this.splitTimes[0].length + this.splitTimes[1].length; ++r) {\n        const date = this.getDateFromRowCol(r, column);\n        if (!date) continue;\n        if (availabilitySet.has(date.getTime())) {\n          subset.add(date.getTime());\n        }\n      }\n      return subset;\n    },\n    /** Returns a copy of the manual availability, converted to dow dates */\n    getManualAvailabilityDow(manualAvailability = this.manualAvailability) {\n      if (!manualAvailability) return null;\n      const manualAvailabilityDow = {};\n      for (const time in manualAvailability) {\n        const dowTime = dateToDowDate(this.event.dates, new Date(parseInt(time)), this.weekOffset).getTime();\n        manualAvailabilityDow[dowTime] = [...manualAvailability[time]].map(a => dateToDowDate(this.event.dates, new Date(a), this.weekOffset));\n      }\n      return manualAvailabilityDow;\n    },\n    //#endregion\n\n    // -----------------------------------\n    //#region Sign up form\n    // -----------------------------------\n\n    /** Creates a sign up block for the current day and hour offset */\n    createSignUpBlock(dayIndex, hoursOffset, hoursLength) {\n      const timeBlock = getTimeBlock(this.days[dayIndex].dateObject, hoursOffset, hoursLength);\n      return {\n        _id: ObjectID().toString(),\n        capacity: 1,\n        name: this.newSignUpBlockName,\n        ...timeBlock,\n        hoursOffset,\n        hoursLength\n      };\n    },\n    /** Updates the sign up block with the same id */\n    editSignUpBlock(signUpBlock) {\n      this.signUpBlocksByDay.forEach((blocksInDay, dayIndex) => {\n        blocksInDay.forEach((block, blockIndex) => {\n          if (signUpBlock._id === block._id) {\n            this.signUpBlocksByDay[dayIndex][blockIndex] = signUpBlock;\n            this.signUpBlocksByDay = [...this.signUpBlocksByDay];\n            return;\n          }\n        });\n      });\n      this.signUpBlocksToAddByDay.forEach((blocksInDay, dayIndex) => {\n        blocksInDay.forEach((block, blockIndex) => {\n          if (signUpBlock._id === block._id) {\n            this.signUpBlocksToAddByDay[dayIndex][blockIndex] = signUpBlock;\n            this.signUpBlocksToAddByDay = [...this.signUpBlocksToAddByDay];\n            return;\n          }\n        });\n      });\n    },\n    /** Deletes the sign up block with the id */\n    deleteSignUpBlock(signUpBlockId) {\n      this.signUpBlocksByDay.forEach((blocksInDay, dayIndex) => {\n        blocksInDay.forEach((block, blockIndex) => {\n          if (signUpBlockId === block._id) {\n            this.signUpBlocksByDay[dayIndex].splice(blockIndex, 1);\n            return;\n          }\n        });\n      });\n      this.signUpBlocksToAddByDay.forEach((blocksInDay, dayIndex) => {\n        blocksInDay.forEach((block, blockIndex) => {\n          if (signUpBlockId === block._id) {\n            this.signUpBlocksToAddByDay[dayIndex].splice(blockIndex, 1);\n            return;\n          }\n        });\n      });\n    },\n    /** Reloads all the data for the sign up form */\n    resetSignUpForm() {\n      /** Split sign up blocks by day */\n      this.signUpBlocksByDay = splitTimeBlocksByDay(this.event, this.event.signUpBlocks ?? []);\n      this.resetSignUpBlocksToAddByDay();\n\n      /** Populate sign up block responses */\n      for (const userId in this.event.signUpResponses) {\n        const signUpResponse = this.event.signUpResponses[userId];\n        for (const signUpBlockId of signUpResponse.signUpBlockIds) {\n          const signUpBlock = this.signUpBlocksByDay.flat().find(signUpBlock => signUpBlock._id === signUpBlockId);\n          if (!signUpBlock.responses) signUpBlock.responses = [];\n          signUpBlock.responses.push(signUpResponse);\n        }\n      }\n    },\n    /** Initialize sign up blocks to be added array */\n    resetSignUpBlocksToAddByDay() {\n      this.signUpBlocksToAddByDay = [];\n      for (const day of this.signUpBlocksByDay) {\n        this.signUpBlocksToAddByDay.push([]);\n      }\n    },\n    /** Emits sign up for block to parent element */\n    handleSignUpBlockClick(block) {\n      if (!this.alreadyRespondedToSignUpForm && !this.isOwner) this.$emit(\"signUpForBlock\", block);\n    },\n    //#endregion\n\n    // -----------------------------------\n    //#region Specific times for specific days\n    // -----------------------------------\n\n    /** Saves the temporary times to the event */\n    saveTempTimes() {\n      // Set event times\n      this.event.times = [...this.tempTimes].map(t => new Date(t)).sort((a, b) => a.getTime() - b.getTime());\n      const {\n        minHours,\n        maxHours\n      } = this.getMinMaxHoursFromTimes(this.event.times);\n\n      // Set event dates to start at the new times\n      for (let i = 0; i < this.event.dates.length; ++i) {\n        const date = new Date(this.event.dates[i]);\n        date.setTime(date.getTime() - this.timezoneOffset * 60 * 1000);\n        date.setUTCHours(minHours, 0, 0, 0);\n        date.setTime(date.getTime() + this.timezoneOffset * 60 * 1000);\n        this.event.dates[i] = date.toISOString();\n      }\n\n      // Set event duration to the difference between the max and min hours\n      this.event.duration = maxHours - minHours + 1;\n\n      // Update event\n      put(`/events/${this.event._id}`, this.event).then(() => {\n        this.state = this.defaultState;\n      }).catch(err => {\n        this.showError(err);\n      });\n    },\n    /** Returns the min and max hours from the times */\n    getMinMaxHoursFromTimes(times) {\n      let minHours = 24;\n      let maxHours = 0;\n      for (const time of times) {\n        const timeDate = new Date(time);\n        const date = new Date(timeDate.getTime() - this.timezoneOffset * 60 * 1000);\n        const localHours = date.getUTCHours();\n        if (localHours < minHours) {\n          minHours = localHours;\n        } else if (localHours > maxHours) {\n          maxHours = localHours;\n        }\n      }\n      return {\n        minHours,\n        maxHours\n      };\n    },\n    //#endregion\n\n    /** Recalculate availability the calendar based on calendar events */\n    reanimateAvailability() {\n      if (this.state === this.states.EDIT_AVAILABILITY && this.authUser && !(this.authUser?._id in this.event.responses) &&\n      // User hasn't responded yet\n      !this.loadingCalendarEvents && (!this.unsavedChanges || this.availabilityAnimEnabled)) {\n        for (const timeout of this.availabilityAnimTimeouts) {\n          clearTimeout(timeout);\n        }\n        this.setAvailabilityAutomatically();\n      }\n    }\n  },\n  watch: {\n    availability() {\n      if (this.state === this.states.EDIT_AVAILABILITY) {\n        this.unsavedChanges = true;\n      }\n    },\n    event: {\n      immediate: true,\n      handler() {\n        this.initSharedCalendarAccounts();\n        this.fetchResponses();\n      }\n    },\n    state(nextState, prevState) {\n      this.$nextTick(() => this.checkElementsVisible());\n\n      // Reset scheduled event when exiting schedule event state\n      if (prevState === this.states.SCHEDULE_EVENT) {\n        this.curScheduledEvent = null;\n      } else if (prevState === this.states.EDIT_AVAILABILITY) {\n        this.unsavedChanges = false;\n      }\n      if (nextState === this.states.SET_SPECIFIC_TIMES) {\n        this.$nextTick(() => {\n          const time9 = document.getElementById(\"time-9\");\n          if (time9) {\n            const yOffset = -150;\n            const y = time9.getBoundingClientRect().top + window.scrollY + yOffset;\n            window.scrollTo({\n              top: y,\n              behavior: \"smooth\"\n            });\n          }\n        });\n      }\n    },\n    respondents: {\n      immediate: true,\n      handler() {\n        this.curTimeslotAvailability = {};\n        for (const respondent of this.respondents) {\n          this.curTimeslotAvailability[respondent._id] = true;\n        }\n      }\n    },\n    calendarEventsByDay(val, oldVal) {\n      if (JSON.stringify(val) !== JSON.stringify(oldVal)) {\n        this.reanimateAvailability();\n      }\n    },\n    page() {\n      this.$nextTick(() => {\n        this.setTimeslotSize();\n      });\n    },\n    allDays() {\n      this.$nextTick(() => {\n        this.setTimeslotSize();\n      });\n    },\n    showStickyRespondents: {\n      immediate: true,\n      handler(cur) {\n        clearTimeout(this.delayedShowStickyRespondentsTimeout);\n        this.delayedShowStickyRespondentsTimeout = setTimeout(() => {\n          this.delayedShowStickyRespondents = cur;\n        }, 100);\n      }\n    },\n    maxDaysPerPage() {\n      // Set page to 0 if user switches from portrait to landscape orientation and we're on an invalid page number,\n      // i.e. we're on a page that displays 0 days\n      if (this.page * this.maxDaysPerPage >= this.allDays.length) {\n        this.page = 0;\n      }\n    },\n    mobileNumDays() {\n      // Save mobile num days in localstorage\n      localStorage[\"mobileNumDays\"] = this.mobileNumDays;\n\n      // Set timeslot size because it has changed\n      this.$nextTick(() => {\n        this.setTimeslotSize();\n      });\n    },\n    weekOffset() {\n      if (this.event.type === eventTypes.GROUP) {\n        this.fetchResponses();\n      }\n    },\n    hideIfNeeded() {\n      this.getResponsesFormatted();\n    },\n    parsedResponses() {\n      // Theoretically, parsed responses should only be changing for groups\n      this.getResponsesFormatted();\n\n      // Repopulate user availability when editing availability (this happens when switching weeks in a group)\n      if (this.event.type === eventTypes.GROUP && this.state === this.states.EDIT_AVAILABILITY && this.authUser) {\n        this.availability = new Set();\n        this.populateUserAvailability(this.authUser._id);\n      }\n    },\n    showBestTimes() {\n      this.onShowBestTimesChange();\n    },\n    startCalendarOnMonday() {\n      localStorage[\"startCalendarOnMonday\"] = this.startCalendarOnMonday;\n    },\n    bufferTime(cur, prev) {\n      if (cur.enabled !== prev.enabled || cur.enabled) {\n        this.reanimateAvailability();\n      }\n    },\n    workingHours(cur, prev) {\n      if (cur.enabled !== prev.enabled || cur.enabled) {\n        this.reanimateAvailability();\n      }\n    },\n    timeType() {\n      localStorage[\"timeType\"] = this.timeType;\n    },\n    fromEditEvent() {\n      if (this.fromEditEvent && this.isSpecificTimes) {\n        this.tempTimes = new Set(this.event.times.map(t => new Date(t).getTime()));\n        this.state = this.states.SET_SPECIFIC_TIMES;\n      }\n    }\n  },\n  created() {\n    this.resetCurUserAvailability();\n    addEventListener(\"click\", this.deselectRespondents);\n  },\n  mounted() {\n    // Get query parameters from URL\n    const urlParams = new URLSearchParams(window.location.search);\n\n    // Set initial state\n    if (this.event.hasSpecificTimes && (this.fromEditEvent || !this.event.times || this.event.times.length === 0)) {\n      this.state = this.states.SET_SPECIFIC_TIMES;\n    } else if (urlParams.get(\"scheduled_event\")) {\n      const scheduledEvent = JSON.parse(urlParams.get(\"scheduled_event\"));\n      this.curScheduledEvent = scheduledEvent;\n      this.state = this.states.SCHEDULE_EVENT;\n\n      // Remove the scheduled_event parameter from URL to avoid reloading the same state\n      const newUrl = new URL(window.location.href);\n      newUrl.searchParams.delete(\"scheduled_event\");\n      window.history.replaceState({}, document.title, newUrl.toString());\n    } else if (this.showBestTimes) {\n      this.state = \"best_times\";\n    } else {\n      this.state = \"heatmap\";\n    }\n\n    // Set calendar options defaults\n    if (this.authUser) {\n      this.bufferTime = this.authUser?.calendarOptions?.bufferTime ?? calendarOptionsDefaults.bufferTime;\n      this.workingHours = this.authUser?.calendarOptions?.workingHours ?? calendarOptionsDefaults.workingHours;\n      if (this.isGroup) {\n        if (this.event.responses[this.authUser._id]?.calendarOptions) {\n          // Update calendar options if user has changed them for this specific group\n          const {\n            bufferTime,\n            workingHours\n          } = this.event.responses[this.authUser._id]?.calendarOptions;\n          if (bufferTime) this.bufferTime = bufferTime;\n          if (workingHours) this.workingHours = workingHours;\n        } else {\n          this.bufferTime = calendarOptionsDefaults.bufferTime;\n          this.workingHours = calendarOptionsDefaults.workingHours;\n        }\n      }\n    }\n\n    // Set initial calendar max scroll\n    // this.calendarMaxScroll =\n    //   this.$refs.calendar.scrollWidth - this.$refs.calendar.offsetWidth\n\n    // Get timeslot size\n    this.setTimeslotSize();\n    addEventListener(\"resize\", this.onResize);\n    addEventListener(\"scroll\", this.onScroll);\n    if (!this.calendarOnly) {\n      const timesEl = document.getElementById(\"drag-section\");\n      if (isTouchEnabled()) {\n        timesEl.addEventListener(\"touchstart\", this.startDrag);\n        timesEl.addEventListener(\"touchmove\", this.moveDrag);\n        timesEl.addEventListener(\"touchend\", this.endDrag);\n        timesEl.addEventListener(\"touchcancel\", this.endDrag);\n      }\n      timesEl.addEventListener(\"mousedown\", this.startDrag);\n      timesEl.addEventListener(\"mousemove\", this.moveDrag);\n      timesEl.addEventListener(\"mouseup\", this.endDrag);\n    }\n\n    // Parse sign up blocks and responses\n    this.resetSignUpForm();\n  },\n  beforeDestroy() {\n    removeEventListener(\"click\", this.deselectRespondents);\n    removeEventListener(\"resize\", this.onResize);\n    removeEventListener(\"scroll\", this.onScroll);\n  },\n  components: {\n    AlertText,\n    AvailabilityTypeToggle,\n    ExpandableSection,\n    BufferTimeSwitch,\n    UserAvatarContent,\n    ZigZag,\n    ConfirmDetailsDialog,\n    ToolRow,\n    CalendarAccounts,\n    RespondentsList,\n    Advertisement,\n    GCalWeekSelector,\n    WorkingHoursToggle,\n    SignUpBlock,\n    SignUpCalendarBlock,\n    SignUpBlocksList,\n    CalendarEventBlock,\n    // Added component registration\n    SpecificTimesInstructions,\n    // Added component registration\n    Tooltip\n  }\n};","map":{"version":3,"names":["timeNumToTimeText","dateCompare","getDateHoursOffset","post","put","isBetween","clamp","isPhone","utcTimeToLocalTime","splitTimeBlocksByDay","getTimeBlock","dateToDowDate","_delete","get","getDateDayOffset","isDateBetween","generateEnabledCalendarsPayload","isTouchEnabled","isElementInViewport","lightOrDark","removeTransparencyFromHex","userPrefers12h","getCalendarAccountKey","getISODateString","getDateWithTimezone","timeNumToTimeString","isPremiumUser","availabilityTypes","calendarOptionsDefaults","eventTypes","timeTypes","timeslotDurations","upgradeDialogTypes","mapMutations","mapActions","mapState","UserAvatarContent","CalendarAccounts","Advertisement","SignUpBlock","SignUpCalendarBlock","SignUpBlocksList","ZigZag","ConfirmDetailsDialog","ToolRow","RespondentsList","GCalWeekSelector","ExpandableSection","WorkingHoursToggle","AlertText","Tooltip","dayjs","ObjectID","utcPlugin","timezonePlugin","AvailabilityTypeToggle","BufferTimeSwitch","CalendarEventBlock","SpecificTimesInstructions","extend","name","props","event","type","Object","required","fromEditEvent","Boolean","default","loadingCalendarEvents","calendarEventsMap","sampleCalendarEventsByDay","Array","calendarPermissionGranted","weekOffset","Number","alwaysShowCalendarEvents","noEventNames","calendarOnly","interactable","showSnackbar","animateTimeslotAlways","showHintText","curGuestId","String","addingAvailabilityAsGuest","initialTimezone","calendarAvailabilities","data","states","HEATMAP","SINGLE_AVAILABILITY","SUBSET_AVAILABILITY","BEST_TIMES","EDIT_AVAILABILITY","EDIT_SIGN_UP_BLOCKS","SCHEDULE_EVENT","SET_SPECIFIC_TIMES","state","availability","Set","ifNeeded","tempTimes","availabilityAnimTimeouts","availabilityAnimEnabled","maxAnimTime","unsavedChanges","curTimeslot","row","col","timeslotSelected","curTimeslotAvailability","curRespondent","curRespondents","sharedCalendarAccounts","fetchedResponses","loadingResponses","loading","lastFetched","Date","getTime","responsesFormatted","Map","tooltipContent","signUpBlocksByDay","signUpBlocksToAddByDay","showEditOptions","localStorage","undefined","availabilityType","AVAILABLE","overlayAvailability","bufferTime","workingHours","showEventOptions","showBestTimes","hideIfNeeded","DRAG_TYPES","ADD","REMOVE","SPLIT_GAP_HEIGHT","SPLIT_GAP_WIDTH","HOUR_HEIGHT","timeslot","width","height","dragging","dragType","dragStart","dragCur","curTimezone","curScheduledEvent","timeType","HOUR12","HOUR24","showCalendarEvents","startCalendarOnMonday","deleteAvailabilityDialog","calendarOptionsDialog","optionsVisible","calendarScrollLeft","calendarMaxScroll","scrolledToRespondents","delayedShowStickyRespondents","delayedShowStickyRespondentsTimeout","page","mobileNumDays","parseInt","pageHasChanged","hasRefreshedAuthUser","hintState","manualAvailability","months","computed","rightSideWidth","isSignUp","daysOfWeek","allowScheduleEvent","availabilityArray","map","item","ifNeededArray","allowDrag","calendarEventsByDay","authUser","events","calendarAccounts","isGroup","id","enabled","hasOwnProperty","index","calendarEvents","subCalendars","calendarId","push","refreshAuthUser","eventsCopy","JSON","parse","stringify","timezoneOffset","groupCalendarEventsByDay","GROUP","userIdToEventsByDay","userId","responses","_id","curRespondentsSet","newSignUpBlockName","flat","length","maxSignUpBlockRowSize","selectedDay","selectedDayToAdd","maxSize","Infinity","block","hoursOffset","Math","min","alreadyRespondedToSignUpForm","some","dayBlocks","response","curRespondentsMax","max","daysOnly","day","allDays","num","dateObject","filter","r","has","i","dates","date","time","times","getRespondentsForHoursOffset","dayOffset","floor","startTime","days","datesSoFar","getDateString","dateString","dayString","offsetDate","isSpecificTimes","setTime","setDate","getDate","isSpecificDates","getUTCMonth","getUTCDate","getUTCDay","isWeekly","tmpDate","prevDate","localDate","setUTCHours","add","isConsecutive","dayText","dayIndex","localStart","localEnd","duration","localEndIsMidnight","getUTCHours","getUTCMinutes","nextDate","setUTCDate","splice","excludeTimes","slice","maxDaysPerPage","monthDays","allDaysSet","d","monthIndex","year","getUTCFullYear","lastDayOfPrevMonth","UTC","lastDayOfCurMonth","curDate","numDaysFromPrevMonth","numDaysInCurMonth","numDaysFromNextMonth","hasDaysFromPrevMonth","totalDays","included","monthDayIncluded","includedMap","monthDay","set","curMonthText","monthText","yearText","defaultState","editing","scheduling","$vuetify","isOwner","ownerId","SPECIFIC_DATES","DOW","isSignUpForm","hasSpecificTimes","respondents","values","parsedResponses","user","selectedGuestRespondent","guestAddedAvailability","guestName","isGuest","scheduledEventStyle","style","top","isSecondSplit","splitTimes","numRows","timeslotHeight","signUpBlockBeingDraggedStyle","parsed","fetchedManualAvailability","getManualAvailabilityDow","curManualAvailability","getAvailabilityFromCalendarEvents","includeTouchedAvailability","calendarOptions","blindAvailabilityEnabled","guestNameKey","a","k","keys","newUser","dateTime","size","specificTimesSet","t","utcStartTime","utcEndTime","localStartTime","localEndTime","isWeirdTimezone","startTimeIsWeird","timeOffset","getExtraTimes","timeslotDuration","FIFTEEN_MINUTES","THIRTY_MINUTES","text","adjustedI","utcTimeNum","localTimeNum","timeIncrement","ONE_HOUR","getTimezoneOffset","offset","tz","value","utcOffset","userHasResponded","showLeftZigZag","showRightZigZag","ceil","hasNextPage","lastDay","hasPrevPage","hasPages","showStickyRespondents","hintText","daysOrTimes","IF_NEEDED","hintClosed","hintStateLocalStorageKey","hintTextShown","timeslotClassStyle","classStyles","getTimeTimeslotClassStyle","dayTimeslotClassStyle","getDayTimeslotClassStyle","timeslotVon","vons","getTimeslotVon","dayTimeslotVon","showLoader","overlaidAvailability","forEach","curBlockIndex","addOverlaidAvailabilityBlocks","getDateFromRowCol","dragAdd","inDragRange","dragRemove","hoursLength","showOverlayAvailabilityToggle","overlayAvailabilitiesEnabled","showCalendarOptions","columnOffsets","offsets","accumulatedOffset","methods","getDateFromDayHoursOffset","getDateFromDayTimeIndex","isColConsecutive","timeIndex","hasSecondSplit","isFirstSplit","adjustedDayIndex","mouseOverRespondent","e","mouseLeaveRespondent","clickRespondent","stopPropagation","deselectRespondents","target","previousElementSibling","firstChild","classList","contains","resetCurTimeslot","firstName","fetchResponses","timeMin","timeMax","url","toISOString","then","getResponsesFormatted","catch","err","showError","$worker","run","splitTimeNum","timeNum","hours","minutes","newDate","setHours","getHours","setMinutes","getMinutes","formatted","finally","showAvailability","available","respondent","setAuthUser","resetCurUserAvailability","initSharedCalendarAccounts","populateUserAvailability","$nextTick","getIsTimeBlockInFirstSplit","timeBlock","getTimeBlockStyle","endDate","manualAvailabilityAdded","bufferTimeInMS","startTimeString","isoDateString","workingHoursStartDate","toDate","endTime","workingHoursEndDate","j","startDate","findIndex","startDateBuffered","endDateBuffered","notIntersect","free","setAvailabilityAutomatically","tmpAvailability","pageStartDate","pageEndDate","animateAvailability","msPerGroup","blocksPerGroup","timeout","setTimeout","showInfo","stopAvailabilityAnim","clearTimeout","submitAvailability","guestPayload","email","payload","guest","addedIfNeededTimes","$posthog","capture","eventId","bufferTimeActive","workingHoursEnabled","workingHoursStartTime","workingHoursEndTime","refreshEvent","submitNewSignUpBlocks","concat","signUpBlocks","capacity","console","error","deleteAvailability","$router","replace","setTimeslotSize","timeslotEl","document","querySelector","getBoundingClientRect","classStyle","getTimeslotClassStyle","isDisabled","class","fractionalTime","borderTopStyle","totalRespondents","backgroundColor","c","s","timeslotRespondents","numRespondents","green","respondentId","frac","alpha","toString","toUpperCase","substring","padStart","red","borderRightStyle","borderBottomStyle","click","mousedown","highlightAvailabilityBtn","mouseover","utc","timeFormat","dateFormat","format","mouseleave","endDrag","startEditing","stopEditing","$emit","editGuestAvailability","scheduleEvent","cancelScheduleEvent","confirmScheduleEvent","googleCalendar","getDay","emails","emailsString","encodeURIComponent","join","shortId","start","end","location","window","open","normalizeXY","pageX","pageY","touches","left","currentTarget","x","y","scrollY","clampRow","clampCol","getRowColFromXY","adjustedRow","colInc","abs","rowInc","isNaN","rowStart","rowMax","colStart","colMax","isMonthDayIncluded","delete","discreteDate","startDateOfDay","existingAvailability","getAvailabilityForColumn","convertedDate","createSignUpBlock","moveDrag","preventDefault","startDrag","$refs","signUpBlocksList","scrollToSignUpBlock","getLocalTimezone","split","toLocaleTimeString","timeZoneName","localTimezone","onShowBestTimesChange","toggleShowEditOptions","toggleShowEventOptions","updateOverlayAvailability","val","onCalendarScroll","scrollWidth","offsetWidth","scrollLeft","onScroll","checkElementsVisible","optionsSectionEl","optionsSection","bottomOffset","respondentsListEl","respondentsList","$el","nextPage","stopImmediatePropagation","prevPage","onResize","closeHint","toggleCalendarAccount","calendarType","toggleSubCalendarAccount","subCalendarId","enabledCalendars","isTouched","availableTime","column","subset","availabilitySet","manualAvailabilityDow","dowTime","editSignUpBlock","signUpBlock","blocksInDay","blockIndex","deleteSignUpBlock","signUpBlockId","resetSignUpForm","resetSignUpBlocksToAddByDay","signUpResponses","signUpResponse","signUpBlockIds","find","handleSignUpBlockClick","saveTempTimes","sort","b","minHours","maxHours","getMinMaxHoursFromTimes","timeDate","localHours","reanimateAvailability","watch","immediate","handler","nextState","prevState","time9","getElementById","yOffset","scrollTo","behavior","oldVal","cur","prev","created","addEventListener","mounted","urlParams","URLSearchParams","search","scheduledEvent","newUrl","URL","href","searchParams","history","replaceState","title","timesEl","beforeDestroy","removeEventListener","components"],"sources":["src/components/schedule_overlap/ScheduleOverlap.vue"],"sourcesContent":["<template>\n  <span>\n    <Tooltip :content=\"tooltipContent\">\n      <div class=\"tw-select-none tw-py-4\" style=\"-webkit-touch-callout: none\">\n        <div class=\"tw-flex tw-flex-col sm:tw-flex-row\">\n          <div\n            class=\"tw-flex tw-grow tw-pl-4\"\n            :class=\"isSignUp ? '' : 'tw-pr-4'\"\n          >\n            <template v-if=\"event.daysOnly\">\n              <div class=\"tw-grow\">\n                <div class=\"tw-flex tw-items-center tw-justify-between\">\n                  <v-btn\n                    :class=\"hasPrevPage ? 'tw-visible' : 'tw-invisible'\"\n                    class=\"tw-border-gray\"\n                    outlined\n                    icon\n                    @click=\"prevPage\"\n                    ><v-icon>mdi-chevron-left</v-icon></v-btn\n                  >\n                  <div\n                    class=\"tw-text-lg tw-font-medium tw-capitalize sm:tw-text-xl\"\n                  >\n                    {{ curMonthText }}\n                  </div>\n                  <v-btn\n                    :class=\"hasNextPage ? 'tw-visible' : 'tw-invisible'\"\n                    class=\"tw-border-gray\"\n                    outlined\n                    icon\n                    @click=\"nextPage\"\n                    ><v-icon>mdi-chevron-right</v-icon></v-btn\n                  >\n                </div>\n                <!-- Header -->\n                <div class=\"tw-flex tw-w-full\">\n                  <div\n                    v-for=\"day in daysOfWeek\"\n                    class=\"tw-flex-1 tw-p-2 tw-text-center tw-text-base tw-capitalize tw-text-dark-gray\"\n                  >\n                    {{ day }}\n                  </div>\n                </div>\n                <!-- Days grid -->\n                <div\n                  id=\"drag-section\"\n                  class=\"tw-grid tw-grid-cols-7\"\n                  @mouseleave=\"resetCurTimeslot\"\n                >\n                  <div\n                    v-for=\"(day, i) in monthDays\"\n                    :key=\"day.time\"\n                    class=\"timeslot tw-aspect-square tw-p-2 tw-text-sm sm:tw-text-base\"\n                    :class=\"dayTimeslotClassStyle[i].class\"\n                    :style=\"dayTimeslotClassStyle[i].style\"\n                    v-on=\"dayTimeslotVon[i]\"\n                  >\n                    {{ day.date }}\n                  </div>\n                </div>\n\n                <v-expand-transition>\n                  <div\n                    :key=\"hintText\"\n                    v-if=\"!isPhone && hintTextShown\"\n                    class=\"tw-sticky tw-bottom-4 tw-z-10 tw-flex\"\n                  >\n                    <div\n                      class=\"tw-mt-2 tw-flex tw-w-full tw-items-center tw-justify-between tw-gap-1 tw-rounded-md tw-bg-off-white tw-p-2 tw-px-[7px] tw-text-sm tw-text-very-dark-gray\"\n                    >\n                      <div class=\"tw-flex tw-items-center tw-gap-1\">\n                        <v-icon small>mdi-information-outline</v-icon>\n                        {{ hintText }}\n                      </div>\n                      <v-icon small @click=\"closeHint\">mdi-close</v-icon>\n                    </div>\n                  </div>\n                </v-expand-transition>\n\n                <ToolRow\n                  v-if=\"!isPhone && !calendarOnly\"\n                  :event=\"event\"\n                  :state=\"state\"\n                  :states=\"states\"\n                  :cur-timezone.sync=\"curTimezone\"\n                  :show-best-times.sync=\"showBestTimes\"\n                  :hide-if-needed.sync=\"hideIfNeeded\"\n                  :is-weekly=\"isWeekly\"\n                  :calendar-permission-granted=\"calendarPermissionGranted\"\n                  :week-offset=\"weekOffset\"\n                  :num-responses=\"respondents.length\"\n                  :mobile-num-days.sync=\"mobileNumDays\"\n                  :allow-schedule-event=\"allowScheduleEvent\"\n                  :show-event-options=\"showEventOptions\"\n                  :time-type.sync=\"timeType\"\n                  @toggleShowEventOptions=\"toggleShowEventOptions\"\n                  @update:weekOffset=\"(val) => $emit('update:weekOffset', val)\"\n                  @scheduleEvent=\"scheduleEvent\"\n                  @cancelScheduleEvent=\"cancelScheduleEvent\"\n                  @confirmScheduleEvent=\"confirmScheduleEvent\"\n                />\n              </div>\n            </template>\n            <template v-else>\n              <!-- Times -->\n              <div\n                :class=\"calendarOnly ? 'tw-w-12' : ''\"\n                class=\"tw-w-8 tw-flex-none sm:tw-w-12\"\n              >\n                <div\n                  :class=\"calendarOnly ? 'tw-invisible' : 'tw-visible'\"\n                  class=\"tw-sticky tw-top-14 tw-z-10 -tw-ml-3 tw-mb-3 tw-h-11 tw-bg-white sm:tw-top-16 sm:tw-ml-0\"\n                >\n                  <div\n                    :class=\"hasPrevPage ? 'tw-visible' : 'tw-invisible'\"\n                    class=\"tw-sticky tw-top-14 tw-ml-0.5 tw-self-start tw-pt-1.5 sm:tw-top-16 sm:-tw-ml-2\"\n                  >\n                    <v-btn\n                      class=\"tw-border-gray\"\n                      outlined\n                      icon\n                      @click=\"prevPage\"\n                      ><v-icon>mdi-chevron-left</v-icon></v-btn\n                    >\n                  </div>\n                </div>\n\n                <div\n                  :class=\"calendarOnly ? '' : '-tw-ml-3'\"\n                  class=\"-tw-mt-[8px] sm:tw-ml-0\"\n                >\n                  <div\n                    v-for=\"(time, i) in splitTimes[0]\"\n                    :key=\"i\"\n                    :id=\"time.id\"\n                    class=\"tw-pr-1 tw-text-right tw-text-xs tw-font-light tw-uppercase sm:tw-pr-2\"\n                    :style=\"{ height: `${timeslotHeight}px` }\"\n                  >\n                    {{ time.text }}\n                  </div>\n                </div>\n\n                <template v-if=\"splitTimes[1].length > 0\">\n                  <div\n                    :style=\"{\n                      height: `${SPLIT_GAP_HEIGHT}px`,\n                    }\"\n                  ></div>\n                  <div\n                    v-if=\"splitTimes[1].length > 0\"\n                    :class=\"calendarOnly ? '' : '-tw-ml-3'\"\n                    class=\"sm:tw-ml-0\"\n                  >\n                    <div\n                      v-for=\"(time, i) in splitTimes[1]\"\n                      :key=\"i\"\n                      :id=\"time.id\"\n                      class=\"tw-pr-1 tw-text-right tw-text-xs tw-font-light tw-uppercase sm:tw-pr-2\"\n                      :style=\"{ height: `${timeslotHeight}px` }\"\n                    >\n                      {{ time.text }}\n                    </div>\n                  </div>\n                </template>\n              </div>\n\n              <!-- Middle section -->\n              <div class=\"tw-grow\">\n                <div\n                  ref=\"calendar\"\n                  @scroll=\"onCalendarScroll\"\n                  class=\"tw-relative tw-flex tw-flex-col\"\n                >\n                  <!-- Days -->\n                  <div\n                    :class=\"\n                      sampleCalendarEventsByDay\n                        ? undefined\n                        : 'tw-sticky tw-top-14'\n                    \"\n                    class=\"tw-z-10 tw-flex tw-h-14 tw-items-center tw-bg-white sm:tw-top-16\"\n                  >\n                    <template v-for=\"(day, i) in days\">\n                      <div\n                        v-if=\"!day.isConsecutive\"\n                        :style=\"{ width: `${SPLIT_GAP_WIDTH}px` }\"\n                        :key=\"`${i}-gap`\"\n                      ></div>\n                      <div :key=\"i\" class=\"tw-flex-1 tw-bg-white\">\n                        <div class=\"tw-text-center\">\n                          <div\n                            v-if=\"isSpecificDates || isGroup\"\n                            class=\"tw-text-[12px] tw-font-light tw-capitalize tw-text-very-dark-gray sm:tw-text-xs\"\n                          >\n                            {{ day.dateString }}\n                          </div>\n                          <div class=\"tw-text-base tw-capitalize sm:tw-text-lg\">\n                            {{ day.dayText }}\n                          </div>\n                        </div>\n                      </div>\n                    </template>\n                  </div>\n\n                  <!-- Calendar -->\n                  <div class=\"tw-flex tw-flex-col\">\n                    <div class=\"tw-flex-1\">\n                      <div\n                        id=\"drag-section\"\n                        data-long-press-delay=\"500\"\n                        class=\"tw-relative tw-flex\"\n                        @mouseleave=\"resetCurTimeslot\"\n                      >\n                        <!-- Loader -->\n                        <div\n                          v-if=\"showLoader\"\n                          class=\"tw-absolute tw-z-10 tw-grid tw-h-full tw-w-full tw-place-content-center\"\n                        >\n                          <v-progress-circular\n                            class=\"tw-text-green\"\n                            indeterminate\n                          />\n                        </div>\n\n                        <template v-for=\"(day, d) in days\">\n                          <div\n                            v-if=\"!day.isConsecutive\"\n                            :style=\"{ width: `${SPLIT_GAP_WIDTH}px` }\"\n                            :key=\"`${d}-gap`\"\n                          ></div>\n                          <div\n                            :key=\"d\"\n                            class=\"tw-relative tw-flex-1\"\n                            :class=\"\n                              ((isGroup && loadingCalendarEvents) ||\n                                loadingResponses.loading) &&\n                              'tw-opacity-50'\n                            \"\n                          >\n                            <!-- Timeslots -->\n                            <div\n                              v-for=\"(_, t) in splitTimes[0]\"\n                              :key=\"`${d}-${t}-0`\"\n                              class=\"tw-w-full\"\n                            >\n                              <div\n                                class=\"timeslot\"\n                                :class=\"\n                                  timeslotClassStyle[d * times.length + t]\n                                    ?.class\n                                \"\n                                :style=\"\n                                  timeslotClassStyle[d * times.length + t]\n                                    ?.style\n                                \"\n                                v-on=\"timeslotVon[d * times.length + t]\"\n                              ></div>\n                            </div>\n\n                            <template v-if=\"splitTimes[1].length > 0\">\n                              <div\n                                :style=\"{\n                                  height: `${SPLIT_GAP_HEIGHT}px`,\n                                }\"\n                              ></div>\n                              <div\n                                v-for=\"(_, t) in splitTimes[1]\"\n                                :key=\"`${d}-${t}-1`\"\n                                class=\"tw-w-full\"\n                              >\n                                <div\n                                  class=\"timeslot\"\n                                  :class=\"\n                                    timeslotClassStyle[\n                                      d * times.length +\n                                        t +\n                                        splitTimes[0].length\n                                    ]?.class\n                                  \"\n                                  :style=\"\n                                    timeslotClassStyle[\n                                      d * times.length +\n                                        t +\n                                        splitTimes[0].length\n                                    ]?.style\n                                  \"\n                                  v-on=\"\n                                    timeslotVon[\n                                      d * times.length +\n                                        t +\n                                        splitTimes[0].length\n                                    ]\n                                  \"\n                                ></div>\n                              </div>\n                            </template>\n\n                            <!-- Calendar events -->\n                            <template\n                              v-if=\"\n                                !loadingCalendarEvents &&\n                                (editing ||\n                                  alwaysShowCalendarEvents ||\n                                  showCalendarEvents)\n                              \"\n                              v-for=\"calendarEvent in calendarEventsByDay[\n                                d + page * maxDaysPerPage\n                              ]\"\n                            >\n                              <CalendarEventBlock\n                                :blockStyle=\"getTimeBlockStyle(calendarEvent)\"\n                                :key=\"calendarEvent.id\"\n                                :calendarEvent=\"calendarEvent\"\n                                :isGroup=\"isGroup\"\n                                :isEditingAvailability=\"\n                                  state === states.EDIT_AVAILABILITY\n                                \"\n                                :noEventNames=\"noEventNames\"\n                                :transitionName=\"\n                                  isGroup ? '' : 'fade-transition'\n                                \"\n                              />\n                            </template>\n\n                            <!-- Scheduled event -->\n                            <div v-if=\"state === states.SCHEDULE_EVENT\">\n                              <div\n                                v-if=\"\n                                  (dragStart && dragStart.col === d) ||\n                                  (!dragStart &&\n                                    curScheduledEvent &&\n                                    curScheduledEvent.col === d)\n                                \"\n                                class=\"tw-absolute tw-w-full tw-select-none tw-p-px\"\n                                :style=\"scheduledEventStyle\"\n                                style=\"pointer-events: none\"\n                              >\n                                <div\n                                  class=\"tw-h-full tw-w-full tw-overflow-hidden tw-text-ellipsis tw-rounded tw-border tw-border-solid tw-border-blue tw-bg-blue tw-p-px tw-text-xs\"\n                                >\n                                  <div class=\"tw-font-medium tw-text-white\">\n                                    {{ event.name }}\n                                  </div>\n                                </div>\n                              </div>\n                            </div>\n\n                            <!-- Sign up block being dragged -->\n                            <div v-if=\"state === states.EDIT_SIGN_UP_BLOCKS\">\n                              <div\n                                v-if=\"dragStart && dragStart.col === d\"\n                                class=\"tw-absolute tw-w-full tw-select-none tw-p-px\"\n                                :style=\"signUpBlockBeingDraggedStyle\"\n                                style=\"pointer-events: none\"\n                              >\n                                <SignUpCalendarBlock\n                                  :title=\"newSignUpBlockName\"\n                                  titleOnly\n                                  unsaved\n                                />\n                              </div>\n                            </div>\n\n                            <div v-if=\"isSignUp\">\n                              <!-- Sign up blocks -->\n                              <div\n                                v-for=\"block in signUpBlocksByDay[\n                                  d + page * maxDaysPerPage\n                                ]\"\n                                :key=\"block._id\"\n                              >\n                                <div\n                                  class=\"tw-absolute tw-w-full tw-select-none tw-p-px\"\n                                  :style=\"{\n                                    top: `calc(${block.hoursOffset} * 4 * 1rem)`,\n                                    height: `calc(${block.hoursLength} * 4 * 1rem)`,\n                                  }\"\n                                  @click=\"handleSignUpBlockClick(block)\"\n                                >\n                                  <SignUpCalendarBlock :signUpBlock=\"block\" />\n                                </div>\n                              </div>\n\n                              <!-- Sign up blocks to be added after hitting 'save' -->\n                              <div\n                                v-for=\"block in signUpBlocksToAddByDay[\n                                  d + page * maxDaysPerPage\n                                ]\"\n                                :key=\"block._id\"\n                              >\n                                <div\n                                  class=\"tw-absolute tw-w-full tw-select-none tw-p-px\"\n                                  :style=\"{\n                                    top: `calc(${block.hoursOffset} * 4 * 1rem)`,\n                                    height: `calc(${block.hoursLength} * 4 * 1rem)`,\n                                  }\"\n                                >\n                                  <SignUpCalendarBlock\n                                    :title=\"block.name\"\n                                    titleOnly\n                                    unsaved\n                                  />\n                                </div>\n                              </div>\n                            </div>\n\n                            <!-- Overlaid availabilities -->\n                            <div v-if=\"overlayAvailability\">\n                              <div\n                                v-for=\"(timeBlock, tb) in overlaidAvailability[\n                                  d\n                                ]\"\n                                :key=\"tb\"\n                                class=\"tw-absolute tw-w-full tw-select-none tw-p-px\"\n                                :style=\"getTimeBlockStyle(timeBlock)\"\n                                style=\"pointer-events: none\"\n                              >\n                                <div\n                                  class=\"tw-h-full tw-w-full tw-border-2\"\n                                  :class=\"\n                                    timeBlock.type === 'available'\n                                      ? 'overlay-avail-shadow-green tw-border-[#00994CB3] tw-bg-[#00994C66]'\n                                      : 'overlay-avail-shadow-yellow tw-border-[#997700CC] tw-bg-[#FFE8B8B3]'\n                                  \"\n                                ></div>\n                              </div>\n                            </div>\n                          </div>\n                        </template>\n                      </div>\n                    </div>\n                  </div>\n\n                  <ZigZag\n                    v-if=\"hasPrevPage\"\n                    left\n                    class=\"tw-absolute tw-left-0 tw-top-0 tw-h-full tw-w-3\"\n                  />\n                  <ZigZag\n                    v-if=\"hasNextPage\"\n                    right\n                    class=\"tw-absolute tw-right-0 tw-top-0 tw-h-full tw-w-3\"\n                  />\n                </div>\n\n                <!-- Hint text (desktop) -->\n                <v-expand-transition>\n                  <div\n                    :key=\"hintText\"\n                    v-if=\"!isPhone && hintTextShown\"\n                    class=\"tw-sticky tw-bottom-4 tw-z-10 tw-flex\"\n                  >\n                    <div\n                      class=\"tw-mt-2 tw-flex tw-w-full tw-items-center tw-justify-between tw-gap-1 tw-rounded-md tw-bg-off-white tw-p-2 tw-px-[7px] tw-text-sm tw-text-very-dark-gray\"\n                    >\n                      <div class=\"tw-flex tw-items-center tw-gap-1\">\n                        <v-icon small>mdi-information-outline</v-icon>\n                        {{ hintText }}\n                      </div>\n                      <v-icon small @click=\"closeHint\">mdi-close</v-icon>\n                    </div>\n                  </div>\n                </v-expand-transition>\n\n                <v-expand-transition>\n                  <div\n                    v-if=\"\n                      state !== states.EDIT_AVAILABILITY &&\n                      max !== respondents.length &&\n                      Object.keys(fetchedResponses).length !== 0 &&\n                      !loadingResponses.loading\n                    \"\n                  >\n                    <div class=\"tw-mt-2 tw-text-sm tw-text-dark-gray\">\n                      Note: There's no time when all\n                      {{ respondents.length }} respondents are available.\n                    </div>\n                  </div>\n                </v-expand-transition>\n\n                <ToolRow\n                  v-if=\"!isPhone && !calendarOnly\"\n                  :event=\"event\"\n                  :state=\"state\"\n                  :states=\"states\"\n                  :cur-timezone.sync=\"curTimezone\"\n                  :show-best-times.sync=\"showBestTimes\"\n                  :hide-if-needed.sync=\"hideIfNeeded\"\n                  :is-weekly=\"isWeekly\"\n                  :calendar-permission-granted=\"calendarPermissionGranted\"\n                  :week-offset=\"weekOffset\"\n                  :num-responses=\"respondents.length\"\n                  :mobile-num-days.sync=\"mobileNumDays\"\n                  :allow-schedule-event=\"allowScheduleEvent\"\n                  :show-event-options=\"showEventOptions\"\n                  :time-type.sync=\"timeType\"\n                  @toggleShowEventOptions=\"toggleShowEventOptions\"\n                  @update:weekOffset=\"(val) => $emit('update:weekOffset', val)\"\n                  @scheduleEvent=\"scheduleEvent\"\n                  @cancelScheduleEvent=\"cancelScheduleEvent\"\n                  @confirmScheduleEvent=\"confirmScheduleEvent\"\n                />\n              </div>\n\n              <div\n                v-if=\"!calendarOnly\"\n                :class=\"calendarOnly ? 'tw-invisible' : 'tw-visible'\"\n                class=\"tw-sticky tw-top-14 tw-z-10 tw-mb-4 tw-h-11 tw-bg-white sm:tw-top-16\"\n              >\n                <div\n                  :class=\"hasNextPage ? 'tw-visible' : 'tw-invisible'\"\n                  class=\"tw-sticky tw-top-14 -tw-mr-2 tw-self-start tw-pt-1.5 sm:tw-top-16\"\n                >\n                  <v-btn class=\"tw-border-gray\" outlined icon @click=\"nextPage\"\n                    ><v-icon>mdi-chevron-right</v-icon></v-btn\n                  >\n                </div>\n              </div>\n            </template>\n          </div>\n\n          <!-- Right hand side content -->\n\n          <div\n            v-if=\"!calendarOnly\"\n            class=\"tw-px-4 tw-py-4 sm:tw-sticky sm:tw-top-16 sm:tw-flex-none sm:tw-self-start sm:tw-py-0 sm:tw-pl-0 sm:tw-pr-0 sm:tw-pt-14\"\n            :style=\"{ width: rightSideWidth }\"\n          >\n            <!-- Show section on the right depending on some if conditions -->\n            <template v-if=\"isSignUp\">\n              <div class=\"tw-mb-2 tw-text-lg tw-text-black\">Slots</div>\n              <div v-if=\"!isOwner\" class=\"tw-mb-3 tw-flex tw-flex-col\">\n                <div\n                  class=\"tw-flex tw-flex-col tw-gap-1 tw-rounded-md tw-bg-light-gray tw-p-3 tw-text-xs tw-italic tw-text-dark-gray\"\n                >\n                  <div v-if=\"!authUser || alreadyRespondedToSignUpForm\">\n                    <a class=\"tw-underline\" :href=\"`mailto:${event.ownerId}`\"\n                      >Contact sign up creator</a\n                    >\n                    to edit your slot\n                  </div>\n                  <div v-if=\"event.blindAvailabilityEnabled\">\n                    Responses are only visible to creator\n                  </div>\n                </div>\n              </div>\n              <SignUpBlocksList\n                ref=\"signUpBlocksList\"\n                :signUpBlocks=\"signUpBlocksByDay.flat()\"\n                :signUpBlocksToAdd=\"signUpBlocksToAddByDay.flat()\"\n                :isEditing=\"state == states.EDIT_SIGN_UP_BLOCKS\"\n                :isOwner=\"isOwner\"\n                :alreadyResponded=\"alreadyRespondedToSignUpForm\"\n                :anonymous=\"event.blindAvailabilityEnabled\"\n                @update:signUpBlock=\"editSignUpBlock\"\n                @delete:signUpBlock=\"deleteSignUpBlock\"\n                @signUpForBlock=\"$emit('signUpForBlock', $event)\"\n              />\n            </template>\n            <template v-else-if=\"state === states.SET_SPECIFIC_TIMES\">\n              <SpecificTimesInstructions\n                v-if=\"!isPhone\"\n                :numTempTimes=\"tempTimes.size\"\n                @saveTempTimes=\"saveTempTimes\"\n              />\n            </template>\n            <template v-else>\n              <div\n                class=\"tw-flex tw-flex-col tw-gap-5\"\n                v-if=\"state == states.EDIT_AVAILABILITY\"\n              >\n                <div\n                  v-if=\"\n                    !(\n                      calendarPermissionGranted &&\n                      !event.daysOnly &&\n                      !addingAvailabilityAsGuest\n                    )\n                  \"\n                  class=\"tw-text-sm tw-italic tw-text-dark-gray\"\n                >\n                  {{\n                    (userHasResponded && !addingAvailabilityAsGuest) ||\n                    curGuestId\n                      ? \"Editing\"\n                      : \"Adding\"\n                  }}\n                  availability as\n                  {{\n                    authUser && !addingAvailabilityAsGuest\n                      ? `${authUser.firstName} ${authUser.lastName}`\n                      : curGuestId?.length > 0\n                      ? curGuestId\n                      : \"a guest\"\n                  }}\n                </div>\n                <AvailabilityTypeToggle\n                  v-if=\"!isGroup && !isPhone\"\n                  class=\"tw-w-full\"\n                  v-model=\"availabilityType\"\n                />\n                <!-- User's calendar accounts -->\n                <CalendarAccounts\n                  v-if=\"\n                    calendarPermissionGranted &&\n                    !event.daysOnly &&\n                    !addingAvailabilityAsGuest\n                  \"\n                  :toggleState=\"true\"\n                  :eventId=\"event._id\"\n                  :calendar-events-map=\"calendarEventsMap\"\n                  :syncWithBackend=\"!isGroup\"\n                  :allowAddCalendarAccount=\"!isGroup\"\n                  @toggleCalendarAccount=\"toggleCalendarAccount\"\n                  @toggleSubCalendarAccount=\"toggleSubCalendarAccount\"\n                  :initialCalendarAccountsData=\"\n                    isGroup ? sharedCalendarAccounts : authUser.calendarAccounts\n                  \"\n                ></CalendarAccounts>\n\n                <div v-if=\"showOverlayAvailabilityToggle\">\n                  <v-switch\n                    id=\"overlay-availabilities-toggle\"\n                    inset\n                    :input-value=\"overlayAvailability\"\n                    @change=\"updateOverlayAvailability\"\n                    hide-details\n                  >\n                    <template v-slot:label>\n                      <div class=\"tw-text-sm tw-text-black\">\n                        Overlay availabilities\n                      </div>\n                    </template>\n                  </v-switch>\n\n                  <div class=\"tw-mt-2 tw-text-xs tw-text-dark-gray\">\n                    View everyone's availability while inputting your own\n                  </div>\n                </div>\n\n                <!-- Options section removed by request: 'Option' feature and all its content are now commented out.\n                <div\n                  v-if=\"!event.daysOnly && showCalendarOptions\"\n                  ref=\"optionsSection\"\n                >\n                  <ExpandableSection\n                    label=\"Options\"\n                    :value=\"showEditOptions\"\n                    @input=\"toggleShowEditOptions\"\n                  >\n                    <div class=\"tw-flex tw-flex-col tw-gap-5 tw-pt-2.5\">\n                      <v-dialog\n                        v-if=\"showCalendarOptions\"\n                        v-model=\"calendarOptionsDialog\"\n                        width=\"500\"\n                      >\n                        <template v-slot:activator=\"{ on, attrs }\">\n                          <v-btn\n                            outlined\n                            class=\"tw-border-gray tw-text-sm\"\n                            v-on=\"on\"\n                            v-bind=\"attrs\"\n                          >\n                            Calendar options...\n                          </v-btn>\n                        </template>\n\n                        <v-card>\n                          <v-card-title class=\"tw-flex\">\n                            <div>Calendar options</div>\n                            <v-spacer />\n                            <v-btn icon @click=\"calendarOptionsDialog = false\">\n                              <v-icon>mdi-close</v-icon>\n                            </v-btn>\n                          </v-card-title>\n                          <v-card-text\n                            class=\"tw-flex tw-flex-col tw-gap-6 tw-pb-8 tw-pt-2\"\n                          >\n                            <AlertText v-if=\"isGroup\" class=\"-tw-mb-4\">\n                              Calendar options will only updated for the current\n                              group\n                            </AlertText>\n\n                            <BufferTimeSwitch\n                              :bufferTime.sync=\"bufferTime\"\n                              :syncWithBackend=\"!isGroup\"\n                            />\n\n                            <WorkingHoursToggle\n                              :workingHours.sync=\"workingHours\"\n                              :timezone=\"curTimezone\"\n                              :syncWithBackend=\"!isGroup\"\n                            />\n                          </v-card-text>\n                        </v-card>\n                      </v-dialog>\n                    </div>\n                  </ExpandableSection>\n                </div>\n                -->\n\n                <!-- Delete availability button -->\n                <div\n                  v-if=\"\n                    (!addingAvailabilityAsGuest && userHasResponded) ||\n                    curGuestId\n                  \"\n                >\n                  <v-dialog\n                    v-model=\"deleteAvailabilityDialog\"\n                    width=\"500\"\n                    persistent\n                  >\n                    <template v-slot:activator=\"{ on, attrs }\">\n                      <span\n                        v-bind=\"attrs\"\n                        v-on=\"on\"\n                        class=\"tw-cursor-pointer tw-text-sm tw-text-red\"\n                      >\n                        {{ !isGroup ? \"Delete availability\" : \"Leave group\" }}\n                      </span>\n                    </template>\n\n                    <v-card>\n                      <v-card-title>Are you sure?</v-card-title>\n                      <v-card-text class=\"tw-text-sm tw-text-dark-gray\"\n                        >Are you sure you want to\n                        {{\n                          !isGroup\n                            ? \"delete your availability from this event?\"\n                            : \"leave this group?\"\n                        }}</v-card-text\n                      >\n                      <v-card-actions>\n                        <v-spacer />\n                        <v-btn text @click=\"deleteAvailabilityDialog = false\"\n                          >Cancel</v-btn\n                        >\n                        <v-btn\n                          text\n                          color=\"error\"\n                          @click=\"\n                            $emit('deleteAvailability')\n                            deleteAvailabilityDialog = false\n                          \"\n                          >{{ !isGroup ? \"Delete\" : \"Leave\" }}</v-btn\n                        >\n                      </v-card-actions>\n                    </v-card>\n                  </v-dialog>\n                </div>\n              </div>\n              <template v-else>\n                <RespondentsList\n                  ref=\"respondentsList\"\n                  :event=\"event\"\n                  :eventId=\"event._id\"\n                  :days=\"allDays\"\n                  :times=\"times\"\n                  :curDate=\"getDateFromRowCol(curTimeslot.row, curTimeslot.col)\"\n                  :curRespondent=\"curRespondent\"\n                  :curRespondents=\"curRespondents\"\n                  :curTimeslot=\"curTimeslot\"\n                  :curTimeslotAvailability=\"curTimeslotAvailability\"\n                  :respondents=\"respondents\"\n                  :parsedResponses=\"parsedResponses\"\n                  :isOwner=\"isOwner\"\n                  :isGroup=\"isGroup\"\n                  :attendees=\"event.attendees\"\n                  :showCalendarEvents.sync=\"showCalendarEvents\"\n                  :responsesFormatted=\"responsesFormatted\"\n                  :timezone=\"curTimezone\"\n                  :show-best-times.sync=\"showBestTimes\"\n                  :hide-if-needed.sync=\"hideIfNeeded\"\n                  :start-calendar-on-monday.sync=\"startCalendarOnMonday\"\n                  :show-event-options=\"showEventOptions\"\n                  :guestAddedAvailability=\"guestAddedAvailability\"\n                  :addingAvailabilityAsGuest=\"addingAvailabilityAsGuest\"\n                  @toggleShowEventOptions=\"toggleShowEventOptions\"\n                  @addAvailability=\"$emit('addAvailability')\"\n                  @addAvailabilityAsGuest=\"$emit('addAvailabilityAsGuest')\"\n                  @mouseOverRespondent=\"mouseOverRespondent\"\n                  @mouseLeaveRespondent=\"mouseLeaveRespondent\"\n                  @clickRespondent=\"clickRespondent\"\n                  @editGuestAvailability=\"editGuestAvailability\"\n                  @refreshEvent=\"refreshEvent\"\n                />\n              </template>\n            </template>\n          </div>\n        </div>\n\n        <ToolRow\n          v-if=\"isPhone && !calendarOnly\"\n          class=\"tw-px-4\"\n          :event=\"event\"\n          :state=\"state\"\n          :states=\"states\"\n          :cur-timezone.sync=\"curTimezone\"\n          :show-best-times.sync=\"showBestTimes\"\n          :hide-if-needed.sync=\"hideIfNeeded\"\n          :start-calendar-on-monday.sync=\"startCalendarOnMonday\"\n          :is-weekly=\"isWeekly\"\n          :calendar-permission-granted=\"calendarPermissionGranted\"\n          :week-offset=\"weekOffset\"\n          :num-responses=\"respondents.length\"\n          :mobile-num-days.sync=\"mobileNumDays\"\n          :allow-schedule-event=\"allowScheduleEvent\"\n          :show-event-options=\"showEventOptions\"\n          :time-type.sync=\"timeType\"\n          @toggleShowEventOptions=\"toggleShowEventOptions\"\n          @update:weekOffset=\"(val) => $emit('update:weekOffset', val)\"\n          @scheduleEvent=\"scheduleEvent\"\n          @cancelScheduleEvent=\"cancelScheduleEvent\"\n          @confirmScheduleEvent=\"confirmScheduleEvent\"\n        />\n\n        <!-- Fixed bottom section for mobile -->\n        <div\n          v-if=\"isPhone && !calendarOnly\"\n          class=\"tw-fixed tw-bottom-16 tw-z-20 tw-w-full\"\n        >\n          <!-- Hint text (mobile) -->\n          <v-expand-transition>\n            <template v-if=\"hintTextShown\">\n              <div :key=\"hintText\">\n                <div\n                  :class=\"`tw-flex tw-w-full tw-items-center tw-justify-between tw-gap-1 tw-bg-light-gray tw-px-2 tw-py-2 tw-text-sm tw-text-very-dark-gray`\"\n                >\n                  <div\n                    :class=\"`tw-flex tw-gap-${hintText.length > 60 ? 2 : 1}`\"\n                  >\n                    <v-icon small>mdi-information-outline</v-icon>\n                    <div>\n                      {{ hintText }}\n                    </div>\n                  </div>\n                  <v-icon small @click=\"closeHint\">mdi-close</v-icon>\n                </div>\n              </div>\n            </template>\n          </v-expand-transition>\n\n          <!-- Fixed pos availability toggle (mobile) -->\n          <v-expand-transition>\n            <div v-if=\"!isGroup && editing && !isSignUp\">\n              <div class=\"tw-bg-white tw-p-4\">\n                <AvailabilityTypeToggle\n                  class=\"tw-w-full\"\n                  v-model=\"availabilityType\"\n                />\n              </div>\n            </div>\n          </v-expand-transition>\n\n          <!-- GCal week selector -->\n          <v-expand-transition>\n            <div v-if=\"isWeekly && editing && calendarPermissionGranted\">\n              <div class=\"tw-h-16 tw-text-sm\">\n                <GCalWeekSelector\n                  :week-offset=\"weekOffset\"\n                  :event=\"event\"\n                  @update:weekOffset=\"(val) => $emit('update:weekOffset', val)\"\n                  :start-on-monday=\"event.startOnMonday\"\n                />\n              </div>\n            </div>\n          </v-expand-transition>\n\n          <!-- Respondents list -->\n          <v-expand-transition>\n            <div v-if=\"delayedShowStickyRespondents\">\n              <div class=\"tw-bg-white tw-p-4\">\n                <RespondentsList\n                  :max-height=\"100\"\n                  :event=\"event\"\n                  :eventId=\"event._id\"\n                  :days=\"allDays\"\n                  :times=\"times\"\n                  :curDate=\"getDateFromRowCol(curTimeslot.row, curTimeslot.col)\"\n                  :curRespondent=\"curRespondent\"\n                  :curRespondents=\"curRespondents\"\n                  :curTimeslot=\"curTimeslot\"\n                  :curTimeslotAvailability=\"curTimeslotAvailability\"\n                  :respondents=\"respondents\"\n                  :parsedResponses=\"parsedResponses\"\n                  :isOwner=\"isOwner\"\n                  :isGroup=\"isGroup\"\n                  :attendees=\"event.attendees\"\n                  :showCalendarEvents.sync=\"showCalendarEvents\"\n                  :responsesFormatted=\"responsesFormatted\"\n                  :timezone=\"curTimezone\"\n                  :show-best-times.sync=\"showBestTimes\"\n                  :hide-if-needed.sync=\"hideIfNeeded\"\n                  :show-event-options=\"showEventOptions\"\n                  :guestAddedAvailability=\"guestAddedAvailability\"\n                  :addingAvailabilityAsGuest=\"addingAvailabilityAsGuest\"\n                  @toggleShowEventOptions=\"toggleShowEventOptions\"\n                  @addAvailability=\"$emit('addAvailability')\"\n                  @addAvailabilityAsGuest=\"$emit('addAvailabilityAsGuest')\"\n                  @mouseOverRespondent=\"mouseOverRespondent\"\n                  @mouseLeaveRespondent=\"mouseLeaveRespondent\"\n                  @clickRespondent=\"clickRespondent\"\n                  @editGuestAvailability=\"editGuestAvailability\"\n                  @refreshEvent=\"refreshEvent\"\n                />\n              </div>\n            </div>\n          </v-expand-transition>\n\n          <!-- Specific times instructions -->\n          <v-expand-transition>\n            <div\n              v-if=\"state === states.SET_SPECIFIC_TIMES\"\n              class=\"-tw-mb-16 tw-bg-white tw-p-4\"\n            >\n              <SpecificTimesInstructions\n                :numTempTimes=\"tempTimes.size\"\n                @saveTempTimes=\"saveTempTimes\"\n              />\n            </div>\n          </v-expand-transition>\n        </div>\n      </div>\n    </Tooltip>\n  </span>\n</template>\n\n<style scoped>\n.animate-bg-color {\n  transition: background-color 0.25s ease-in-out;\n}\n\n.break {\n  flex-basis: 100%;\n  height: 0;\n}\n</style>\n\n<style>\n/* Make timezone select element the same width as content */\n#timezone-select {\n  width: 5px;\n}\n</style>\n\n<script>\nimport {\n  timeNumToTimeText,\n  dateCompare,\n  getDateHoursOffset,\n  post,\n  put,\n  isBetween,\n  clamp,\n  isPhone,\n  utcTimeToLocalTime,\n  splitTimeBlocksByDay,\n  getTimeBlock,\n  dateToDowDate,\n  _delete,\n  get,\n  getDateDayOffset,\n  isDateBetween,\n  generateEnabledCalendarsPayload,\n  isTouchEnabled,\n  isElementInViewport,\n  lightOrDark,\n  removeTransparencyFromHex,\n  userPrefers12h,\n  getCalendarAccountKey,\n  getISODateString,\n  getDateWithTimezone,\n  timeNumToTimeString,\n  isPremiumUser,\n} from \"@/utils\"\nimport {\n  availabilityTypes,\n  calendarOptionsDefaults,\n  eventTypes,\n  timeTypes,\n  timeslotDurations,\n  upgradeDialogTypes,\n} from \"@/constants\"\nimport { mapMutations, mapActions, mapState } from \"vuex\"\nimport UserAvatarContent from \"@/components/UserAvatarContent.vue\"\nimport CalendarAccounts from \"@/components/settings/CalendarAccounts.vue\"\nimport Advertisement from \"@/components/event/Advertisement.vue\"\nimport SignUpBlock from \"@/components/sign_up_form/SignUpBlock.vue\"\nimport SignUpCalendarBlock from \"@/components/sign_up_form/SignUpCalendarBlock.vue\"\nimport SignUpBlocksList from \"@/components/sign_up_form/SignUpBlocksList.vue\"\nimport ZigZag from \"./ZigZag.vue\"\nimport ConfirmDetailsDialog from \"./ConfirmDetailsDialog.vue\"\nimport ToolRow from \"./ToolRow.vue\"\nimport RespondentsList from \"./RespondentsList.vue\"\nimport GCalWeekSelector from \"./GCalWeekSelector.vue\"\nimport ExpandableSection from \"../ExpandableSection.vue\"\nimport WorkingHoursToggle from \"./WorkingHoursToggle.vue\"\nimport AlertText from \"../AlertText.vue\"\nimport Tooltip from \"../Tooltip.vue\"\n\nimport dayjs from \"dayjs\"\nimport ObjectID from \"bson-objectid\"\nimport utcPlugin from \"dayjs/plugin/utc\"\nimport timezonePlugin from \"dayjs/plugin/timezone\"\nimport AvailabilityTypeToggle from \"./AvailabilityTypeToggle.vue\"\nimport BufferTimeSwitch from \"./BufferTimeSwitch.vue\"\nimport CalendarEventBlock from \"./CalendarEventBlock.vue\" // Added import\nimport SpecificTimesInstructions from \"./SpecificTimesInstructions.vue\"\ndayjs.extend(utcPlugin)\ndayjs.extend(timezonePlugin)\n\nexport default {\n  name: \"ScheduleOverlap\",\n  props: {\n    event: { type: Object, required: true },\n    fromEditEvent: { type: Boolean, default: false },\n\n    loadingCalendarEvents: { type: Boolean, default: false }, // Whether we are currently loading the calendar events\n    calendarEventsMap: { type: Object, default: () => {} }, // Object of different users' calendar events\n    sampleCalendarEventsByDay: { type: Array, required: false }, // Sample calendar events to use for example calendars\n    calendarPermissionGranted: { type: Boolean, default: false }, // Whether user has granted google calendar permissions\n\n    weekOffset: { type: Number, default: 0 }, // Week offset used for displaying calendar events on weekly schejs\n\n    alwaysShowCalendarEvents: { type: Boolean, default: false }, // Whether to show calendar events all the time\n    noEventNames: { type: Boolean, default: false }, // Whether to show \"busy\" instead of the event name\n    calendarOnly: { type: Boolean, default: false }, // Whether to only show calendar and not respondents or any other controls\n    interactable: { type: Boolean, default: true }, // Whether to allow user to interact with component\n    showSnackbar: { type: Boolean, default: true }, // Whether to show snackbar when availability is automatically filled in\n    animateTimeslotAlways: { type: Boolean, default: false }, // Whether to animate timeslots all the time\n    showHintText: { type: Boolean, default: true }, // Whether to show the hint text telling user what to do\n\n    curGuestId: { type: String, default: \"\" }, // Id of the current guest being edited\n    addingAvailabilityAsGuest: { type: Boolean, default: false }, // Whether the signed in user is adding availability as a guest\n\n    initialTimezone: { type: Object, default: () => ({}) },\n\n    // Availability Groups\n    calendarAvailabilities: { type: Object, default: () => ({}) },\n  },\n  data() {\n    return {\n      states: {\n        HEATMAP: \"heatmap\", // Display heatmap of availabilities\n        SINGLE_AVAILABILITY: \"single_availability\", // Show one person's availability\n        SUBSET_AVAILABILITY: \"subset_availability\", // Show availability for a subset of people\n        BEST_TIMES: \"best_times\", // Show only the times that work for most people\n        EDIT_AVAILABILITY: \"edit_availability\", // Edit current user's availability\n        EDIT_SIGN_UP_BLOCKS: \"edit_sign_up_blocks\", // Edit the slots on a sign up form\n        SCHEDULE_EVENT: \"schedule_event\", // Schedule event on gcal\n        SET_SPECIFIC_TIMES: \"set_specific_times\", // Set specific times for the event\n      },\n      state: \"best_times\",\n\n      availability: new Set(), // The current user's availability\n      ifNeeded: new Set(), // The current user's \"if needed\" availability\n      tempTimes: new Set(), // The specific times that the user has selected for the event (pending save)\n      availabilityAnimTimeouts: [], // Timeouts for availability animation\n      availabilityAnimEnabled: false, // Whether to animate timeslots changing colors\n      maxAnimTime: 1200, // Max amount of time for availability animation\n      unsavedChanges: false, // If there are unsaved availability changes\n      curTimeslot: { row: -1, col: -1 }, // The currently highlighted timeslot\n      timeslotSelected: false, // Whether a timeslot is selected (used to persist selection on desktop)\n      curTimeslotAvailability: {}, // The users available for the current timeslot\n      curRespondent: \"\", // Id of the active respondent (set on hover)\n      curRespondents: [], // Id of currently selected respondents (set on click)\n      sharedCalendarAccounts: {}, // The user's calendar accounts for changing calendar options for groups\n      fetchedResponses: {}, // Responses fetched from the server for the dates currently shown\n      loadingResponses: { loading: false, lastFetched: new Date().getTime() }, // Whether we're currently fetching the responses\n      responsesFormatted: new Map(), // Map where date/time is mapped to the people that are available then\n      tooltipContent: \"\", // The content of the tooltip\n\n      /* Sign up form */\n      signUpBlocksByDay: [], // The current event's sign up blocks by day\n      signUpBlocksToAddByDay: [], // The sign up blocks to be added after hitting 'save'\n\n      /* Edit options */\n      showEditOptions:\n        localStorage[\"showEditOptions\"] == undefined\n          ? false\n          : localStorage[\"showEditOptions\"] == \"true\",\n      availabilityType: availabilityTypes.AVAILABLE, // The current availability type\n      overlayAvailability: false, // Whether to overlay everyone's availability when editing\n      bufferTime: calendarOptionsDefaults.bufferTime, // Set in mounted()\n      workingHours: calendarOptionsDefaults.workingHours, // Set in mounted()\n\n      /* Event Options */\n      showEventOptions:\n        localStorage[\"showEventOptions\"] == undefined\n          ? false\n          : localStorage[\"showEventOptions\"] == \"true\",\n      showBestTimes:\n        localStorage[\"showBestTimes\"] == undefined\n          ? false\n          : localStorage[\"showBestTimes\"] == \"true\",\n      hideIfNeeded: false,\n\n      /* Variables for drag stuff */\n      DRAG_TYPES: {\n        ADD: \"add\",\n        REMOVE: \"remove\",\n      },\n      SPLIT_GAP_HEIGHT: 40,\n      SPLIT_GAP_WIDTH: 20,\n      HOUR_HEIGHT: 60,\n      timeslot: {\n        width: 0,\n        height: 0,\n      },\n      dragging: false,\n      dragType: \"add\",\n      dragStart: null,\n      dragCur: null,\n\n      /* Variables for options */\n      curTimezone: this.initialTimezone,\n      curScheduledEvent: null, // The scheduled event represented in the form {hoursOffset, hoursLength, dayIndex}\n      timeType:\n        localStorage[\"timeType\"] ??\n        (userPrefers12h() ? timeTypes.HOUR12 : timeTypes.HOUR24), // Whether 12-hour or 24-hour\n      showCalendarEvents: false,\n      startCalendarOnMonday: false,\n      // localStorage[\"startCalendarOnMonday\"] == undefined\n      //   ? false\n      //   : localStorage[\"startCalendarOnMonday\"] == \"true\",\n\n      /* Dialogs */\n      deleteAvailabilityDialog: false,\n      calendarOptionsDialog: false,\n\n      /* Variables for scrolling */\n      optionsVisible: false,\n      calendarScrollLeft: 0, // The current scroll position of the calendar\n      calendarMaxScroll: 0, // The maximum scroll amount of the calendar, scrolling to this point means we have scrolled to the end\n      scrolledToRespondents: false, // whether we have scrolled to the respondents section\n      delayedShowStickyRespondents: false, // showStickyRespondents variable but changes 100ms after the actual variable changes (to add some delay)\n      delayedShowStickyRespondentsTimeout: null, // Timeout that sets delayedShowStickyRespondents\n\n      /* Variables for pagination */\n      page: 0,\n      mobileNumDays: localStorage[\"mobileNumDays\"]\n        ? parseInt(localStorage[\"mobileNumDays\"])\n        : 3, // The number of days to show at a time on mobile\n      pageHasChanged: false,\n\n      hasRefreshedAuthUser: false,\n\n      /* Variables for hint */\n      hintState: true,\n\n      /** Groups */\n      manualAvailability: {},\n\n      /** Constants */\n      months: [\n        \"jan\",\n        \"feb\",\n        \"mar\",\n        \"apr\",\n        \"may\",\n        \"jun\",\n        \"jul\",\n        \"aug\",\n        \"sep\",\n        \"oct\",\n        \"nov\",\n        \"dec\",\n      ],\n    }\n  },\n  computed: {\n    ...mapState([\"authUser\", \"overlayAvailabilitiesEnabled\"]),\n    /** Returns the width of the right side of the calendar */\n    rightSideWidth() {\n      if (this.isPhone) return \"100%\"\n      return this.isSignUp ? \"18rem\" : \"13rem\"\n    },\n    /** Returns the days of the week in the correct order */\n    daysOfWeek() {\n      // 返回带“周”的中文星期标题\n      return !this.startCalendarOnMonday\n        ? [\"周日\", \"周一\", \"周二\", \"周三\", \"周四\", \"周五\", \"周六\"]\n        : [\"周一\", \"周二\", \"周三\", \"周四\", \"周五\", \"周六\", \"周日\"]\n    },\n    /** Only allow scheduling when a curScheduledEvent exists */\n    allowScheduleEvent() {\n      return !!this.curScheduledEvent\n    },\n    /** Returns the availability as an array */\n    availabilityArray() {\n      return [...this.availability].map((item) => new Date(item))\n    },\n    /** Returns the if needed availability as an array */\n    ifNeededArray() {\n      return [...this.ifNeeded].map((item) => new Date(item))\n    },\n    allowDrag() {\n      return (\n        this.state === this.states.EDIT_AVAILABILITY ||\n        this.state === this.states.EDIT_SIGN_UP_BLOCKS ||\n        this.state === this.states.SCHEDULE_EVENT ||\n        this.state === this.states.SET_SPECIFIC_TIMES\n      )\n    },\n    /** Returns an array of calendar events for all of the authUser's enabled calendars, separated by the day they occur on */\n    calendarEventsByDay() {\n      // If this is an example calendar\n      if (this.sampleCalendarEventsByDay) return this.sampleCalendarEventsByDay\n\n      // If the user isn't logged in or is adding availability as a guest\n      if (!this.authUser || this.addingAvailabilityAsGuest) return []\n\n      let events = []\n      let event\n\n      const calendarAccounts = this.isGroup\n        ? this.sharedCalendarAccounts\n        : this.authUser.calendarAccounts\n\n      // Adds events from calendar accounts that are enabled\n      for (const id in calendarAccounts) {\n        if (!calendarAccounts[id].enabled) continue\n\n        if (this.calendarEventsMap.hasOwnProperty(id)) {\n          for (const index in this.calendarEventsMap[id].calendarEvents) {\n            event = this.calendarEventsMap[id].calendarEvents[index]\n\n            // Check if we need to update authUser (to get latest subcalendars)\n            const subCalendars = calendarAccounts[id].subCalendars\n            if (!subCalendars || !(event.calendarId in subCalendars)) {\n              // authUser doesn't contain the subCalendar, so push event to events without checking if subcalendar is enabled\n              // and queue the authUser to be refreshed\n              events.push(event)\n              if (!this.hasRefreshedAuthUser && !this.isGroup) {\n                this.refreshAuthUser()\n              }\n              continue\n            }\n\n            // Push event to events if subcalendar is enabled\n            if (subCalendars[event.calendarId].enabled) {\n              events.push(event)\n            }\n          }\n        }\n      }\n\n      const eventsCopy = JSON.parse(JSON.stringify(events))\n\n      const calendarEventsByDay = splitTimeBlocksByDay(\n        this.event,\n        eventsCopy,\n        this.weekOffset,\n        this.timezoneOffset\n      )\n\n      return calendarEventsByDay\n    },\n    /** [SPECIFIC TO GROUPS] Returns an object mapping user ids to their calendar events separated by the day they occur on */\n    groupCalendarEventsByDay() {\n      if (this.event.type !== eventTypes.GROUP) return {}\n\n      const userIdToEventsByDay = {}\n      for (const userId in this.event.responses) {\n        if (userId === this.authUser._id) {\n          userIdToEventsByDay[userId] = this.calendarEventsByDay\n        } else if (userId in this.calendarAvailabilities) {\n          userIdToEventsByDay[userId] = splitTimeBlocksByDay(\n            this.event,\n            this.calendarAvailabilities[userId],\n            this.weekOffset,\n            this.timezoneOffset\n          )\n        }\n      }\n\n      return userIdToEventsByDay\n    },\n    curRespondentsSet() {\n      return new Set(this.curRespondents)\n    },\n\n    // -----------------------------------\n    //#region Sign up form\n    // -----------------------------------\n\n    /** Returns the name of the new sign up block being dragged */\n    newSignUpBlockName() {\n      return `Slot #${\n        this.signUpBlocksByDay.flat().length +\n        this.signUpBlocksToAddByDay.flat().length +\n        1\n      }`\n    },\n\n    /** Returns the max allowable drag */\n    maxSignUpBlockRowSize() {\n      if (!this.dragStart || !this.isSignUp) return null\n\n      const selectedDay = this.signUpBlocksByDay[this.dragStart.col]\n      const selectedDayToAdd = this.signUpBlocksToAddByDay[this.dragStart.col]\n\n      if (selectedDay.length === 0 && selectedDayToAdd.length === 0) return null\n\n      let maxSize = Infinity\n      for (const block of [...selectedDay, ...selectedDayToAdd]) {\n        if (block.hoursOffset * 4 > this.dragStart.row) {\n          maxSize = Math.min(\n            maxSize,\n            block.hoursOffset * 4 - this.dragStart.row\n          )\n        }\n      }\n\n      return maxSize\n    },\n\n    /** Whether the current user has already responded to the sign up form */\n    alreadyRespondedToSignUpForm() {\n      if (!this.authUser || !this.signUpBlocksByDay) return false\n\n      return this.signUpBlocksByDay.some((dayBlocks) =>\n        dayBlocks.some((block) =>\n          block.responses?.some(\n            (response) => response.userId === this.authUser._id\n          )\n        )\n      )\n    },\n\n    //#endregion\n\n    /** Returns the max number of people in the curRespondents array available at any given time */\n    curRespondentsMax() {\n      let max = 0\n      if (this.event.daysOnly) {\n        for (const day of this.allDays) {\n          const num = [\n            ...(this.responsesFormatted.get(day.dateObject.getTime()) ??\n              new Set()),\n          ].filter((r) => this.curRespondentsSet.has(r)).length\n\n          if (num > max) max = num\n        }\n      } else {\n        for (let i = 0; i < this.event.dates.length; i++) {\n          const date = new Date(this.event.dates[i])\n          for (const time of this.times) {\n            const num = [\n              ...this.getRespondentsForHoursOffset(date, time.hoursOffset),\n            ].filter((r) => this.curRespondentsSet.has(r)).length\n\n            if (num > max) max = num\n          }\n        }\n      }\n      return max\n    },\n    /** Returns the day offset caused by the timezone offset. If the timezone offset changes the date, dayOffset != 0 */\n    dayOffset() {\n      return Math.floor((this.event.startTime - this.timezoneOffset / 60) / 24)\n    },\n    /** Returns all the days that are encompassed by startDate and endDate */\n    allDays() {\n      const days = []\n      const datesSoFar = new Set()\n\n      const getDateString = (date) => {\n        let dateString = \"\"\n        let dayString = \"\"\n        const offsetDate = new Date(date)\n        if (this.isSpecificTimes) {\n          offsetDate.setTime(\n            offsetDate.getTime() - this.timezoneOffset * 60 * 1000\n          )\n        } else {\n          offsetDate.setDate(offsetDate.getDate() + this.dayOffset)\n        }\n        if (this.isSpecificDates) {\n          dateString = `${\n            this.months[offsetDate.getUTCMonth()]\n          } ${offsetDate.getUTCDate()}`\n          dayString = this.daysOfWeek[offsetDate.getUTCDay()]\n        } else if (this.isGroup || this.isWeekly) {\n          const tmpDate = dateToDowDate(\n            this.event.dates,\n            offsetDate,\n            this.weekOffset,\n            true\n          )\n\n          dateString = `${\n            this.months[tmpDate.getUTCMonth()]\n          } ${tmpDate.getUTCDate()}`\n          dayString = this.daysOfWeek[tmpDate.getUTCDay()]\n        }\n        return { dateString, dayString }\n      }\n\n      if (\n        this.isSpecificTimes &&\n        (this.state === this.states.SET_SPECIFIC_TIMES ||\n          this.event.times?.length === 0)\n      ) {\n        let prevDate = null // Stores the prevDate to check if the current date is consecutive to the previous date\n        for (let i = 0; i < this.event.dates.length; ++i) {\n          const date = new Date(this.event.dates[i])\n          const localDate = new Date(\n            date.getTime() - this.timezoneOffset * 60 * 1000\n          )\n          localDate.setUTCHours(0, 0, 0, 0)\n          localDate.setTime(\n            localDate.getTime() + this.timezoneOffset * 60 * 1000\n          )\n\n          if (!datesSoFar.has(localDate.getTime())) {\n            datesSoFar.add(localDate.getTime())\n\n            let isConsecutive = true\n            if (prevDate) {\n              isConsecutive =\n                prevDate.getTime() === localDate.getTime() - 24 * 60 * 60 * 1000\n            }\n            const { dayString, dateString } = getDateString(localDate)\n            days.push({\n              dayText: dayString,\n              dateString,\n              dateObject: localDate,\n              isConsecutive,\n            })\n\n            prevDate = new Date(localDate)\n          }\n        }\n        return days\n      }\n\n      for (let i = 0; i < this.event.dates.length; ++i) {\n        const date = new Date(this.event.dates[i])\n        datesSoFar.add(date.getTime())\n\n        const { dayString, dateString } = getDateString(date)\n        days.push({\n          dayText: dayString,\n          dateString,\n          dateObject: date,\n        })\n      }\n\n      let dayIndex = 0\n      for (let i = 0; i < this.event.dates.length; ++i) {\n        const date = new Date(this.event.dates[i])\n        // See if the date goes into the next day\n        const localStart = new Date(\n          date.getTime() - this.timezoneOffset * 60 * 1000\n        )\n        const localEnd = new Date(\n          date.getTime() +\n            this.event.duration * 60 * 60 * 1000 -\n            this.timezoneOffset * 60 * 1000\n        )\n        const localEndIsMidnight =\n          localEnd.getUTCHours() === 0 && localEnd.getUTCMinutes() === 0\n        if (\n          localStart.getUTCDate() !== localEnd.getUTCDate() &&\n          !localEndIsMidnight\n        ) {\n          // The date goes into the next day. Split the date into two dates\n          let nextDate = new Date(date)\n          nextDate.setUTCDate(nextDate.getUTCDate() + 1)\n          if (!datesSoFar.has(nextDate.getTime())) {\n            datesSoFar.add(nextDate.getTime())\n\n            const { dayString, dateString } = getDateString(nextDate)\n            days.splice(dayIndex + 1, 0, {\n              dayText: dayString,\n              dateString,\n              dateObject: nextDate,\n              excludeTimes: true,\n            })\n            dayIndex++\n          }\n        }\n        dayIndex++\n      }\n\n      let prevDate = null // Stores the prevDate to check if the current date is consecutive to the previous date\n      for (let i = 0; i < days.length; ++i) {\n        let isConsecutive = true\n        if (prevDate) {\n          isConsecutive =\n            prevDate.getTime() ===\n            days[i].dateObject.getTime() - 24 * 60 * 60 * 1000\n        }\n\n        days[i].isConsecutive = isConsecutive\n\n        prevDate = new Date(days[i].dateObject)\n      }\n\n      return days\n    },\n    /** Returns a subset of all days based on the page number */\n    days() {\n      const slice = this.allDays.slice(\n        this.page * this.maxDaysPerPage,\n        (this.page + 1) * this.maxDaysPerPage\n      )\n      slice[0] = { ...slice[0], isConsecutive: true }\n      return slice\n    },\n    /** Returns all the days of the month */\n    monthDays() {\n      const monthDays = []\n      const allDaysSet = new Set(\n        this.allDays.map((d) => d.dateObject.getTime())\n      )\n\n      // Calculate monthIndex and year from event start date and page num\n      const date = new Date(this.event.dates[0])\n      const monthIndex = date.getUTCMonth() + this.page\n      const year = date.getUTCFullYear()\n\n      const lastDayOfPrevMonth = new Date(Date.UTC(year, monthIndex, 0))\n      const lastDayOfCurMonth = new Date(Date.UTC(year, monthIndex + 1, 0))\n\n      // Calculate num days from prev month, cur month, and next month to show\n      const curDate = new Date(lastDayOfPrevMonth)\n      let numDaysFromPrevMonth = 0\n      const numDaysInCurMonth = lastDayOfCurMonth.getUTCDate()\n      const numDaysFromNextMonth = 6 - lastDayOfCurMonth.getUTCDay()\n      const hasDaysFromPrevMonth = !this.startCalendarOnMonday\n        ? lastDayOfPrevMonth.getUTCDay() < 6\n        : lastDayOfPrevMonth.getUTCDay() != 0\n      if (hasDaysFromPrevMonth) {\n        curDate.setUTCDate(\n          curDate.getUTCDate() -\n            (lastDayOfPrevMonth.getUTCDay() -\n              (this.startCalendarOnMonday ? 1 : 0))\n        )\n        numDaysFromPrevMonth = lastDayOfPrevMonth.getUTCDay() + 1\n      } else {\n        curDate.setUTCDate(curDate.getUTCDate() + 1)\n      }\n      curDate.setUTCHours(this.event.startTime)\n\n      // Add all days from prev month, cur month, and next month\n      const totalDays =\n        numDaysFromPrevMonth + numDaysInCurMonth + numDaysFromNextMonth\n      for (let i = 0; i < totalDays; ++i) {\n        // Only include days from the current month\n        if (curDate.getUTCMonth() === lastDayOfCurMonth.getUTCMonth()) {\n          monthDays.push({\n            date: curDate.getUTCDate(),\n            time: curDate.getTime(),\n            dateObject: new Date(curDate),\n            included: allDaysSet.has(curDate.getTime()),\n          })\n        } else {\n          monthDays.push({\n            date: \"\",\n            time: curDate.getTime(),\n            dateObject: new Date(curDate),\n            included: false,\n          })\n        }\n\n        curDate.setUTCDate(curDate.getUTCDate() + 1)\n      }\n\n      return monthDays\n    },\n    /** Map from datetime to whether that month day is included  */\n    monthDayIncluded() {\n      const includedMap = new Map()\n      for (const monthDay of this.monthDays) {\n        includedMap.set(monthDay.dateObject.getTime(), monthDay.included)\n      }\n      return includedMap\n    },\n    /** Returns the text to show for the current month */\n    curMonthText() {\n      const date = new Date(this.event.dates[0])\n      const monthIndex = date.getUTCMonth() + this.page\n      const year = date.getUTCFullYear()\n      const lastDayOfCurMonth = new Date(Date.UTC(year, monthIndex + 1, 0))\n\n      const monthText = this.months[lastDayOfCurMonth.getUTCMonth()]\n      const yearText = lastDayOfCurMonth.getUTCFullYear()\n      return `${monthText} ${yearText}`\n    },\n    defaultState() {\n      // Either the heatmap or the best_times state, depending on the toggle\n      return this.showBestTimes ? this.states.BEST_TIMES : this.states.HEATMAP\n    },\n    editing() {\n      // Returns whether currently in the editing state\n      return (\n        this.state === this.states.EDIT_AVAILABILITY ||\n        this.state === this.states.EDIT_SIGN_UP_BLOCKS\n      )\n    },\n    scheduling() {\n      // Returns whether currently in the scheduling state\n      return this.state === this.states.SCHEDULE_EVENT\n    },\n    isPhone() {\n      return isPhone(this.$vuetify)\n    },\n    isOwner() {\n      return this.authUser?._id === this.event.ownerId\n    },\n    isSpecificDates() {\n      return this.event.type === eventTypes.SPECIFIC_DATES || !this.event.type\n    },\n    isWeekly() {\n      return this.event.type === eventTypes.DOW\n    },\n    isGroup() {\n      return this.event.type === eventTypes.GROUP\n    },\n    isSignUp() {\n      return this.event.isSignUpForm\n    },\n    isSpecificTimes() {\n      return this.event.hasSpecificTimes\n    },\n    respondents() {\n      return Object.values(this.parsedResponses)\n        .map((r) => r.user)\n        .filter(Boolean)\n    },\n    selectedGuestRespondent() {\n      if (this.guestAddedAvailability) return this.guestName\n\n      if (this.curRespondents.length !== 1) return \"\"\n\n      const user = this.parsedResponses[this.curRespondents[0]].user\n      return this.isGuest(user) ? user._id : \"\"\n    },\n    scheduledEventStyle() {\n      const style = {}\n      let top, height, isSecondSplit\n      if (this.dragging) {\n        top = this.dragStart.row\n        height = this.dragCur.row - this.dragStart.row + 1\n        isSecondSplit = this.dragStart.row >= this.splitTimes[0].length\n      } else {\n        top = this.curScheduledEvent.row\n        height = this.curScheduledEvent.numRows\n        isSecondSplit = this.curScheduledEvent.row >= this.splitTimes[0].length\n      }\n\n      if (isSecondSplit) {\n        style.top = `calc(${top} * ${this.timeslotHeight}px + ${this.SPLIT_GAP_HEIGHT}px)`\n      } else {\n        style.top = `calc(${top} * ${this.timeslotHeight}px)`\n      }\n      style.height = `calc(${height} * ${this.timeslotHeight}px)`\n      return style\n    },\n    signUpBlockBeingDraggedStyle() {\n      const style = {}\n      let top = 0,\n        height = 0\n      if (this.dragging) {\n        top = this.dragStart.row\n        height = this.dragCur.row - this.dragStart.row + 1\n      }\n      style.top = `calc(${top} * 1rem)`\n      style.height = `calc(${height} * 1rem)`\n      return style\n    },\n    /** Parses the responses to the Schej, makes necessary changes based on the type of event, and returns it */\n    parsedResponses() {\n      const parsed = {}\n\n      // Return calendar availability if group\n      if (this.event.type === eventTypes.GROUP) {\n        for (const userId in this.event.responses) {\n          const calendarEventsByDay = this.groupCalendarEventsByDay[userId]\n          if (calendarEventsByDay) {\n            // Get manual availability and convert to DOW dates\n            const fetchedManualAvailability = this.getManualAvailabilityDow(\n              this.fetchedResponses[userId]?.manualAvailability\n            )\n            const curManualAvailability =\n              userId === this.authUser._id\n                ? this.getManualAvailabilityDow(this.manualAvailability)\n                : {}\n\n            // Get availability from calendar events and use manual availability on the\n            // \"touched\" days\n            const availability = this.getAvailabilityFromCalendarEvents({\n              calendarEventsByDay,\n              includeTouchedAvailability: true,\n              fetchedManualAvailability: fetchedManualAvailability ?? {},\n              curManualAvailability: curManualAvailability ?? {},\n              calendarOptions:\n                userId === this.authUser._id\n                  ? {\n                      bufferTime: this.bufferTime,\n                      workingHours: this.workingHours,\n                    }\n                  : this.fetchedResponses[userId]?.calendarOptions ?? undefined,\n            })\n\n            parsed[userId] = {\n              ...this.event.responses[userId],\n              availability: availability,\n            }\n          } else {\n            parsed[userId] = {\n              ...this.event.responses[userId],\n              availability: new Set(),\n            }\n          }\n        }\n        return parsed\n      }\n\n      // Return only current user availability if using blind availabilities and user is not owner\n      if (this.event.blindAvailabilityEnabled && !this.isOwner) {\n        const guestName = localStorage[this.guestNameKey]\n        const userId = this.authUser?._id ?? guestName\n        if (userId in this.event.responses) {\n          const user = {\n            ...this.event.responses[userId].user,\n            _id: userId,\n          }\n          parsed[userId] = {\n            ...this.event.responses[userId],\n            availability: new Set(\n              this.fetchedResponses[userId]?.availability?.map((a) =>\n                new Date(a).getTime()\n              )\n            ),\n            ifNeeded: new Set(\n              this.fetchedResponses[userId]?.ifNeeded?.map((a) =>\n                new Date(a).getTime()\n              )\n            ),\n            user: user,\n          }\n        }\n        return parsed\n      }\n\n      // Otherwise, parse responses so that if _id is null (i.e. guest user), then it is set to the guest user's name\n      for (const k of Object.keys(this.event.responses)) {\n        const newUser = {\n          ...this.event.responses[k].user,\n          _id: k,\n        }\n        parsed[k] = {\n          ...this.event.responses[k],\n          availability: new Set(\n            this.fetchedResponses[k]?.availability?.map((a) =>\n              new Date(a).getTime()\n            )\n          ),\n          ifNeeded: new Set(\n            this.fetchedResponses[k]?.ifNeeded?.map((a) =>\n              new Date(a).getTime()\n            )\n          ),\n          user: newUser,\n        }\n      }\n      return parsed\n    },\n    max() {\n      let max = 0\n      for (const [dateTime, availability] of this.responsesFormatted) {\n        if (availability.size > max) {\n          max = availability.size\n        }\n      }\n\n      return max\n    },\n    /** Returns a set containing the times for the event if it has specific times */\n    specificTimesSet() {\n      return new Set(this.event.times?.map((t) => new Date(t).getTime()) ?? [])\n    },\n    /**\n     * Returns a two dimensional array of times\n     * IF endTime < startTime:\n     * the first element is an array of times between 12am and end time and the second element is an array of times between start time and 12am\n     * ELSE:\n     * the first element is an array of times between start time and end time. the second element is an empty array\n     * */\n    splitTimes() {\n      const splitTimes = [[], []]\n\n      const utcStartTime = this.event.startTime\n      const utcEndTime = this.event.startTime + this.event.duration\n      const localStartTime = utcTimeToLocalTime(\n        utcStartTime,\n        this.timezoneOffset\n      )\n      const localEndTime = utcTimeToLocalTime(utcEndTime, this.timezoneOffset)\n\n      // Weird timezones are timezones that are not a multiple of 60 minutes (e.g. GMT-2:30)\n      const isWeirdTimezone = this.timezoneOffset % 60 !== 0\n      const startTimeIsWeird = utcStartTime % 1 !== 0\n      let timeOffset = 0\n      if (isWeirdTimezone !== startTimeIsWeird) {\n        timeOffset = -0.5\n      }\n\n      const getExtraTimes = (hoursOffset) => {\n        if (this.timeslotDuration === timeslotDurations.FIFTEEN_MINUTES) {\n          return [\n            {\n              hoursOffset: hoursOffset + 0.25,\n            },\n            {\n              hoursOffset: hoursOffset + 0.5,\n            },\n            {\n              hoursOffset: hoursOffset + 0.75,\n            },\n          ]\n        } else if (this.timeslotDuration === timeslotDurations.THIRTY_MINUTES) {\n          return [\n            {\n              hoursOffset: hoursOffset + 0.5,\n            },\n          ]\n        }\n        return []\n      }\n\n      if (this.state === this.states.SET_SPECIFIC_TIMES) {\n        // Hours offset for specific times starts from minHours\n        for (let i = 0; i <= 23; ++i) {\n          const hoursOffset = i\n          if (i === 9) {\n            // add an id so we can scroll to it\n            splitTimes[0].push({\n              id: \"time-9\",\n              hoursOffset,\n              text: timeNumToTimeText(i, this.timeType === timeTypes.HOUR12),\n            })\n          } else {\n            splitTimes[0].push({\n              hoursOffset,\n              text: timeNumToTimeText(i, this.timeType === timeTypes.HOUR12),\n            })\n          }\n          splitTimes[0].push(...getExtraTimes(hoursOffset))\n        }\n        return splitTimes\n      }\n\n      if (localEndTime <= localStartTime && localEndTime !== 0) {\n        for (let i = 0; i < localEndTime; ++i) {\n          splitTimes[0].push({\n            hoursOffset: this.event.duration - (localEndTime - i),\n            text: timeNumToTimeText(i, this.timeType === timeTypes.HOUR12),\n          })\n          splitTimes[0].push(\n            ...getExtraTimes(this.event.duration - (localEndTime - i))\n          )\n        }\n        for (let i = 0; i < 24 - localStartTime; ++i) {\n          const adjustedI = i + timeOffset\n          splitTimes[1].push({\n            hoursOffset: adjustedI,\n            text: timeNumToTimeText(\n              localStartTime + adjustedI,\n              this.timeType === timeTypes.HOUR12\n            ),\n          })\n          splitTimes[1].push(...getExtraTimes(adjustedI))\n        }\n      } else {\n        for (let i = 0; i < this.event.duration; ++i) {\n          const adjustedI = i + timeOffset\n          const utcTimeNum = this.event.startTime + adjustedI\n          const localTimeNum = utcTimeToLocalTime(\n            utcTimeNum,\n            this.timezoneOffset\n          )\n\n          splitTimes[0].push({\n            hoursOffset: adjustedI,\n            text: timeNumToTimeText(\n              localTimeNum,\n              this.timeType === timeTypes.HOUR12\n            ),\n          })\n          splitTimes[0].push(...getExtraTimes(adjustedI))\n        }\n        if (timeOffset !== 0) {\n          const localTimeNum = utcTimeToLocalTime(\n            this.event.startTime + this.event.duration - 0.5,\n            this.timezoneOffset\n          )\n          splitTimes[0].push({\n            hoursOffset: this.event.duration - 0.5,\n            text: timeNumToTimeText(\n              localTimeNum,\n              this.timeType === timeTypes.HOUR12\n            ),\n          })\n          splitTimes[0].push(...getExtraTimes(this.event.duration - 0.5))\n        }\n        splitTimes[1] = []\n      }\n\n      return splitTimes\n    },\n    /** Returns the times that are encompassed by startTime and endTime */\n    times() {\n      return [...this.splitTimes[1], ...this.splitTimes[0]]\n    },\n    timeslotDuration() {\n      return this.event.timeIncrement ?? timeslotDurations.FIFTEEN_MINUTES\n    },\n    timeslotHeight() {\n      if (this.timeslotDuration === timeslotDurations.FIFTEEN_MINUTES) {\n        return Math.floor(this.HOUR_HEIGHT / 4)\n      } else if (this.timeslotDuration === timeslotDurations.THIRTY_MINUTES) {\n        return Math.floor(this.HOUR_HEIGHT / 2)\n      } else if (this.timeslotDuration === timeslotDurations.ONE_HOUR) {\n        return this.HOUR_HEIGHT\n      }\n      return Math.floor(this.HOUR_HEIGHT / 4)\n    },\n    timezoneOffset() {\n      if (!(\"offset\" in this.curTimezone)) {\n        return new Date().getTimezoneOffset()\n      }\n\n      if (this.event.type === eventTypes.DOW) {\n        return this.curTimezone.offset * -1\n      }\n\n      // Can't just get the offset directly from curTimezone because it doesn't account for dates in the future\n      // when daylight savings might be in or out of effect, so instead, we get the timezone for the first date\n      // of the event\n      return (\n        dayjs(this.event.dates[0]).tz(this.curTimezone.value).utcOffset() * -1 // Multiply by -1 because offset is flipped\n      )\n    },\n    userHasResponded() {\n      return this.authUser && this.authUser._id in this.parsedResponses\n    },\n    showLeftZigZag() {\n      return this.calendarScrollLeft > 0\n    },\n    showRightZigZag() {\n      return Math.ceil(this.calendarScrollLeft) < this.calendarMaxScroll\n    },\n    maxDaysPerPage() {\n      return this.isPhone ? this.mobileNumDays : 7\n    },\n    hasNextPage() {\n      if (this.event.daysOnly) {\n        const lastDay = new Date(this.event.dates[this.event.dates.length - 1])\n        const curDate = new Date(this.event.dates[0])\n        const monthIndex = curDate.getUTCMonth() + this.page\n        const year = curDate.getUTCFullYear()\n\n        const lastDayOfCurMonth = new Date(Date.UTC(year, monthIndex + 1, 0))\n\n        return lastDayOfCurMonth.getTime() < lastDay.getTime()\n      }\n\n      return (\n        this.allDays.length - (this.page + 1) * this.maxDaysPerPage > 0 ||\n        this.event.type === eventTypes.GROUP\n      )\n    },\n    hasPrevPage() {\n      return this.page > 0 || this.event.type === eventTypes.GROUP\n    },\n    /** Returns whether the event has more than one page */\n    hasPages() {\n      return this.hasNextPage || this.hasPrevPage\n    },\n\n    showStickyRespondents() {\n      return (\n        this.isPhone &&\n        !this.scrolledToRespondents &&\n        (this.curTimeslot.row !== -1 ||\n          this.curRespondent.length > 0 ||\n          this.curRespondents.length > 0)\n      )\n    },\n\n    // Hint stuff\n    hintText() {\n      if (this.isPhone) {\n        switch (this.state) {\n          case this.isGroup && this.states.EDIT_AVAILABILITY:\n            return \"Toggle which calendars are used. Tap and drag to edit your availability.\"\n          case this.states.EDIT_AVAILABILITY:\n            const daysOrTimes = this.event.daysOnly ? \"days\" : \"times\"\n            if (this.availabilityType === availabilityTypes.IF_NEEDED) {\n              return `Tap and drag to add your \"if needed\" ${daysOrTimes} in yellow.`\n            }\n            return `Tap and drag to add your \"available\" ${daysOrTimes} in green.`\n          case this.states.SCHEDULE_EVENT:\n            return \"Tap and drag on the calendar to schedule a Google Calendar event during those times.\"\n          default:\n            return \"\"\n        }\n      }\n\n      switch (this.state) {\n        case this.isGroup && this.states.EDIT_AVAILABILITY:\n          return \"Toggle which calendars are used. Click and drag to edit your availability.\"\n        case this.states.EDIT_AVAILABILITY:\n          const daysOrTimes = this.event.daysOnly ? \"days\" : \"times\"\n          if (this.availabilityType === availabilityTypes.IF_NEEDED) {\n            return `Click and drag to add your \"if needed\" ${daysOrTimes} in yellow.`\n          }\n          return `Click and drag to add your \"available\" ${daysOrTimes} in green.`\n        case this.states.SCHEDULE_EVENT:\n          return \"Click and drag on the calendar to schedule a Google Calendar event during those times.\"\n        default:\n          return \"\"\n      }\n    },\n    hintClosed() {\n      return !this.hintState || localStorage[this.hintStateLocalStorageKey]\n    },\n    hintStateLocalStorageKey() {\n      return `closedHintText${this.state}` + (\"&isGroup\" ? this.isGroup : \"\")\n    },\n    hintTextShown() {\n      return this.showHintText && this.hintText != \"\" && !this.hintClosed\n    },\n\n    timeslotClassStyle() {\n      const classStyles = []\n      for (let d = 0; d < this.days.length; ++d) {\n        const day = this.days[d]\n        for (let t = 0; t < this.splitTimes[0].length; ++t) {\n          const time = this.splitTimes[0][t]\n          classStyles.push(this.getTimeTimeslotClassStyle(day, time, d, t))\n        }\n        for (let t = 0; t < this.splitTimes[1].length; ++t) {\n          const time = this.splitTimes[1][t]\n          classStyles.push(\n            this.getTimeTimeslotClassStyle(\n              day,\n              time,\n              d,\n              t + this.splitTimes[0].length\n            )\n          )\n        }\n      }\n      return classStyles\n    },\n    dayTimeslotClassStyle() {\n      const classStyles = []\n      for (let i = 0; i < this.monthDays.length; ++i) {\n        classStyles.push(\n          this.getDayTimeslotClassStyle(this.monthDays[i].dateObject, i)\n        )\n      }\n      return classStyles\n    },\n    timeslotVon() {\n      const vons = []\n      for (let d = 0; d < this.days.length; ++d) {\n        for (let t = 0; t < this.times.length; ++t) {\n          vons.push(this.getTimeslotVon(t, d))\n        }\n      }\n      return vons\n    },\n    dayTimeslotVon() {\n      const vons = []\n      for (let i = 0; i < this.monthDays.length; ++i) {\n        const row = Math.floor(i / 7)\n        const col = i % 7\n        vons.push(this.getTimeslotVon(row, col))\n      }\n      return vons\n    },\n\n    /** Whether to show spinner on top of availability grid */\n    showLoader() {\n      return (\n        // Loading calendar events\n        ((this.isGroup || this.alwaysShowCalendarEvents || this.editing) &&\n          this.loadingCalendarEvents) ||\n        // Loading responses\n        this.loadingResponses.loading\n      )\n    },\n\n    /** Localstorage key containing the guest's name */\n    guestNameKey() {\n      return `${this.event._id}.guestName`\n    },\n    /** The guest name stored in localstorage */\n    guestName() {\n      return localStorage[this.guestNameKey]\n    },\n    /** Whether a guest has added their availability (saved in localstorage) */\n    guestAddedAvailability() {\n      return (\n        this.guestName?.length > 0 && this.guestName in this.parsedResponses\n      )\n    },\n\n    /** Returns an array of time blocks representing the current user's availability\n     * (used for displaying current user's availability on top of everybody else's availability)\n     */\n    overlaidAvailability() {\n      const overlaidAvailability = []\n      this.days.forEach((day, d) => {\n        overlaidAvailability.push([])\n        let curBlockIndex = 0\n        const addOverlaidAvailabilityBlocks = (time, t) => {\n          const date = this.getDateFromRowCol(t, d)\n          if (!date) return\n\n          const dragAdd =\n            this.dragging &&\n            this.inDragRange(t, d) &&\n            this.dragType === this.DRAG_TYPES.ADD\n          const dragRemove =\n            this.dragging &&\n            this.inDragRange(t, d) &&\n            this.dragType === this.DRAG_TYPES.REMOVE\n\n          // Check if timeslot is available or if needed or in the drag region\n          if (\n            dragAdd ||\n            (!dragRemove &&\n              (this.availability.has(date.getTime()) ||\n                this.ifNeeded.has(date.getTime())))\n          ) {\n            // Determine whether to render as available or if needed block\n            let type = availabilityTypes.AVAILABLE\n            if (dragAdd) {\n              type = this.availabilityType\n            } else {\n              type = this.availability.has(date.getTime())\n                ? availabilityTypes.AVAILABLE\n                : availabilityTypes.IF_NEEDED\n            }\n\n            if (curBlockIndex in overlaidAvailability[d]) {\n              if (overlaidAvailability[d][curBlockIndex].type === type) {\n                // Increase block length if matching type and curBlockIndex exists\n                overlaidAvailability[d][curBlockIndex].hoursLength += 0.25\n              } else {\n                // Add a new block because type is different\n                overlaidAvailability[d].push({\n                  hoursOffset: time.hoursOffset,\n                  hoursLength: 0.25,\n                  type,\n                })\n                curBlockIndex++\n              }\n            } else {\n              // Add a new block because block doesn't exist for current index\n              overlaidAvailability[d].push({\n                hoursOffset: time.hoursOffset,\n                hoursLength: 0.25,\n                type,\n              })\n            }\n          } else if (curBlockIndex in overlaidAvailability[d]) {\n            // Only increment cur block index if block already exists at the current index\n            curBlockIndex++\n          }\n        }\n        for (let t = 0; t < this.splitTimes[0].length; ++t) {\n          addOverlaidAvailabilityBlocks(this.splitTimes[0][t], t)\n        }\n        if (curBlockIndex in overlaidAvailability[d]) {\n          curBlockIndex++\n        }\n        for (let t = 0; t < this.splitTimes[1].length; ++t) {\n          addOverlaidAvailabilityBlocks(\n            this.splitTimes[1][t],\n            t + this.splitTimes[0].length\n          )\n        }\n      })\n      return overlaidAvailability\n    },\n\n    // Options\n    showOverlayAvailabilityToggle() {\n      return this.respondents.length > 0 && this.overlayAvailabilitiesEnabled\n    },\n    showCalendarOptions() {\n      return (\n        !this.addingAvailabilityAsGuest &&\n        this.calendarPermissionGranted &&\n        (this.isGroup || (!this.isGroup && !this.userHasResponded))\n      )\n    },\n\n    /** Returns an array of the x-offsets of the columns, taking into account the split gaps from non-consecutive days */\n    columnOffsets() {\n      const offsets = []\n      let accumulatedOffset = 0\n      for (let i = 0; i < this.days.length; ++i) {\n        offsets.push(accumulatedOffset)\n        if (!this.days[i].isConsecutive) {\n          accumulatedOffset += this.SPLIT_GAP_WIDTH\n        }\n        accumulatedOffset += this.timeslot.width\n      }\n      return offsets\n    },\n  },\n  methods: {\n    ...mapMutations([\"setAuthUser\"]),\n    ...mapActions([\"showInfo\", \"showError\", \"showUpgradeDialog\"]),\n\n    // -----------------------------------\n    //#region Date\n    // -----------------------------------\n\n    /** Returns a date object from the dayindex and hoursoffset given */\n    getDateFromDayHoursOffset(dayIndex, hoursOffset) {\n      return getDateHoursOffset(this.days[dayIndex].dateObject, hoursOffset)\n    },\n    /** Returns a date object from the row and column given on the current page */\n    getDateFromRowCol(row, col) {\n      if (this.event.daysOnly) {\n        const dateObject = this.monthDays[row * 7 + col]?.dateObject\n        if (!dateObject) return null\n        return new Date(dateObject)\n      } else {\n        return this.getDateFromDayTimeIndex(\n          this.maxDaysPerPage * this.page + col,\n          row\n        )\n      }\n    },\n    isColConsecutive(col) {\n      return Boolean(this.days[col]?.isConsecutive)\n    },\n    /** Returns a date object from the day index and time index given */\n    getDateFromDayTimeIndex(dayIndex, timeIndex) {\n      const hasSecondSplit = this.splitTimes[1].length > 0\n      const isFirstSplit = timeIndex < this.splitTimes[0].length\n      const time = isFirstSplit\n        ? this.splitTimes[0][timeIndex]\n        : this.splitTimes[1][timeIndex - this.splitTimes[0].length]\n      let adjustedDayIndex = dayIndex\n      if (hasSecondSplit) {\n        if (isFirstSplit) {\n          adjustedDayIndex = dayIndex - 1\n        } else if (dayIndex === this.allDays.length - 1) {\n          return null\n        }\n      }\n      const day = this.allDays[adjustedDayIndex]\n      if (!day || !time) return null\n      if (day.excludeTimes) {\n        return null\n      }\n\n      const date = getDateHoursOffset(day.dateObject, time.hoursOffset)\n      if (this.isSpecificTimes) {\n        // TODO: see if we need to do anything for 0.5 timezones\n        if (\n          this.state !== this.states.SET_SPECIFIC_TIMES &&\n          this.event.times?.length > 0\n        ) {\n          if (!this.specificTimesSet.has(date.getTime())) {\n            return null\n          }\n        }\n      } else {\n        // Return null for times outside of the correct range\n        if (time.hoursOffset < 0 || time.hoursOffset >= this.event.duration) {\n          return null\n        }\n      }\n      return date\n    },\n    //#endregion\n\n    // -----------------------------------\n    //#region Respondent\n    // -----------------------------------\n    mouseOverRespondent(e, id) {\n      if (this.curRespondents.length === 0) {\n        if (this.state === this.defaultState) {\n          this.state = this.states.SINGLE_AVAILABILITY\n        }\n\n        this.curRespondent = id\n      }\n    },\n    mouseLeaveRespondent(e) {\n      if (this.curRespondents.length === 0) {\n        if (this.state === this.states.SINGLE_AVAILABILITY) {\n          this.state = this.defaultState\n        }\n\n        this.curRespondent = \"\"\n      }\n    },\n    clickRespondent(e, id) {\n      this.state = this.states.SUBSET_AVAILABILITY\n      this.curRespondent = \"\"\n\n      if (this.curRespondentsSet.has(id)) {\n        // Remove id\n        this.curRespondents = this.curRespondents.filter((r) => r != id)\n\n        // Go back to default state if all users deselected\n        if (this.curRespondents.length === 0) {\n          this.state = this.defaultState\n        }\n      } else {\n        // Add id\n        this.curRespondents.push(id)\n      }\n\n      e.stopPropagation()\n    },\n    deselectRespondents(e) {\n      // Don't deselect respondents if toggled best times\n      // or if this was fired by clicking on a timeslot\n      if (\n        e?.target?.previousElementSibling?.id === \"show-best-times-toggle\" ||\n        e?.target?.firstChild?.firstChild?.id === \"show-best-times-toggle\" ||\n        e?.target?.classList?.contains(\"timeslot\") //&& this.isPhone)\n      )\n        return\n\n      if (this.state === this.states.SUBSET_AVAILABILITY) {\n        this.state = this.defaultState\n      }\n\n      this.curRespondents = []\n\n      // Stop persisting timeslot\n      this.timeslotSelected = false\n      this.resetCurTimeslot()\n    },\n\n    isGuest(user) {\n      return user._id == user.firstName\n    },\n    //#endregion\n\n    // -----------------------------------\n    //#region Aggregate user availability\n    // -----------------------------------\n\n    /** Fetches responses from server */\n    fetchResponses() {\n      if (this.calendarOnly) {\n        this.fetchedResponses = this.event.responses\n        return\n      }\n\n      let timeMin, timeMax\n      if (this.event.type === eventTypes.GROUP) {\n        if (this.event.dates.length > 0) {\n          // Fetch the date range for the current week\n          timeMin = new Date(this.event.dates[0])\n          timeMax = new Date(this.event.dates[this.event.dates.length - 1])\n          timeMax.setDate(timeMax.getDate() + 1)\n\n          // Convert dow dates to discrete dates\n          timeMin = dateToDowDate(\n            this.event.dates,\n            timeMin,\n            this.weekOffset,\n            true\n          )\n          timeMax = dateToDowDate(\n            this.event.dates,\n            timeMax,\n            this.weekOffset,\n            true\n          )\n        }\n      } else {\n        if (this.allDays.length > 0) {\n          // Fetch the entire time range of availabilities\n          timeMin = new Date(this.allDays[0].dateObject)\n          timeMax = new Date(this.allDays[this.allDays.length - 1].dateObject)\n          timeMax.setDate(timeMax.getDate() + 1)\n        }\n      }\n\n      if (!timeMin || !timeMax) return\n\n      // Fetch responses between timeMin and timeMax\n      const url = `/events/${\n        this.event._id\n      }/responses?timeMin=${timeMin.toISOString()}&timeMax=${timeMax.toISOString()}`\n      get(url)\n        .then((responses) => {\n          this.fetchedResponses = responses\n          this.getResponsesFormatted()\n        })\n        .catch((err) => {\n          this.showError(\n            \"There was an error fetching availability! Please refresh the page.\"\n          )\n        })\n    },\n    /** Formats the responses in a map where date/time is mapped to the people that are available then */\n    getResponsesFormatted() {\n      const lastFetched = new Date().getTime()\n      this.loadingResponses.loading = true\n      this.loadingResponses.lastFetched = lastFetched\n\n      this.$worker\n        .run(\n          (days, times, parsedResponses, daysOnly, hideIfNeeded) => {\n            // Define functions locally because we can't import functions\n            const splitTimeNum = (timeNum) => {\n              const hours = Math.floor(timeNum)\n              const minutes = Math.floor((timeNum - hours) * 60)\n              return { hours, minutes }\n            }\n            const getDateHoursOffset = (date, hoursOffset) => {\n              const { hours, minutes } = splitTimeNum(hoursOffset)\n              const newDate = new Date(date)\n              newDate.setHours(newDate.getHours() + hours)\n              newDate.setMinutes(newDate.getMinutes() + minutes)\n              return newDate\n            }\n\n            // Create array of all dates in the event\n            const dates = []\n            if (daysOnly) {\n              for (const day of days) {\n                dates.push(day.dateObject)\n              }\n            } else {\n              for (const day of days) {\n                for (const time of times) {\n                  // Iterate through all the times\n                  const date = getDateHoursOffset(\n                    day.dateObject,\n                    time.hoursOffset\n                  )\n                  dates.push(date)\n                }\n              }\n            }\n\n            // Create a map mapping time to the respondents available during that time\n            const formatted = new Map()\n            for (const date of dates) {\n              formatted.set(date.getTime(), new Set())\n\n              // Check every response and see if they are available for the given time\n              for (const response of Object.values(parsedResponses)) {\n                // Check availability array\n                if (\n                  response.availability?.has(date.getTime()) ||\n                  (response.ifNeeded?.has(date.getTime()) && !hideIfNeeded)\n                ) {\n                  formatted.get(date.getTime()).add(response.user._id)\n                  continue\n                }\n              }\n            }\n            return formatted\n          },\n          [\n            this.allDays,\n            this.times,\n            this.parsedResponses,\n            this.event.daysOnly,\n            this.hideIfNeeded,\n          ]\n        )\n        .then((formatted) => {\n          // Only set responses formatted for the latest request\n          if (lastFetched >= this.loadingResponses.lastFetched) {\n            this.responsesFormatted = formatted\n          }\n        })\n        .finally(() => {\n          if (this.loadingResponses.lastFetched === lastFetched) {\n            this.loadingResponses.loading = false\n          }\n        })\n    },\n    /** Returns a set of respondents for the given date/time */\n    getRespondentsForHoursOffset(date, hoursOffset) {\n      const d = getDateHoursOffset(date, hoursOffset)\n      return this.responsesFormatted.get(d.getTime()) ?? new Set()\n    },\n    showAvailability(row, col) {\n      if (this.state === this.states.EDIT_AVAILABILITY && this.isPhone) {\n        // Don't show currently selected timeslot when on phone and editing\n        return\n      }\n\n      // Update current timeslot (the timeslot that has a dotted border around it)\n      this.curTimeslot = { row, col }\n\n      if (this.state === this.states.EDIT_AVAILABILITY || this.curRespondent) {\n        // Don't show availability when editing or when respondent is selected\n        return\n      }\n\n      const date = this.getDateFromRowCol(row, col)\n      if (!date) return\n\n      // Update current timeslot availability to show who is available for the given timeslot\n      const available = this.responsesFormatted.get(date.getTime()) ?? new Set()\n      for (const respondent of this.respondents) {\n        if (available.has(respondent._id)) {\n          this.curTimeslotAvailability[respondent._id] = true\n        } else {\n          this.curTimeslotAvailability[respondent._id] = false\n        }\n      }\n    },\n    //#endregion\n\n    // -----------------------------------\n    //#region Current user availability\n    // -----------------------------------\n    async refreshAuthUser() {\n      this.hasRefreshedAuthUser = true\n      await get(\"/user/profile\").then((authUser) => {\n        this.setAuthUser(authUser)\n      })\n    },\n    /** resets cur user availability to the response stored on the server */\n    resetCurUserAvailability() {\n      if (this.event.type === eventTypes.GROUP) {\n        this.initSharedCalendarAccounts()\n        this.manualAvailability = {}\n      }\n\n      this.availability = new Set()\n      this.ifNeeded = new Set()\n      if (this.userHasResponded) {\n        this.populateUserAvailability(this.authUser._id)\n      }\n    },\n    /** Populates the availability set for the auth user from the responses object stored on the server */\n    populateUserAvailability(id) {\n      this.availability =\n        new Set(this.parsedResponses[id]?.availability) ?? new Set()\n      this.ifNeeded = new Set(this.parsedResponses[id]?.ifNeeded) ?? new Set()\n      this.$nextTick(() => (this.unsavedChanges = false))\n    },\n    /** Returns true if the calendar event is in the first split */\n    getIsTimeBlockInFirstSplit(timeBlock) {\n      return (\n        timeBlock.hoursOffset >= this.splitTimes[0][0].hoursOffset &&\n        timeBlock.hoursOffset <=\n          this.splitTimes[0][this.splitTimes[0].length - 1].hoursOffset\n      )\n    },\n    /** Returns the style for the calendar event block */\n    getTimeBlockStyle(timeBlock) {\n      const style = {}\n      const hasSecondSplit = this.splitTimes[1].length > 0\n      if (!hasSecondSplit || this.getIsTimeBlockInFirstSplit(timeBlock)) {\n        style.top = `calc(${\n          timeBlock.hoursOffset - this.splitTimes[0][0].hoursOffset\n        } * ${this.HOUR_HEIGHT}px)`\n        style.height = `calc(${timeBlock.hoursLength} * ${this.HOUR_HEIGHT}px)`\n      } else {\n        style.top = `calc(${this.splitTimes[0].length} * ${\n          this.timeslotHeight\n        }px + ${this.SPLIT_GAP_HEIGHT}px + ${\n          timeBlock.hoursOffset - this.splitTimes[1][0].hoursOffset\n        } * ${this.HOUR_HEIGHT}px)`\n        style.height = `calc(${timeBlock.hoursLength} * ${this.HOUR_HEIGHT}px)`\n      }\n      return style\n    },\n    /** Returns a set containing the available times based on the given calendar events object */\n    getAvailabilityFromCalendarEvents({\n      calendarEventsByDay = [],\n      includeTouchedAvailability = false, // Whether to include manual availability for touched days\n      fetchedManualAvailability = {}, // Object mapping unix timestamp to array of manual availability (fetched from server)\n      curManualAvailability = {}, // Manual availability with edits (takes precedence over fetchedManualAvailability)\n      calendarOptions = calendarOptionsDefaults, // User id of the user we are getting availability for\n    }) {\n      const availability = new Set()\n\n      for (let i = 0; i < this.allDays.length; ++i) {\n        const day = this.allDays[i]\n        const date = day.dateObject\n\n        if (includeTouchedAvailability) {\n          const endDate = getDateHoursOffset(\n            date,\n            this.times.length * (this.timeslotDuration / 60)\n          )\n\n          // Check if manual availability has been added for the current date\n          let manualAvailabilityAdded = false\n\n          for (const time in curManualAvailability) {\n            if (date.getTime() <= time && time <= endDate.getTime()) {\n              curManualAvailability[time].forEach((a) => {\n                availability.add(new Date(a).getTime())\n              })\n              delete curManualAvailability[time]\n              manualAvailabilityAdded = true\n              break\n            }\n          }\n\n          if (manualAvailabilityAdded) continue\n\n          for (const time in fetchedManualAvailability) {\n            if (date.getTime() <= time && time <= endDate.getTime()) {\n              fetchedManualAvailability[time].forEach((a) => {\n                availability.add(new Date(a).getTime())\n              })\n              delete fetchedManualAvailability[time]\n              manualAvailabilityAdded = true\n              break\n            }\n          }\n\n          if (manualAvailabilityAdded) continue\n        }\n\n        // Calculate buffer time\n        const bufferTimeInMS = calendarOptions.bufferTime.enabled\n          ? calendarOptions.bufferTime.time * 1000 * 60\n          : 0\n\n        // Calculate working hours\n        const startTimeString = timeNumToTimeString(\n          calendarOptions.workingHours.startTime\n        )\n        const isoDateString = getISODateString(getDateWithTimezone(date), true)\n        const workingHoursStartDate = dayjs\n          .tz(`${isoDateString} ${startTimeString}`, this.curTimezone.value)\n          .toDate()\n        let duration =\n          calendarOptions.workingHours.endTime -\n          calendarOptions.workingHours.startTime\n        if (duration <= 0) duration += 24\n        const workingHoursEndDate = getDateHoursOffset(\n          workingHoursStartDate,\n          duration\n        )\n\n        for (let j = 0; j < this.times.length; ++j) {\n          const startDate = this.getDateFromDayTimeIndex(i, j)\n          if (!startDate) continue\n          const endDate = getDateHoursOffset(\n            startDate,\n            this.timeslotDuration / 60\n          )\n\n          // Working hours\n          if (calendarOptions.workingHours.enabled) {\n            if (\n              endDate.getTime() <= workingHoursStartDate.getTime() ||\n              startDate.getTime() >= workingHoursEndDate.getTime()\n            ) {\n              continue\n            }\n          }\n\n          // Check if there exists a calendar event that overlaps [startDate, endDate]\n          const index = calendarEventsByDay[i]?.findIndex((e) => {\n            const startDateBuffered = new Date(\n              e.startDate.getTime() - bufferTimeInMS\n            )\n            const endDateBuffered = new Date(\n              e.endDate.getTime() + bufferTimeInMS\n            )\n\n            const notIntersect =\n              dateCompare(endDate, startDateBuffered) <= 0 ||\n              dateCompare(startDate, endDateBuffered) >= 0\n            return !notIntersect && !e.free\n          })\n          if (index === -1) {\n            availability.add(startDate.getTime())\n          }\n        }\n      }\n      return availability\n    },\n    /** Constructs the availability array using calendarEvents array */\n    setAvailabilityAutomatically() {\n      // This is not a computed property because we should be able to change it manually from what it automatically fills in\n      this.availability = new Set()\n      const tmpAvailability = this.getAvailabilityFromCalendarEvents({\n        calendarEventsByDay: this.calendarEventsByDay,\n        calendarOptions: {\n          bufferTime: this.bufferTime,\n          workingHours: this.workingHours,\n        },\n      })\n\n      const pageStartDate = getDateDayOffset(\n        new Date(this.event.dates[0]),\n        this.page * this.maxDaysPerPage\n      )\n      const pageEndDate = getDateDayOffset(pageStartDate, this.maxDaysPerPage)\n      this.animateAvailability(tmpAvailability, pageStartDate, pageEndDate)\n    },\n    /** Animate the filling out of availability using setTimeout, between startDate and endDate */\n    animateAvailability(availability, startDate, endDate) {\n      this.availabilityAnimEnabled = true\n      this.availabilityAnimTimeouts = []\n\n      let msPerGroup = 25\n      let blocksPerGroup = 2\n      if (\n        (availability.size / blocksPerGroup) * msPerGroup >\n        this.maxAnimTime\n      ) {\n        blocksPerGroup = (availability.size * msPerGroup) / this.maxAnimTime\n      }\n      let availabilityArray = [...availability]\n      availabilityArray = availabilityArray.filter((a) =>\n        isDateBetween(a, startDate, endDate)\n      )\n\n      for (let i = 0; i < availabilityArray.length / blocksPerGroup + 1; ++i) {\n        const timeout = setTimeout(() => {\n          for (const a of availabilityArray.slice(\n            i * blocksPerGroup,\n            i * blocksPerGroup + blocksPerGroup\n          )) {\n            this.availability.add(a)\n          }\n          this.availability = new Set(this.availability)\n          if (i >= availabilityArray.length / blocksPerGroup) {\n            // Make sure the entire availability has been added (will not be guaranteed when only animating a portion of availability)\n            this.availability = new Set(availability)\n            this.availabilityAnimTimeouts.push(\n              setTimeout(() => {\n                this.availabilityAnimEnabled = false\n\n                if (this.showSnackbar) {\n                  this.showInfo(\"Your availability has been autofilled!\")\n                }\n                this.unsavedChanges = false\n              }, 500)\n            )\n          }\n        }, i * msPerGroup)\n\n        this.availabilityAnimTimeouts.push(timeout)\n      }\n    },\n    stopAvailabilityAnim() {\n      for (const timeout of this.availabilityAnimTimeouts) {\n        clearTimeout(timeout)\n      }\n      this.availabilityAnimEnabled = false\n    },\n    async submitAvailability(guestPayload = { name: \"\", email: \"\" }) {\n      let payload = {}\n\n      let type = \"\"\n      // If this is a group submit enabled calendars, otherwise submit availability\n      if (this.isGroup) {\n        type = \"group availability and calendars\"\n        payload = generateEnabledCalendarsPayload(this.sharedCalendarAccounts)\n        payload.manualAvailability = {}\n        for (const day of Object.keys(this.manualAvailability)) {\n          payload.manualAvailability[day] = [\n            ...this.manualAvailability[day],\n          ].map((a) => new Date(a))\n        }\n        payload.calendarOptions = {\n          bufferTime: this.bufferTime,\n          workingHours: this.workingHours,\n        }\n      } else {\n        type = \"availability\"\n        payload.availability = this.availabilityArray\n        payload.ifNeeded = this.ifNeededArray\n        if (this.authUser && !this.addingAvailabilityAsGuest) {\n          payload.guest = false\n        } else {\n          payload.guest = true\n          payload.name = guestPayload.name\n          payload.email = guestPayload.email\n          localStorage[this.guestNameKey] = guestPayload.name\n        }\n      }\n\n      await post(`/events/${this.event._id}/response`, payload)\n\n      // Update analytics\n      const addedIfNeededTimes = this.ifNeededArray.length > 0\n      if (this.authUser) {\n        if (this.authUser._id in this.parsedResponses) {\n          this.$posthog?.capture(`Edited ${type}`, {\n            eventId: this.event._id,\n            addedIfNeededTimes,\n          })\n        } else {\n          this.$posthog?.capture(`Added ${type}`, {\n            eventId: this.event._id,\n            addedIfNeededTimes,\n            // bufferTime: this.bufferTime,\n            bufferTime: this.bufferTime.time,\n            bufferTimeActive: this.bufferTime.enabled,\n            workingHoursEnabled: this.workingHours.enabled,\n            workingHoursStartTime: this.workingHours.startTime,\n            workingHoursEndTime: this.workingHours.endTime,\n          })\n        }\n      } else {\n        if (guestPayload.name in this.parsedResponses) {\n          this.$posthog?.capture(`Edited ${type} as guest`, {\n            eventId: this.event._id,\n            addedIfNeededTimes,\n          })\n        } else {\n          this.$posthog?.capture(`Added ${type} as guest`, {\n            eventId: this.event._id,\n            addedIfNeededTimes,\n          })\n        }\n      }\n\n      this.refreshEvent()\n      this.unsavedChanges = false\n    },\n    async submitNewSignUpBlocks() {\n      if (\n        this.signUpBlocksToAddByDay.flat().length +\n          this.signUpBlocksByDay.flat().length ===\n        0\n      ) {\n        this.showError(\"Please add at least one sign-up block!\")\n        return false\n      }\n\n      for (let i = 0; i < this.signUpBlocksToAddByDay.length; ++i) {\n        this.signUpBlocksByDay[i] = this.signUpBlocksByDay[i].concat(\n          this.signUpBlocksToAddByDay[i]\n        )\n        this.signUpBlocksToAddByDay[i] = []\n      }\n\n      const payload = {\n        name: this.event.name,\n        duration: this.event.duration,\n        dates: this.event.dates,\n        type: this.event.type,\n        signUpBlocks: this.signUpBlocksByDay.flat().map((block) => {\n          return {\n            _id: block._id,\n            name: block.name,\n            capacity: block.capacity,\n            startDate: block.startDate,\n            endDate: block.endDate,\n          }\n        }),\n      }\n\n      put(`/events/${this.event._id}`, payload)\n        .then(() => {\n          // window.location.reload()\n        })\n        .catch((err) => {\n          console.error(err)\n          this.showError(\n            \"There was a problem editing this event! Please try again later.\"\n          )\n        })\n\n      return true\n    },\n\n    async deleteAvailability(name = \"\") {\n      const payload = {}\n      if (this.authUser && !this.addingAvailabilityAsGuest) {\n        payload.guest = false\n        payload.userId = this.authUser._id\n\n        this.$posthog?.capture(\"Deleted availability\", {\n          eventId: this.event._id,\n        })\n      } else {\n        payload.guest = true\n        payload.name = name\n\n        this.$posthog?.capture(\"Deleted availability as guest\", {\n          eventId: this.event._id,\n          name,\n        })\n      }\n      await _delete(`/events/${this.event._id}/response`, payload)\n      this.availability = new Set()\n      if (this.isGroup) this.$router.replace({ name: \"home\" })\n      else this.refreshEvent()\n    },\n    //#endregion\n\n    // -----------------------------------\n    //#region Timeslot\n    // -----------------------------------\n    setTimeslotSize() {\n      /* Gets the dimensions of each timeslot and assigns it to the timeslot variable */\n      const timeslotEl = document.querySelector(\".timeslot\")\n      if (timeslotEl) {\n        ;({ width: this.timeslot.width, height: this.timeslot.height } =\n          timeslotEl.getBoundingClientRect())\n      }\n    },\n    /** Returns a class string and style object for the given time timeslot div */\n    getTimeTimeslotClassStyle(day, time, d, t) {\n      const row = t\n      const col = d\n      const date = this.getDateFromRowCol(row, col)\n      const classStyle = this.getTimeslotClassStyle(date, row, col)\n\n      // Add time timeslot specific stuff\n      const isFirstSplit = t < this.splitTimes[0].length\n      const isDisabled = !date\n\n      // Animation\n      if (this.animateTimeslotAlways || this.availabilityAnimEnabled) {\n        classStyle.class += \"animate-bg-color \"\n      }\n\n      // Height\n      classStyle.style.height = `${this.timeslotHeight}px`\n\n      // Border style\n      if (\n        (this.respondents.length > 0 ||\n          this.editing ||\n          this.state === this.states.SET_SPECIFIC_TIMES) &&\n        this.curTimeslot.row === row &&\n        this.curTimeslot.col === col &&\n        !isDisabled\n      ) {\n        // Dashed border for currently selected timeslot\n        classStyle.class +=\n          \"tw-border tw-border-dashed tw-border-black tw-z-10 \"\n      } else {\n        // Normal border\n        if (date) {\n          const localDate = new Date(\n            date.getTime() - this.timezoneOffset * 60 * 1000\n          )\n          const fractionalTime = localDate.getMinutes()\n          if (fractionalTime === 0) {\n            classStyle.class += \"tw-border-t \"\n          } else if (fractionalTime === 30) {\n            classStyle.class += \"tw-border-t \"\n            classStyle.style.borderTopStyle = \"dashed\"\n          }\n        }\n\n        classStyle.class += \"tw-border-r \"\n        if (col === 0 || !this.isColConsecutive(col))\n          classStyle.class += \"tw-border-l tw-border-l-gray \"\n        if (col === this.days.length - 1 || !this.isColConsecutive(col + 1))\n          classStyle.class += \"tw-border-r-gray \"\n        if (isFirstSplit && row === 0)\n          classStyle.class += \"tw-border-t tw-border-t-gray \"\n        if (!isFirstSplit && row === this.splitTimes[0].length)\n          classStyle.class += \"tw-border-t tw-border-t-gray \"\n        if (isFirstSplit && row === this.splitTimes[0].length - 1)\n          classStyle.class += \"tw-border-b tw-border-b-gray \"\n        if (\n          !isFirstSplit &&\n          row === this.splitTimes[0].length + this.splitTimes[1].length - 1\n        )\n          classStyle.class += \"tw-border-b tw-border-b-gray \"\n\n        const totalRespondents =\n          this.state === this.states.SUBSET_AVAILABILITY\n            ? this.curRespondents.length\n            : this.respondents.length\n        if (\n          this.state === this.states.EDIT_AVAILABILITY ||\n          this.state === this.states.SINGLE_AVAILABILITY ||\n          totalRespondents === 1\n        ) {\n          classStyle.class += \"tw-border-[#999999] \"\n        } else {\n          classStyle.class += \"tw-border-[#DDDDDD99] \"\n        }\n      }\n\n      // Edit fill color and border color if day is not interactable\n      if (isDisabled) {\n        classStyle.class +=\n          \"tw-bg-light-gray-stroke tw-border-light-gray-stroke \"\n      }\n\n      // Change default red:\n      if (classStyle.style.backgroundColor === \"#E523230D\") {\n        classStyle.style.backgroundColor = \"#E5232333\"\n      }\n\n      return classStyle\n    },\n    /** Returns the shared class string and style object for the given timeslot (either time timeslot or day timeslot) */\n    getTimeslotClassStyle(date, row, col) {\n      let c = \"\"\n      const s = {}\n      if (!date) return { class: c, style: s }\n\n      const timeslotRespondents =\n        this.responsesFormatted.get(date.getTime()) ?? new Set()\n\n      // Fill style\n\n      if (this.isSignUp) {\n        c += \"tw-bg-light-gray \"\n        return { class: c, style: s }\n      }\n\n      if (\n        (!this.overlayAvailability &&\n          this.state === this.states.EDIT_AVAILABILITY) ||\n        this.state === this.states.SET_SPECIFIC_TIMES\n      ) {\n        // Set default background color to red (unavailable)\n        s.backgroundColor = \"#E523230D\"\n\n        // Show only current user availability\n        const inDragRange = this.inDragRange(row, col)\n        if (inDragRange) {\n          // Set style if drag range goes over the current timeslot\n          if (this.dragType === this.DRAG_TYPES.ADD) {\n            if (this.state === this.states.SET_SPECIFIC_TIMES) {\n              c += \"tw-bg-white \"\n            } else {\n              if (this.availabilityType === availabilityTypes.AVAILABLE) {\n                s.backgroundColor = \"#00994C77\"\n              } else if (\n                this.availabilityType === availabilityTypes.IF_NEEDED\n              ) {\n                c += \"tw-bg-yellow \"\n              }\n            }\n          } else if (this.dragType === this.DRAG_TYPES.REMOVE) {\n            if (this.state === this.states.SET_SPECIFIC_TIMES) {\n              c += \"tw-bg-gray \"\n            }\n          }\n        } else {\n          // Otherwise just show the current availability\n          // Show current availability from availability set\n          if (this.state === this.states.SET_SPECIFIC_TIMES) {\n            if (this.tempTimes.has(date.getTime())) {\n              c += \"tw-bg-white \"\n            } else {\n              c += \"tw-bg-gray \"\n            }\n          } else {\n            if (this.availability.has(date.getTime())) {\n              s.backgroundColor = \"#00994C77\"\n            } else if (this.ifNeeded.has(date.getTime())) {\n              c += \"tw-bg-yellow \"\n            }\n          }\n        }\n      }\n\n      if (this.state === this.states.SINGLE_AVAILABILITY) {\n        // Show only the currently selected respondent's availability\n        const respondent = this.curRespondent\n        if (timeslotRespondents.has(respondent)) {\n          if (this.parsedResponses[respondent]?.ifNeeded?.has(date.getTime())) {\n            c += \"tw-bg-yellow \"\n          } else {\n            s.backgroundColor = \"#00994C77\"\n          }\n        } else {\n          s.backgroundColor = \"#E523230D\"\n        }\n        return { class: c, style: s }\n      }\n\n      if (\n        this.overlayAvailability ||\n        this.state === this.states.BEST_TIMES ||\n        this.state === this.states.HEATMAP ||\n        this.state === this.states.SCHEDULE_EVENT ||\n        this.state === this.states.SUBSET_AVAILABILITY\n      ) {\n        let numRespondents\n        let max\n\n        if (\n          this.state === this.states.BEST_TIMES ||\n          this.state === this.states.HEATMAP ||\n          this.state === this.states.SCHEDULE_EVENT\n        ) {\n          numRespondents = timeslotRespondents.size\n          max = this.max\n        } else if (this.state === this.states.SUBSET_AVAILABILITY) {\n          numRespondents = [...timeslotRespondents].filter((r) =>\n            this.curRespondentsSet.has(r)\n          ).length\n\n          max = this.curRespondentsMax\n        } else if (this.overlayAvailability) {\n          if (\n            (this.userHasResponded || this.curGuestId?.length > 0) &&\n            timeslotRespondents.has(this.authUser?._id ?? this.curGuestId)\n          ) {\n            // Subtract 1 because we do not want to include current user's availability\n            numRespondents = timeslotRespondents.size - 1\n            max = this.max\n          } else {\n            numRespondents = timeslotRespondents.size\n            max = this.max\n          }\n        }\n\n        const totalRespondents =\n          this.state === this.states.SUBSET_AVAILABILITY\n            ? this.curRespondents.length\n            : this.respondents.length\n\n        if (this.defaultState === this.states.BEST_TIMES) {\n          if (max > 0 && numRespondents === max) {\n            // Only set timeslot to green for the times that most people are available\n            if (totalRespondents === 1 || this.overlayAvailability) {\n              // Make single responses less saturated\n              const green = \"#00994C88\"\n              s.backgroundColor = green\n            } else {\n              const green = \"#00994C\"\n              s.backgroundColor = green\n            }\n          }\n        } else if (this.defaultState === this.states.HEATMAP) {\n          if (numRespondents > 0) {\n            if (totalRespondents === 1) {\n              const respondentId =\n                this.state === this.states.SUBSET_AVAILABILITY\n                  ? this.curRespondents[0]\n                  : this.respondents[0]._id\n              if (\n                this.parsedResponses[respondentId]?.ifNeeded?.has(\n                  date.getTime()\n                )\n              ) {\n                c += \"tw-bg-yellow \"\n              } else {\n                const green = \"#00994C88\"\n                s.backgroundColor = green\n              }\n            } else {\n              // Determine color of timeslot based on number of people available\n              const frac = numRespondents / max\n              const green = \"#00994C\"\n              let alpha\n              if (!this.overlayAvailability) {\n                alpha = Math.floor(frac * (255 - 30))\n                  .toString(16)\n                  .toUpperCase()\n                  .substring(0, 2)\n                  .padStart(2, \"0\")\n                if (\n                  frac == 1 &&\n                  ((this.curRespondents.length > 0 &&\n                    max === this.curRespondents.length) ||\n                    (this.curRespondents.length === 0 &&\n                      max === this.respondents.length))\n                ) {\n                  alpha = \"FF\"\n                }\n              } else {\n                alpha = Math.floor(frac * (255 - 85))\n                  .toString(16)\n                  .toUpperCase()\n                  .substring(0, 2)\n                  .padStart(2, \"0\")\n              }\n\n              s.backgroundColor = green + alpha\n            }\n          } else if (totalRespondents === 1) {\n            const red = \"#E523230D\"\n            s.backgroundColor = red\n          }\n        }\n      }\n\n      return { class: c, style: s }\n    },\n    getDayTimeslotClassStyle(date, i) {\n      const row = Math.floor(i / 7)\n      const col = i % 7\n\n      let classStyle\n      // Only compute class style for days that are included\n      if (this.monthDayIncluded.get(date.getTime())) {\n        classStyle = this.getTimeslotClassStyle(date, row, col)\n        if (this.state === this.states.EDIT_AVAILABILITY) {\n          classStyle.class += \"tw-cursor-pointer \"\n        }\n\n        const backgroundColor = classStyle.style.backgroundColor\n        if (\n          backgroundColor &&\n          lightOrDark(removeTransparencyFromHex(backgroundColor)) === \"dark\"\n        ) {\n          classStyle.class += \"tw-text-white \"\n        }\n      } else {\n        classStyle = {\n          class: \"tw-bg-off-white tw-text-gray \",\n          style: {},\n        }\n      }\n\n      // Change default red:\n      if (classStyle.style.backgroundColor === \"#E523230D\") {\n        classStyle.style.backgroundColor = \"#E523233B\"\n      }\n\n      // Change edit green\n      // if (classStyle.style.backgroundColor === \"#00994C88\") {\n      //   classStyle.style.backgroundColor = \"#29BC6880\"\n      // }\n\n      // Border style\n      if (\n        (this.respondents.length > 0 ||\n          this.state === this.states.EDIT_AVAILABILITY) &&\n        this.curTimeslot.row === row &&\n        this.curTimeslot.col === col &&\n        this.monthDayIncluded.get(date.getTime())\n      ) {\n        // Dashed border for currently selected timeslot\n        classStyle.class +=\n          \"tw-outline-2 tw-outline-dashed tw-outline-black tw-z-10 \"\n      } else {\n        // Normal border\n        if (col === 0) classStyle.class += \"tw-border-l tw-border-l-gray \"\n        classStyle.class += \"tw-border-r tw-border-r-gray \"\n        if (col !== 7 - 1) {\n          classStyle.style.borderRightStyle = \"dashed\"\n        }\n\n        if (row === 0) classStyle.class += \"tw-border-t tw-border-t-gray \"\n        classStyle.class += \"tw-border-b tw-border-b-gray \"\n        if (row !== Math.floor(this.monthDays.length / 7) - 1) {\n          classStyle.style.borderBottomStyle = \"dashed\"\n        }\n      }\n\n      return classStyle\n    },\n    getTimeslotVon(row, col) {\n      if (this.interactable) {\n        return {\n          click: () => {\n            if (this.timeslotSelected) {\n              // Get rid of persistent timeslot selection if clicked on the same timeslot that is currently being persisted\n              if (\n                row === this.curTimeslot.row &&\n                col === this.curTimeslot.col\n              ) {\n                this.timeslotSelected = false\n              }\n            } else if (\n              this.state !== this.states.EDIT_AVAILABILITY &&\n              (this.userHasResponded || this.guestAddedAvailability)\n            ) {\n              // Persist timeslot selection if user has already responded\n              this.timeslotSelected = true\n            }\n\n            this.showAvailability(row, col)\n          },\n          mousedown: () => {\n            // Highlight availability button\n            if (\n              this.state === this.defaultState &&\n              ((!this.isPhone &&\n                !(this.userHasResponded || this.guestAddedAvailability)) ||\n                this.respondents.length == 0)\n            )\n              this.highlightAvailabilityBtn()\n          },\n          mouseover: () => {\n            // Only show availability on hover if timeslot is not being persisted\n            if (!this.timeslotSelected) {\n              this.showAvailability(row, col)\n              if (!this.event.daysOnly) {\n                const date = this.getDateFromRowCol(row, col)\n                if (date) {\n                  date.setTime(date.getTime() - this.timezoneOffset * 60 * 1000)\n                  const startDate = dayjs(date).utc()\n                  const endDate = dayjs(date)\n                    .utc()\n                    .add(this.timeslotDuration, \"minutes\")\n                  const timeFormat =\n                    this.timeType === timeTypes.HOUR12 ? \"h:mm A\" : \"HH:mm\"\n                  let dateFormat\n                  if (this.isSpecificDates) {\n                    dateFormat = \"ddd, MMM D, YYYY\"\n                  } else {\n                    dateFormat = \"ddd\"\n                  }\n                  this.tooltipContent = `${startDate.format(\n                    dateFormat\n                  )} ${startDate.format(timeFormat)} to ${endDate.format(\n                    timeFormat\n                  )}`\n                }\n              }\n            }\n          },\n          mouseleave: () => {\n            this.tooltipContent = \"\"\n          },\n        }\n      }\n      return {}\n    },\n    resetCurTimeslot() {\n      // Only reset cur timeslot if it isn't being persisted\n      if (this.timeslotSelected) return\n\n      this.curTimeslotAvailability = {}\n      for (const respondent of this.respondents) {\n        this.curTimeslotAvailability[respondent._id] = true\n      }\n      this.curTimeslot = { row: -1, col: -1 }\n\n      // End drag if mouse left time grid\n      this.endDrag()\n    },\n    //#endregion\n\n    // -----------------------------------\n    //#region Editing\n    // -----------------------------------\n    startEditing() {\n      this.state = this.isSignUp\n        ? this.states.EDIT_SIGN_UP_BLOCKS\n        : this.states.EDIT_AVAILABILITY\n      this.availabilityType = availabilityTypes.AVAILABLE\n      this.availability = new Set()\n      this.ifNeeded = new Set()\n\n      if (this.authUser && !this.addingAvailabilityAsGuest) {\n        this.resetCurUserAvailability()\n      }\n      this.$nextTick(() => (this.unsavedChanges = false))\n      this.pageHasChanged = false\n    },\n    stopEditing() {\n      this.state = this.defaultState\n      this.stopAvailabilityAnim()\n\n      // Reset options\n      this.availabilityType = availabilityTypes.AVAILABLE\n      this.overlayAvailability = false\n    },\n    highlightAvailabilityBtn() {\n      this.$emit(\"highlightAvailabilityBtn\")\n    },\n    editGuestAvailability(id) {\n      if (this.authUser) {\n        this.$emit(\"addAvailabilityAsGuest\")\n      } else {\n        this.startEditing()\n      }\n\n      this.$nextTick(() => {\n        this.populateUserAvailability(id)\n        this.$emit(\"setCurGuestId\", id)\n      })\n    },\n    refreshEvent() {\n      this.$emit(\"refreshEvent\")\n    },\n    //#endregion\n\n    // -----------------------------------\n    //#region Schedule event\n    // -----------------------------------\n    scheduleEvent() {\n      this.state = this.states.SCHEDULE_EVENT\n      this.$posthog?.capture(\"schedule_event_button_clicked\")\n    },\n    cancelScheduleEvent() {\n      this.state = this.defaultState\n    },\n\n    /** Redirect user to Google Calendar to finish the creation of the event */\n    confirmScheduleEvent(googleCalendar = true) {\n      if (!this.curScheduledEvent) return\n      // if (!isPremiumUser(this.authUser)) {\n      //   this.showUpgradeDialog({\n      //     type: upgradeDialogTypes.SCHEDULE_EVENT,\n      //     data: {\n      //       scheduledEvent: this.curScheduledEvent,\n      //     },\n      //   })\n      //   return\n      // }\n\n      this.$posthog?.capture(\"schedule_event_confirmed\")\n      // Get start date, and end date from the area that the user has dragged out\n      const { col, row, numRows } = this.curScheduledEvent\n      let startDate = this.getDateFromRowCol(row, col)\n      let endDate = new Date(startDate)\n      endDate.setMinutes(\n        startDate.getMinutes() + this.timeslotDuration * numRows\n      )\n\n      if (this.isWeekly || this.isGroup) {\n        // Determine offset based on current day of the week.\n        // People expect the event to be scheduled in the future, not the past, which is why this check exists\n        let offset = 0\n        if (this.isGroup) {\n          offset = this.weekOffset\n        } else if (this.isWeekly) {\n          if (new Date().getDay() > startDate.getDay()) {\n            offset = 1\n          }\n        }\n\n        // Transform startDate and endDate to be the current week offset\n        startDate = dateToDowDate(this.event.dates, startDate, offset, true)\n        endDate = dateToDowDate(this.event.dates, endDate, offset, true)\n      }\n\n      // Format email string separated by commas\n      const emails = this.respondents.map((r) => {\n        // Return email if they are not a guest, otherwise return their name\n        if (r.email.length > 0) {\n          return r.email\n        } else {\n          // return `${r.firstName} (no email)`\n          return null\n        }\n      })\n      const emailsString = encodeURIComponent(emails.filter(Boolean).join(\",\"))\n\n      const eventId = this.event.shortId ?? this.event._id\n\n      let url = \"\"\n      if (googleCalendar) {\n        // Format start and end date to be in the format required by gcal (remove -, :, and .000)\n        const start = startDate.toISOString().replace(/([-:]|\\.000)/g, \"\")\n        const end = endDate.toISOString().replace(/([-:]|\\.000)/g, \"\")\n\n        // Construct Google Calendar event creation template url\n        url = `https://calendar.google.com/calendar/render?action=TEMPLATE&text=${encodeURIComponent(\n          this.event.name\n        )}&dates=${start}/${end}&details=${encodeURIComponent(\n          \"\\n\\nThis event was scheduled with schej: https://schej.it/e/\"\n        )}${eventId}&ctz=${this.curTimezone.value}&add=${emailsString}`\n      } else {\n        url = `https://outlook.live.com/calendar/0/deeplink/compose?subject=${encodeURIComponent(\n          this.event.name\n        )}&body=${encodeURIComponent(\n          \"\\n\\nThis event was scheduled with schej: https://schej.it/e/\" +\n            eventId\n        )}&startdt=${startDate.toISOString()}&enddt=${endDate.toISOString()}&location=${encodeURIComponent(\n          this.event.location || \"\"\n        )}&path=/calendar/action/compose&timezone=${this.curTimezone.value}`\n      }\n\n      // Navigate to url and reset state\n      window.open(url, \"_blank\")\n      this.state = this.defaultState\n    },\n    //#endregion\n\n    // -----------------------------------\n    //#region Drag Stuff\n    // -----------------------------------\n    normalizeXY(e) {\n      /* Normalize the touch event to be relative to element */\n      let pageX, pageY\n      if (\"touches\" in e) {\n        // is a touch event\n        ;({ pageX, pageY } = e.touches[0])\n      } else {\n        // is a mouse event\n        ;({ pageX, pageY } = e)\n      }\n      const { left, top } = e.currentTarget.getBoundingClientRect()\n      const x = pageX - left\n      const y = pageY - top - window.scrollY\n      return { x, y }\n    },\n    clampRow(row) {\n      if (this.event.daysOnly) {\n        row = clamp(row, 0, Math.floor(this.monthDays.length / 7) - 1)\n      } else {\n        row = clamp(row, 0, this.times.length - 1)\n      }\n      return row\n    },\n    clampCol(col) {\n      if (this.event.daysOnly) {\n        col = clamp(col, 0, 7 - 1)\n      } else {\n        col = clamp(col, 0, this.days.length - 1)\n      }\n      return col\n    },\n    /** Returns row, col for the timeslot we are currently hovering over given the x and y position */\n    getRowColFromXY(x, y) {\n      const { width, height } = this.timeslot\n      let col = Math.floor(x / width)\n      if (!this.event.daysOnly) {\n        col = this.columnOffsets.length\n        for (let i = 0; i < this.columnOffsets.length; ++i) {\n          if (x < this.columnOffsets[i]) {\n            col = i - 1\n            break\n          }\n        }\n      }\n      let row = Math.floor(y / height)\n\n      // Account for split gap\n      if (!this.event.daysOnly && row > this.splitTimes[0].length) {\n        const adjustedRow = Math.floor((y - this.SPLIT_GAP_HEIGHT) / height)\n        if (adjustedRow >= this.splitTimes[0].length) {\n          // Make sure we don't go to a lesser index\n          row = adjustedRow\n        }\n      }\n\n      row = this.clampRow(row)\n      col = this.clampCol(col)\n      return {\n        row,\n        col,\n      }\n    },\n    endDrag() {\n      if (!this.allowDrag) return\n\n      if (!this.dragStart || !this.dragCur) return\n\n      // Update availability set based on drag region\n      if (\n        this.state === this.states.EDIT_AVAILABILITY ||\n        this.state === this.states.SET_SPECIFIC_TIMES\n      ) {\n        // Determine colInc and rowInc\n        let colInc =\n          (this.dragCur.col - this.dragStart.col) /\n          Math.abs(this.dragCur.col - this.dragStart.col)\n        let rowInc =\n          (this.dragCur.row - this.dragStart.row) /\n          Math.abs(this.dragCur.row - this.dragStart.row)\n        if (isNaN(colInc)) colInc = 1\n        if (isNaN(rowInc)) rowInc = 1\n\n        // Determine iteration variables\n        let rowStart = this.dragStart.row\n        let rowMax = this.dragCur.row + rowInc\n        let colStart = this.dragStart.col\n        let colMax = this.dragCur.col + colInc\n\n        // Correct iteration variables if days only\n        if (this.event.daysOnly) {\n          colStart = 0\n          colMax = 7\n          colInc = 1\n        }\n\n        // Iterate all selected time slots and either add or remove them\n        for (let r = rowStart; r != rowMax; r += rowInc) {\n          for (let c = colStart; c != colMax; c += colInc) {\n            const date = this.getDateFromRowCol(r, c)\n            if (!date) continue\n\n            if (this.event.daysOnly) {\n              // Don't add to availability set if month day is not included\n              const isMonthDayIncluded =\n                this.monthDayIncluded.get(date.getTime()) &&\n                this.inDragRange(r, c)\n              if (!isMonthDayIncluded) continue\n            }\n\n            if (this.dragType === this.DRAG_TYPES.ADD) {\n              if (this.state === this.states.SET_SPECIFIC_TIMES) {\n                this.tempTimes.add(date.getTime())\n              } else {\n                // Add / remove time from availability set\n                if (this.availabilityType === availabilityTypes.AVAILABLE) {\n                  this.availability.add(date.getTime())\n                  this.ifNeeded.delete(date.getTime())\n                } else if (\n                  this.availabilityType === availabilityTypes.IF_NEEDED\n                ) {\n                  this.ifNeeded.add(date.getTime())\n                  this.availability.delete(date.getTime())\n                }\n              }\n            } else if (this.dragType === this.DRAG_TYPES.REMOVE) {\n              if (this.state === this.states.SET_SPECIFIC_TIMES) {\n                this.tempTimes.delete(date.getTime())\n              } else {\n                // Add / remove time from availability set\n                this.availability.delete(date.getTime())\n                this.ifNeeded.delete(date.getTime())\n              }\n            }\n\n            // Edit manualAvailability set if event is a GROUP\n            if (this.event.type === eventTypes.GROUP) {\n              const discreteDate = dateToDowDate(\n                this.event.dates,\n                date,\n                this.weekOffset,\n                true\n              )\n              const startDateOfDay = dateToDowDate(\n                this.event.dates,\n                this.days[c].dateObject,\n                this.weekOffset,\n                true\n              )\n\n              // If date not touched, then add all of the existing calendar availabilities and mark it as touched\n              if (!(startDateOfDay.getTime() in this.manualAvailability)) {\n                // Create new set\n                this.manualAvailability[startDateOfDay.getTime()] = new Set()\n\n                // Add the existing calendar availabilities\n                const existingAvailability = this.getAvailabilityForColumn(c)\n                for (const a of existingAvailability) {\n                  const convertedDate = dateToDowDate(\n                    this.event.dates,\n                    new Date(a),\n                    this.weekOffset,\n                    true\n                  )\n                  this.manualAvailability[startDateOfDay.getTime()].add(\n                    convertedDate.getTime()\n                  )\n                }\n              }\n\n              // Add / remove time from manual availability set\n              if (this.dragType === this.DRAG_TYPES.ADD) {\n                this.manualAvailability[startDateOfDay.getTime()].add(\n                  discreteDate.getTime()\n                )\n              } else if (this.dragType === this.DRAG_TYPES.REMOVE) {\n                this.manualAvailability[startDateOfDay.getTime()].delete(\n                  discreteDate.getTime()\n                )\n              }\n            }\n          }\n        }\n        this.availability = new Set(this.availability)\n      } else if (this.state === this.states.SCHEDULE_EVENT) {\n        // Update scheduled event\n        const col = this.dragStart.col\n        const row = this.dragStart.row\n        const numRows = this.dragCur.row - this.dragStart.row + 1\n\n        if (numRows > 0) {\n          this.curScheduledEvent = { col, row, numRows }\n        } else {\n          this.curScheduledEvent = null\n        }\n      } else if (this.state === this.states.EDIT_SIGN_UP_BLOCKS) {\n        // Update sign up blocks\n        const dayIndex = this.dragStart.col\n        const hoursOffset = this.dragStart.row / 4\n        const hoursLength = (this.dragCur.row - this.dragStart.row + 1) / 4\n        if (hoursLength > 0) {\n          this.signUpBlocksToAddByDay[dayIndex].push(\n            this.createSignUpBlock(dayIndex, hoursOffset, hoursLength)\n          )\n        }\n      }\n\n      // Set dragging defaults\n      this.dragging = false\n      this.dragStart = null\n      this.dragCur = null\n    },\n    inDragRange(row, col) {\n      /* Returns whether the given row and col is within the drag range */\n      if (this.dragging) {\n        if (this.event.daysOnly) {\n          if (\n            isBetween(row, this.dragStart.row, this.dragCur.row) ||\n            isBetween(row, this.dragCur.row, this.dragStart.row)\n          ) {\n            if (this.dragCur.row < this.dragStart.row) {\n              return (\n                (this.dragCur.row === row && this.dragCur.col <= col) ||\n                (this.dragStart.row === row && this.dragStart.col >= col) ||\n                (this.dragStart.row !== row && this.dragCur.row !== row)\n              )\n            } else if (this.dragCur.row > this.dragStart.row) {\n              return (\n                (this.dragCur.row === row && this.dragCur.col >= col) ||\n                (this.dragStart.row === row && this.dragStart.col <= col) ||\n                (this.dragStart.row !== row && this.dragCur.row !== row)\n              )\n            } else {\n              // cur row == start row\n              return (\n                isBetween(col, this.dragStart.col, this.dragCur.col) ||\n                isBetween(col, this.dragCur.col, this.dragStart.col)\n              )\n            }\n          }\n          return false\n        }\n\n        return (\n          (isBetween(row, this.dragStart.row, this.dragCur.row) ||\n            isBetween(row, this.dragCur.row, this.dragStart.row)) &&\n          (isBetween(col, this.dragStart.col, this.dragCur.col) ||\n            isBetween(col, this.dragCur.col, this.dragStart.col))\n        )\n      }\n      return false\n    },\n    moveDrag(e) {\n      if (!this.allowDrag) return\n      if (e.touches?.length > 1) return // If dragging with more than one finger\n      if (!this.dragStart) return\n\n      e.preventDefault()\n      let { row, col } = this.getRowColFromXY(\n        ...Object.values(this.normalizeXY(e))\n      )\n\n      if (\n        this.maxSignUpBlockRowSize &&\n        row >= this.dragStart.row + this.maxSignUpBlockRowSize\n      ) {\n        row = this.dragStart.row + this.maxSignUpBlockRowSize - 1\n      } else if (this.state === this.states.SCHEDULE_EVENT) {\n        const isFirstSplit = this.dragStart.row < this.splitTimes[0].length\n        if (isFirstSplit) {\n          row = Math.min(row, this.splitTimes[0].length - 1)\n        }\n      }\n\n      this.dragCur = { row, col }\n    },\n    startDrag(e) {\n      const { row, col } = this.getRowColFromXY(\n        ...Object.values(this.normalizeXY(e))\n      )\n\n      // If sign up form, check if trying to drag in a block\n      if (this.isSignUp) {\n        for (const block of this.signUpBlocksByDay[col].concat(\n          this.signUpBlocksToAddByDay[col]\n        )) {\n          if (\n            isBetween(\n              row,\n              block.hoursOffset * 4,\n              (block.hoursOffset + block.hoursLength) * 4 - 1\n            )\n          ) {\n            this.$refs.signUpBlocksList.scrollToSignUpBlock(block._id)\n            return\n          }\n        }\n      }\n\n      if (!this.allowDrag) return\n      if (e.touches?.length > 1) return // If dragging with more than one finger\n\n      const date = this.getDateFromRowCol(row, col)\n      if (!date) return\n\n      // Dont start dragging if day not included in daysonly event\n      if (this.event.daysOnly && !this.monthDayIncluded.get(date.getTime())) {\n        return\n      }\n\n      this.dragging = true\n      this.dragStart = { row, col }\n      this.dragCur = { row, col }\n\n      // Prevent scroll\n      e.preventDefault()\n\n      // Set drag type\n      if (this.isSignUp) {\n        this.dragType = this.DRAG_TYPES.ADD\n      } else if (\n        (this.state === this.states.SET_SPECIFIC_TIMES &&\n          this.tempTimes.has(date.getTime())) ||\n        (this.availabilityType === availabilityTypes.AVAILABLE &&\n          this.availability.has(date.getTime())) ||\n        (this.availabilityType === availabilityTypes.IF_NEEDED &&\n          this.ifNeeded.has(date.getTime()))\n      ) {\n        this.dragType = this.DRAG_TYPES.REMOVE\n      } else {\n        this.dragType = this.DRAG_TYPES.ADD\n      }\n    },\n    //#endregion\n\n    // -----------------------------------\n    //#region Options\n    // -----------------------------------\n    getLocalTimezone() {\n      const split = new Date(this.event.dates[0])\n        .toLocaleTimeString(\"en-us\", { timeZoneName: \"short\" })\n        .split(\" \")\n      const localTimezone = split[split.length - 1]\n\n      return localTimezone\n    },\n    onShowBestTimesChange() {\n      localStorage[\"showBestTimes\"] = this.showBestTimes\n      if (\n        this.state == this.states.BEST_TIMES ||\n        this.state == this.states.HEATMAP\n      )\n        this.state = this.defaultState\n    },\n    toggleShowEditOptions() {\n      this.showEditOptions = !this.showEditOptions\n      localStorage[\"showEditOptions\"] = this.showEditOptions\n    },\n    toggleShowEventOptions() {\n      this.showEventOptions = !this.showEventOptions\n      localStorage[\"showEventOptions\"] = this.showEventOptions\n    },\n    updateOverlayAvailability(val) {\n      this.overlayAvailability = !!val\n      this.$posthog?.capture(\"overlay_availability_toggled\", {\n        enabled: !!val,\n      })\n    },\n    //#endregion\n\n    // -----------------------------------\n    //#region Scroll\n    // -----------------------------------\n    onCalendarScroll(e) {\n      this.calendarMaxScroll = e.target.scrollWidth - e.target.offsetWidth\n      this.calendarScrollLeft = e.target.scrollLeft\n    },\n    onScroll(e) {\n      this.checkElementsVisible()\n    },\n    /** Checks whether certain elements are visible and sets variables accoringly */\n    checkElementsVisible() {\n      const optionsSectionEl = this.$refs.optionsSection\n      if (optionsSectionEl) {\n        this.optionsVisible = isElementInViewport(optionsSectionEl, {\n          bottomOffset: -64,\n        })\n      }\n\n      const respondentsListEl = this.$refs.respondentsList?.$el\n      if (respondentsListEl) {\n        this.scrolledToRespondents = isElementInViewport(respondentsListEl, {\n          bottomOffset: -64,\n        })\n      }\n    },\n    //#endregion\n\n    // -----------------------------------\n    //#region Pagination\n    // -----------------------------------\n    nextPage(e) {\n      e.stopImmediatePropagation()\n      if (this.event.type === eventTypes.GROUP) {\n        // Go to next page if there are still more days left to see\n        // Otherwise, update week offset\n        if ((this.page + 1) * this.maxDaysPerPage < this.allDays.length) {\n          this.page++\n        } else {\n          this.page = 0\n          this.$emit(\"update:weekOffset\", this.weekOffset + 1)\n        }\n      } else {\n        this.page++\n      }\n      this.pageHasChanged = true\n    },\n    prevPage(e) {\n      e.stopImmediatePropagation()\n      if (this.event.type === eventTypes.GROUP) {\n        // Go to prev page if there is a prev page\n        // Otherwise, update week offset\n        if (this.page > 0) {\n          this.page--\n        } else {\n          this.page = Math.ceil(this.allDays.length / this.maxDaysPerPage) - 1\n          this.$emit(\"update:weekOffset\", this.weekOffset - 1)\n        }\n      } else {\n        this.page--\n      }\n      this.pageHasChanged = true\n    },\n    //#endregion\n\n    // -----------------------------------\n    //#region Resize\n    // -----------------------------------\n    onResize() {\n      this.setTimeslotSize()\n    },\n    //#endregion\n\n    // -----------------------------------\n    //#region hint\n    // -----------------------------------\n    closeHint() {\n      this.hintState = false\n      localStorage[this.hintStateLocalStorageKey] = true\n    },\n    //#endregion\n\n    // -----------------------------------\n    //#region Group\n    // -----------------------------------\n\n    /** Toggles calendar account - in groups to enable/disable calendars */\n    toggleCalendarAccount(payload) {\n      this.sharedCalendarAccounts[\n        getCalendarAccountKey(payload.email, payload.calendarType)\n      ].enabled = payload.enabled\n      this.sharedCalendarAccounts = JSON.parse(\n        JSON.stringify(this.sharedCalendarAccounts)\n      )\n    },\n\n    /** Toggles sub calendar account - in groups to enable/disable sub calendars */\n    toggleSubCalendarAccount(payload) {\n      this.sharedCalendarAccounts[\n        getCalendarAccountKey(payload.email, payload.calendarType)\n      ].subCalendars[payload.subCalendarId].enabled = payload.enabled\n      this.sharedCalendarAccounts = JSON.parse(\n        JSON.stringify(this.sharedCalendarAccounts)\n      )\n    },\n\n    /** Sets the initial sharedCalendarAccounts object */\n    initSharedCalendarAccounts() {\n      if (!this.authUser) return\n\n      // Init shared calendar accounts to current calendar accounts\n      this.sharedCalendarAccounts = JSON.parse(\n        JSON.stringify(this.authUser.calendarAccounts)\n      )\n\n      // Disable all calendars\n      for (const id in this.sharedCalendarAccounts) {\n        this.sharedCalendarAccounts[id].enabled = false\n        if (this.sharedCalendarAccounts[id].subCalendars) {\n          for (const subCalendarId in this.sharedCalendarAccounts[id]\n            .subCalendars) {\n            this.sharedCalendarAccounts[id].subCalendars[\n              subCalendarId\n            ].enabled = false\n          }\n        }\n      }\n\n      // Enable calendars based on responses\n      if (this.authUser._id in this.event.responses) {\n        const enabledCalendars =\n          this.event.responses[this.authUser._id].enabledCalendars\n\n        for (const id in enabledCalendars) {\n          this.sharedCalendarAccounts[id].enabled = true\n\n          enabledCalendars[id].forEach((subCalendarId) => {\n            this.sharedCalendarAccounts[id].subCalendars[\n              subCalendarId\n            ].enabled = true\n          })\n        }\n      }\n    },\n\n    /** Based on the date, determine whether it has been touched */\n    isTouched(date, availability = [...this.availability]) {\n      const start = new Date(date)\n      const end = new Date(date)\n      end.setHours(end.getHours() + this.event.duration)\n\n      for (const a of availability) {\n        const availableTime = new Date(a).getTime()\n        if (\n          start.getTime() <= availableTime &&\n          availableTime <= end.getTime()\n        ) {\n          return true\n        }\n      }\n\n      return false\n    },\n\n    /** Returns a subset of availability for the current date */\n    getAvailabilityForColumn(column, availability = [...this.availability]) {\n      const subset = new Set()\n      const availabilitySet = new Set(availability)\n      for (\n        let r = 0;\n        r < this.splitTimes[0].length + this.splitTimes[1].length;\n        ++r\n      ) {\n        const date = this.getDateFromRowCol(r, column)\n        if (!date) continue\n\n        if (availabilitySet.has(date.getTime())) {\n          subset.add(date.getTime())\n        }\n      }\n\n      return subset\n    },\n\n    /** Returns a copy of the manual availability, converted to dow dates */\n    getManualAvailabilityDow(manualAvailability = this.manualAvailability) {\n      if (!manualAvailability) return null\n\n      const manualAvailabilityDow = {}\n      for (const time in manualAvailability) {\n        const dowTime = dateToDowDate(\n          this.event.dates,\n          new Date(parseInt(time)),\n          this.weekOffset\n        ).getTime()\n        manualAvailabilityDow[dowTime] = [...manualAvailability[time]].map(\n          (a) => dateToDowDate(this.event.dates, new Date(a), this.weekOffset)\n        )\n      }\n      return manualAvailabilityDow\n    },\n    //#endregion\n\n    // -----------------------------------\n    //#region Sign up form\n    // -----------------------------------\n\n    /** Creates a sign up block for the current day and hour offset */\n    createSignUpBlock(dayIndex, hoursOffset, hoursLength) {\n      const timeBlock = getTimeBlock(\n        this.days[dayIndex].dateObject,\n        hoursOffset,\n        hoursLength\n      )\n\n      return {\n        _id: ObjectID().toString(),\n        capacity: 1,\n        name: this.newSignUpBlockName,\n        ...timeBlock,\n        hoursOffset,\n        hoursLength,\n      }\n    },\n\n    /** Updates the sign up block with the same id */\n    editSignUpBlock(signUpBlock) {\n      this.signUpBlocksByDay.forEach((blocksInDay, dayIndex) => {\n        blocksInDay.forEach((block, blockIndex) => {\n          if (signUpBlock._id === block._id) {\n            this.signUpBlocksByDay[dayIndex][blockIndex] = signUpBlock\n            this.signUpBlocksByDay = [...this.signUpBlocksByDay]\n            return\n          }\n        })\n      })\n\n      this.signUpBlocksToAddByDay.forEach((blocksInDay, dayIndex) => {\n        blocksInDay.forEach((block, blockIndex) => {\n          if (signUpBlock._id === block._id) {\n            this.signUpBlocksToAddByDay[dayIndex][blockIndex] = signUpBlock\n            this.signUpBlocksToAddByDay = [...this.signUpBlocksToAddByDay]\n            return\n          }\n        })\n      })\n    },\n\n    /** Deletes the sign up block with the id */\n    deleteSignUpBlock(signUpBlockId) {\n      this.signUpBlocksByDay.forEach((blocksInDay, dayIndex) => {\n        blocksInDay.forEach((block, blockIndex) => {\n          if (signUpBlockId === block._id) {\n            this.signUpBlocksByDay[dayIndex].splice(blockIndex, 1)\n            return\n          }\n        })\n      })\n\n      this.signUpBlocksToAddByDay.forEach((blocksInDay, dayIndex) => {\n        blocksInDay.forEach((block, blockIndex) => {\n          if (signUpBlockId === block._id) {\n            this.signUpBlocksToAddByDay[dayIndex].splice(blockIndex, 1)\n            return\n          }\n        })\n      })\n    },\n\n    /** Reloads all the data for the sign up form */\n    resetSignUpForm() {\n      /** Split sign up blocks by day */\n      this.signUpBlocksByDay = splitTimeBlocksByDay(\n        this.event,\n        this.event.signUpBlocks ?? []\n      )\n\n      this.resetSignUpBlocksToAddByDay()\n\n      /** Populate sign up block responses */\n      for (const userId in this.event.signUpResponses) {\n        const signUpResponse = this.event.signUpResponses[userId]\n        for (const signUpBlockId of signUpResponse.signUpBlockIds) {\n          const signUpBlock = this.signUpBlocksByDay\n            .flat()\n            .find((signUpBlock) => signUpBlock._id === signUpBlockId)\n\n          if (!signUpBlock.responses) signUpBlock.responses = []\n          signUpBlock.responses.push(signUpResponse)\n        }\n      }\n    },\n\n    /** Initialize sign up blocks to be added array */\n    resetSignUpBlocksToAddByDay() {\n      this.signUpBlocksToAddByDay = []\n      for (const day of this.signUpBlocksByDay) {\n        this.signUpBlocksToAddByDay.push([])\n      }\n    },\n\n    /** Emits sign up for block to parent element */\n    handleSignUpBlockClick(block) {\n      if (!this.alreadyRespondedToSignUpForm && !this.isOwner)\n        this.$emit(\"signUpForBlock\", block)\n    },\n\n    //#endregion\n\n    // -----------------------------------\n    //#region Specific times for specific days\n    // -----------------------------------\n\n    /** Saves the temporary times to the event */\n    saveTempTimes() {\n      // Set event times\n      this.event.times = [...this.tempTimes]\n        .map((t) => new Date(t))\n        .sort((a, b) => a.getTime() - b.getTime())\n\n      const { minHours, maxHours } = this.getMinMaxHoursFromTimes(\n        this.event.times\n      )\n\n      // Set event dates to start at the new times\n      for (let i = 0; i < this.event.dates.length; ++i) {\n        const date = new Date(this.event.dates[i])\n        date.setTime(date.getTime() - this.timezoneOffset * 60 * 1000)\n        date.setUTCHours(minHours, 0, 0, 0)\n        date.setTime(date.getTime() + this.timezoneOffset * 60 * 1000)\n        this.event.dates[i] = date.toISOString()\n      }\n\n      // Set event duration to the difference between the max and min hours\n      this.event.duration = maxHours - minHours + 1\n\n      // Update event\n      put(`/events/${this.event._id}`, this.event)\n        .then(() => {\n          this.state = this.defaultState\n        })\n        .catch((err) => {\n          this.showError(err)\n        })\n    },\n\n    /** Returns the min and max hours from the times */\n    getMinMaxHoursFromTimes(times) {\n      let minHours = 24\n      let maxHours = 0\n      for (const time of times) {\n        const timeDate = new Date(time)\n        const date = new Date(\n          timeDate.getTime() - this.timezoneOffset * 60 * 1000\n        )\n        const localHours = date.getUTCHours()\n        if (localHours < minHours) {\n          minHours = localHours\n        } else if (localHours > maxHours) {\n          maxHours = localHours\n        }\n      }\n      return { minHours, maxHours }\n    },\n\n    //#endregion\n\n    /** Recalculate availability the calendar based on calendar events */\n    reanimateAvailability() {\n      if (\n        this.state === this.states.EDIT_AVAILABILITY &&\n        this.authUser &&\n        !(this.authUser?._id in this.event.responses) && // User hasn't responded yet\n        !this.loadingCalendarEvents &&\n        (!this.unsavedChanges || this.availabilityAnimEnabled)\n      ) {\n        for (const timeout of this.availabilityAnimTimeouts) {\n          clearTimeout(timeout)\n        }\n        this.setAvailabilityAutomatically()\n      }\n    },\n  },\n  watch: {\n    availability() {\n      if (this.state === this.states.EDIT_AVAILABILITY) {\n        this.unsavedChanges = true\n      }\n    },\n    event: {\n      immediate: true,\n      handler() {\n        this.initSharedCalendarAccounts()\n        this.fetchResponses()\n      },\n    },\n    state(nextState, prevState) {\n      this.$nextTick(() => this.checkElementsVisible())\n\n      // Reset scheduled event when exiting schedule event state\n      if (prevState === this.states.SCHEDULE_EVENT) {\n        this.curScheduledEvent = null\n      } else if (prevState === this.states.EDIT_AVAILABILITY) {\n        this.unsavedChanges = false\n      }\n\n      if (nextState === this.states.SET_SPECIFIC_TIMES) {\n        this.$nextTick(() => {\n          const time9 = document.getElementById(\"time-9\")\n          if (time9) {\n            const yOffset = -150\n            const y =\n              time9.getBoundingClientRect().top + window.scrollY + yOffset\n            window.scrollTo({ top: y, behavior: \"smooth\" })\n          }\n        })\n      }\n    },\n    respondents: {\n      immediate: true,\n      handler() {\n        this.curTimeslotAvailability = {}\n        for (const respondent of this.respondents) {\n          this.curTimeslotAvailability[respondent._id] = true\n        }\n      },\n    },\n    calendarEventsByDay(val, oldVal) {\n      if (JSON.stringify(val) !== JSON.stringify(oldVal)) {\n        this.reanimateAvailability()\n      }\n    },\n    page() {\n      this.$nextTick(() => {\n        this.setTimeslotSize()\n      })\n    },\n    allDays() {\n      this.$nextTick(() => {\n        this.setTimeslotSize()\n      })\n    },\n    showStickyRespondents: {\n      immediate: true,\n      handler(cur) {\n        clearTimeout(this.delayedShowStickyRespondentsTimeout)\n        this.delayedShowStickyRespondentsTimeout = setTimeout(() => {\n          this.delayedShowStickyRespondents = cur\n        }, 100)\n      },\n    },\n    maxDaysPerPage() {\n      // Set page to 0 if user switches from portrait to landscape orientation and we're on an invalid page number,\n      // i.e. we're on a page that displays 0 days\n      if (this.page * this.maxDaysPerPage >= this.allDays.length) {\n        this.page = 0\n      }\n    },\n    mobileNumDays() {\n      // Save mobile num days in localstorage\n      localStorage[\"mobileNumDays\"] = this.mobileNumDays\n\n      // Set timeslot size because it has changed\n      this.$nextTick(() => {\n        this.setTimeslotSize()\n      })\n    },\n    weekOffset() {\n      if (this.event.type === eventTypes.GROUP) {\n        this.fetchResponses()\n      }\n    },\n    hideIfNeeded() {\n      this.getResponsesFormatted()\n    },\n    parsedResponses() {\n      // Theoretically, parsed responses should only be changing for groups\n      this.getResponsesFormatted()\n\n      // Repopulate user availability when editing availability (this happens when switching weeks in a group)\n      if (\n        this.event.type === eventTypes.GROUP &&\n        this.state === this.states.EDIT_AVAILABILITY &&\n        this.authUser\n      ) {\n        this.availability = new Set()\n        this.populateUserAvailability(this.authUser._id)\n      }\n    },\n    showBestTimes() {\n      this.onShowBestTimesChange()\n    },\n    startCalendarOnMonday() {\n      localStorage[\"startCalendarOnMonday\"] = this.startCalendarOnMonday\n    },\n    bufferTime(cur, prev) {\n      if (cur.enabled !== prev.enabled || cur.enabled) {\n        this.reanimateAvailability()\n      }\n    },\n    workingHours(cur, prev) {\n      if (cur.enabled !== prev.enabled || cur.enabled) {\n        this.reanimateAvailability()\n      }\n    },\n    timeType() {\n      localStorage[\"timeType\"] = this.timeType\n    },\n    fromEditEvent() {\n      if (this.fromEditEvent && this.isSpecificTimes) {\n        this.tempTimes = new Set(\n          this.event.times.map((t) => new Date(t).getTime())\n        )\n        this.state = this.states.SET_SPECIFIC_TIMES\n      }\n    },\n  },\n  created() {\n    this.resetCurUserAvailability()\n\n    addEventListener(\"click\", this.deselectRespondents)\n  },\n  mounted() {\n    // Get query parameters from URL\n    const urlParams = new URLSearchParams(window.location.search)\n\n    // Set initial state\n    if (\n      this.event.hasSpecificTimes &&\n      (this.fromEditEvent || !this.event.times || this.event.times.length === 0)\n    ) {\n      this.state = this.states.SET_SPECIFIC_TIMES\n    } else if (urlParams.get(\"scheduled_event\")) {\n      const scheduledEvent = JSON.parse(urlParams.get(\"scheduled_event\"))\n      this.curScheduledEvent = scheduledEvent\n      this.state = this.states.SCHEDULE_EVENT\n\n      // Remove the scheduled_event parameter from URL to avoid reloading the same state\n      const newUrl = new URL(window.location.href)\n      newUrl.searchParams.delete(\"scheduled_event\")\n      window.history.replaceState({}, document.title, newUrl.toString())\n    } else if (this.showBestTimes) {\n      this.state = \"best_times\"\n    } else {\n      this.state = \"heatmap\"\n    }\n\n    // Set calendar options defaults\n    if (this.authUser) {\n      this.bufferTime =\n        this.authUser?.calendarOptions?.bufferTime ??\n        calendarOptionsDefaults.bufferTime\n      this.workingHours =\n        this.authUser?.calendarOptions?.workingHours ??\n        calendarOptionsDefaults.workingHours\n      if (this.isGroup) {\n        if (this.event.responses[this.authUser._id]?.calendarOptions) {\n          // Update calendar options if user has changed them for this specific group\n          const { bufferTime, workingHours } =\n            this.event.responses[this.authUser._id]?.calendarOptions\n          if (bufferTime) this.bufferTime = bufferTime\n          if (workingHours) this.workingHours = workingHours\n        } else {\n          this.bufferTime = calendarOptionsDefaults.bufferTime\n          this.workingHours = calendarOptionsDefaults.workingHours\n        }\n      }\n    }\n\n    // Set initial calendar max scroll\n    // this.calendarMaxScroll =\n    //   this.$refs.calendar.scrollWidth - this.$refs.calendar.offsetWidth\n\n    // Get timeslot size\n    this.setTimeslotSize()\n    addEventListener(\"resize\", this.onResize)\n    addEventListener(\"scroll\", this.onScroll)\n    if (!this.calendarOnly) {\n      const timesEl = document.getElementById(\"drag-section\")\n      if (isTouchEnabled()) {\n        timesEl.addEventListener(\"touchstart\", this.startDrag)\n        timesEl.addEventListener(\"touchmove\", this.moveDrag)\n        timesEl.addEventListener(\"touchend\", this.endDrag)\n        timesEl.addEventListener(\"touchcancel\", this.endDrag)\n      }\n      timesEl.addEventListener(\"mousedown\", this.startDrag)\n      timesEl.addEventListener(\"mousemove\", this.moveDrag)\n      timesEl.addEventListener(\"mouseup\", this.endDrag)\n    }\n\n    // Parse sign up blocks and responses\n    this.resetSignUpForm()\n  },\n  beforeDestroy() {\n    removeEventListener(\"click\", this.deselectRespondents)\n    removeEventListener(\"resize\", this.onResize)\n    removeEventListener(\"scroll\", this.onScroll)\n  },\n  components: {\n    AlertText,\n    AvailabilityTypeToggle,\n    ExpandableSection,\n    BufferTimeSwitch,\n    UserAvatarContent,\n    ZigZag,\n    ConfirmDetailsDialog,\n    ToolRow,\n    CalendarAccounts,\n    RespondentsList,\n    Advertisement,\n    GCalWeekSelector,\n    WorkingHoursToggle,\n    SignUpBlock,\n    SignUpCalendarBlock,\n    SignUpBlocksList,\n    CalendarEventBlock, // Added component registration\n    SpecificTimesInstructions, // Added component registration\n    Tooltip,\n  },\n}\n</script>\n"],"mappings":";;;;AAm7BA,SACAA,iBAAA,EACAC,WAAA,EACAC,kBAAA,EACAC,IAAA,EACAC,GAAA,EACAC,SAAA,EACAC,KAAA,EACAC,OAAA,EACAC,kBAAA,EACAC,oBAAA,EACAC,YAAA,EACAC,aAAA,EACAC,OAAA,EACAC,GAAA,EACAC,gBAAA,EACAC,aAAA,EACAC,+BAAA,EACAC,cAAA,EACAC,mBAAA,EACAC,WAAA,EACAC,yBAAA,EACAC,cAAA,EACAC,qBAAA,EACAC,gBAAA,EACAC,mBAAA,EACAC,mBAAA,EACAC,aAAA,QACA;AACA,SACAC,iBAAA,EACAC,uBAAA,EACAC,UAAA,EACAC,SAAA,EACAC,iBAAA,EACAC,kBAAA,QACA;AACA,SAAAC,YAAA,EAAAC,UAAA,EAAAC,QAAA;AACA,OAAAC,iBAAA;AACA,OAAAC,gBAAA;AACA,OAAAC,aAAA;AACA,OAAAC,WAAA;AACA,OAAAC,mBAAA;AACA,OAAAC,gBAAA;AACA,OAAAC,MAAA;AACA,OAAAC,oBAAA;AACA,OAAAC,OAAA;AACA,OAAAC,eAAA;AACA,OAAAC,gBAAA;AACA,OAAAC,iBAAA;AACA,OAAAC,kBAAA;AACA,OAAAC,SAAA;AACA,OAAAC,OAAA;AAEA,OAAAC,KAAA;AACA,OAAAC,QAAA;AACA,OAAAC,SAAA;AACA,OAAAC,cAAA;AACA,OAAAC,sBAAA;AACA,OAAAC,gBAAA;AACA,OAAAC,kBAAA;AACA,OAAAC,yBAAA;AACAP,KAAA,CAAAQ,MAAA,CAAAN,SAAA;AACAF,KAAA,CAAAQ,MAAA,CAAAL,cAAA;AAEA;EACAM,IAAA;EACAC,KAAA;IACAC,KAAA;MAAAC,IAAA,EAAAC,MAAA;MAAAC,QAAA;IAAA;IACAC,aAAA;MAAAH,IAAA,EAAAI,OAAA;MAAAC,OAAA;IAAA;IAEAC,qBAAA;MAAAN,IAAA,EAAAI,OAAA;MAAAC,OAAA;IAAA;IAAA;IACAE,iBAAA;MAAAP,IAAA,EAAAC,MAAA;MAAAI,OAAA,EAAAA,CAAA;IAAA;IAAA;IACAG,yBAAA;MAAAR,IAAA,EAAAS,KAAA;MAAAP,QAAA;IAAA;IAAA;IACAQ,yBAAA;MAAAV,IAAA,EAAAI,OAAA;MAAAC,OAAA;IAAA;IAAA;;IAEAM,UAAA;MAAAX,IAAA,EAAAY,MAAA;MAAAP,OAAA;IAAA;IAAA;;IAEAQ,wBAAA;MAAAb,IAAA,EAAAI,OAAA;MAAAC,OAAA;IAAA;IAAA;IACAS,YAAA;MAAAd,IAAA,EAAAI,OAAA;MAAAC,OAAA;IAAA;IAAA;IACAU,YAAA;MAAAf,IAAA,EAAAI,OAAA;MAAAC,OAAA;IAAA;IAAA;IACAW,YAAA;MAAAhB,IAAA,EAAAI,OAAA;MAAAC,OAAA;IAAA;IAAA;IACAY,YAAA;MAAAjB,IAAA,EAAAI,OAAA;MAAAC,OAAA;IAAA;IAAA;IACAa,qBAAA;MAAAlB,IAAA,EAAAI,OAAA;MAAAC,OAAA;IAAA;IAAA;IACAc,YAAA;MAAAnB,IAAA,EAAAI,OAAA;MAAAC,OAAA;IAAA;IAAA;;IAEAe,UAAA;MAAApB,IAAA,EAAAqB,MAAA;MAAAhB,OAAA;IAAA;IAAA;IACAiB,yBAAA;MAAAtB,IAAA,EAAAI,OAAA;MAAAC,OAAA;IAAA;IAAA;;IAEAkB,eAAA;MAAAvB,IAAA,EAAAC,MAAA;MAAAI,OAAA,EAAAA,CAAA;IAAA;IAEA;IACAmB,sBAAA;MAAAxB,IAAA,EAAAC,MAAA;MAAAI,OAAA,EAAAA,CAAA;IAAA;EACA;EACAoB,KAAA;IACA;MACAC,MAAA;QACAC,OAAA;QAAA;QACAC,mBAAA;QAAA;QACAC,mBAAA;QAAA;QACAC,UAAA;QAAA;QACAC,iBAAA;QAAA;QACAC,mBAAA;QAAA;QACAC,cAAA;QAAA;QACAC,kBAAA;MACA;MACAC,KAAA;MAEAC,YAAA,MAAAC,GAAA;MAAA;MACAC,QAAA,MAAAD,GAAA;MAAA;MACAE,SAAA,MAAAF,GAAA;MAAA;MACAG,wBAAA;MAAA;MACAC,uBAAA;MAAA;MACAC,WAAA;MAAA;MACAC,cAAA;MAAA;MACAC,WAAA;QAAAC,GAAA;QAAAC,GAAA;MAAA;MAAA;MACAC,gBAAA;MAAA;MACAC,uBAAA;MAAA;MACAC,aAAA;MAAA;MACAC,cAAA;MAAA;MACAC,sBAAA;MAAA;MACAC,gBAAA;MAAA;MACAC,gBAAA;QAAAC,OAAA;QAAAC,WAAA,MAAAC,IAAA,GAAAC,OAAA;MAAA;MAAA;MACAC,kBAAA,MAAAC,GAAA;MAAA;MACAC,cAAA;MAAA;;MAEA;MACAC,iBAAA;MAAA;MACAC,sBAAA;MAAA;;MAEA;MACAC,eAAA,EACAC,YAAA,uBAAAC,SAAA,GACA,QACAD,YAAA;MACAE,gBAAA,EAAAtG,iBAAA,CAAAuG,SAAA;MAAA;MACAC,mBAAA;MAAA;MACAC,UAAA,EAAAxG,uBAAA,CAAAwG,UAAA;MAAA;MACAC,YAAA,EAAAzG,uBAAA,CAAAyG,YAAA;MAAA;;MAEA;MACAC,gBAAA,EACAP,YAAA,wBAAAC,SAAA,GACA,QACAD,YAAA;MACAQ,aAAA,EACAR,YAAA,qBAAAC,SAAA,GACA,QACAD,YAAA;MACAS,YAAA;MAEA;MACAC,UAAA;QACAC,GAAA;QACAC,MAAA;MACA;MACAC,gBAAA;MACAC,eAAA;MACAC,WAAA;MACAC,QAAA;QACAC,KAAA;QACAC,MAAA;MACA;MACAC,QAAA;MACAC,QAAA;MACAC,SAAA;MACAC,OAAA;MAEA;MACAC,WAAA,OAAAhE,eAAA;MACAiE,iBAAA;MAAA;MACAC,QAAA,EACAzB,YAAA,iBACA1G,cAAA,KAAAS,SAAA,CAAA2H,MAAA,GAAA3H,SAAA,CAAA4H,MAAA;MAAA;MACAC,kBAAA;MACAC,qBAAA;MACA;MACA;MACA;;MAEA;MACAC,wBAAA;MACAC,qBAAA;MAEA;MACAC,cAAA;MACAC,kBAAA;MAAA;MACAC,iBAAA;MAAA;MACAC,qBAAA;MAAA;MACAC,4BAAA;MAAA;MACAC,mCAAA;MAAA;;MAEA;MACAC,IAAA;MACAC,aAAA,EAAAvC,YAAA,oBACAwC,QAAA,CAAAxC,YAAA,qBACA;MAAA;MACAyC,cAAA;MAEAC,oBAAA;MAEA;MACAC,SAAA;MAEA;MACAC,kBAAA;MAEA;MACAC,MAAA,GACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA;IAEA;EACA;EACAC,QAAA;IACA,GAAA1I,QAAA;IACA;IACA2I,eAAA;MACA,SAAAvK,OAAA;MACA,YAAAwK,QAAA;IACA;IACA;IACAC,WAAA;MACA;MACA,aAAApB,qBAAA,GACA,6CACA;IACA;IACA;IACAqB,mBAAA;MACA,cAAA1B,iBAAA;IACA;IACA;IACA2B,kBAAA;MACA,gBAAA/E,YAAA,EAAAgF,GAAA,CAAAC,IAAA,QAAA7D,IAAA,CAAA6D,IAAA;IACA;IACA;IACAC,cAAA;MACA,gBAAAhF,QAAA,EAAA8E,GAAA,CAAAC,IAAA,QAAA7D,IAAA,CAAA6D,IAAA;IACA;IACAE,UAAA;MACA,OACA,KAAApF,KAAA,UAAAT,MAAA,CAAAK,iBAAA,IACA,KAAAI,KAAA,UAAAT,MAAA,CAAAM,mBAAA,IACA,KAAAG,KAAA,UAAAT,MAAA,CAAAO,cAAA,IACA,KAAAE,KAAA,UAAAT,MAAA,CAAAQ,kBAAA;IAEA;IACA;IACAsF,oBAAA;MACA;MACA,SAAAhH,yBAAA,cAAAA,yBAAA;;MAEA;MACA,UAAAiH,QAAA,SAAAnG,yBAAA;MAEA,IAAAoG,MAAA;MACA,IAAA3H,KAAA;MAEA,MAAA4H,gBAAA,QAAAC,OAAA,GACA,KAAAzE,sBAAA,GACA,KAAAsE,QAAA,CAAAE,gBAAA;;MAEA;MACA,WAAAE,EAAA,IAAAF,gBAAA;QACA,KAAAA,gBAAA,CAAAE,EAAA,EAAAC,OAAA;QAEA,SAAAvH,iBAAA,CAAAwH,cAAA,CAAAF,EAAA;UACA,WAAAG,KAAA,SAAAzH,iBAAA,CAAAsH,EAAA,EAAAI,cAAA;YACAlI,KAAA,QAAAQ,iBAAA,CAAAsH,EAAA,EAAAI,cAAA,CAAAD,KAAA;;YAEA;YACA,MAAAE,YAAA,GAAAP,gBAAA,CAAAE,EAAA,EAAAK,YAAA;YACA,KAAAA,YAAA,MAAAnI,KAAA,CAAAoI,UAAA,IAAAD,YAAA;cACA;cACA;cACAR,MAAA,CAAAU,IAAA,CAAArI,KAAA;cACA,UAAA2G,oBAAA,UAAAkB,OAAA;gBACA,KAAAS,eAAA;cACA;cACA;YACA;;YAEA;YACA,IAAAH,YAAA,CAAAnI,KAAA,CAAAoI,UAAA,EAAAL,OAAA;cACAJ,MAAA,CAAAU,IAAA,CAAArI,KAAA;YACA;UACA;QACA;MACA;MAEA,MAAAuI,UAAA,GAAAC,IAAA,CAAAC,KAAA,CAAAD,IAAA,CAAAE,SAAA,CAAAf,MAAA;MAEA,MAAAF,mBAAA,GAAA9K,oBAAA,CACA,KAAAqD,KAAA,EACAuI,UAAA,EACA,KAAA3H,UAAA,EACA,KAAA+H,cACA;MAEA,OAAAlB,mBAAA;IACA;IACA;IACAmB,yBAAA;MACA,SAAA5I,KAAA,CAAAC,IAAA,KAAAlC,UAAA,CAAA8K,KAAA;MAEA,MAAAC,mBAAA;MACA,WAAAC,MAAA,SAAA/I,KAAA,CAAAgJ,SAAA;QACA,IAAAD,MAAA,UAAArB,QAAA,CAAAuB,GAAA;UACAH,mBAAA,CAAAC,MAAA,SAAAtB,mBAAA;QACA,WAAAsB,MAAA,SAAAtH,sBAAA;UACAqH,mBAAA,CAAAC,MAAA,IAAApM,oBAAA,CACA,KAAAqD,KAAA,EACA,KAAAyB,sBAAA,CAAAsH,MAAA,GACA,KAAAnI,UAAA,EACA,KAAA+H,cACA;QACA;MACA;MAEA,OAAAG,mBAAA;IACA;IACAI,kBAAA;MACA,WAAA5G,GAAA,MAAAa,cAAA;IACA;IAEA;IACA;IACA;;IAEA;IACAgG,mBAAA;MACA,gBACA,KAAArF,iBAAA,CAAAsF,IAAA,GAAAC,MAAA,GACA,KAAAtF,sBAAA,CAAAqF,IAAA,GAAAC,MAAA,GACA,CACA;IACA;IAEA;IACAC,sBAAA;MACA,UAAAhE,SAAA,UAAA2B,QAAA;MAEA,MAAAsC,WAAA,QAAAzF,iBAAA,MAAAwB,SAAA,CAAAvC,GAAA;MACA,MAAAyG,gBAAA,QAAAzF,sBAAA,MAAAuB,SAAA,CAAAvC,GAAA;MAEA,IAAAwG,WAAA,CAAAF,MAAA,UAAAG,gBAAA,CAAAH,MAAA;MAEA,IAAAI,OAAA,GAAAC,QAAA;MACA,WAAAC,KAAA,QAAAJ,WAAA,KAAAC,gBAAA;QACA,IAAAG,KAAA,CAAAC,WAAA,YAAAtE,SAAA,CAAAxC,GAAA;UACA2G,OAAA,GAAAI,IAAA,CAAAC,GAAA,CACAL,OAAA,EACAE,KAAA,CAAAC,WAAA,YAAAtE,SAAA,CAAAxC,GACA;QACA;MACA;MAEA,OAAA2G,OAAA;IACA;IAEA;IACAM,6BAAA;MACA,UAAArC,QAAA,UAAA5D,iBAAA;MAEA,YAAAA,iBAAA,CAAAkG,IAAA,CAAAC,SAAA,IACAA,SAAA,CAAAD,IAAA,CAAAL,KAAA,IACAA,KAAA,CAAAX,SAAA,EAAAgB,IAAA,CACAE,QAAA,IAAAA,QAAA,CAAAnB,MAAA,UAAArB,QAAA,CAAAuB,GACA,CACA,CACA;IACA;IAEA;;IAEA;IACAkB,kBAAA;MACA,IAAAC,GAAA;MACA,SAAApK,KAAA,CAAAqK,QAAA;QACA,WAAAC,GAAA,SAAAC,OAAA;UACA,MAAAC,GAAA,IACA,SAAA7G,kBAAA,CAAA5G,GAAA,CAAAuN,GAAA,CAAAG,UAAA,CAAA/G,OAAA,OACA,IAAApB,GAAA,IACA,CAAAoI,MAAA,CAAAC,CAAA,SAAAzB,iBAAA,CAAA0B,GAAA,CAAAD,CAAA,GAAAtB,MAAA;UAEA,IAAAmB,GAAA,GAAAJ,GAAA,EAAAA,GAAA,GAAAI,GAAA;QACA;MACA;QACA,SAAAK,CAAA,MAAAA,CAAA,QAAA7K,KAAA,CAAA8K,KAAA,CAAAzB,MAAA,EAAAwB,CAAA;UACA,MAAAE,IAAA,OAAAtH,IAAA,MAAAzD,KAAA,CAAA8K,KAAA,CAAAD,CAAA;UACA,WAAAG,IAAA,SAAAC,KAAA;YACA,MAAAT,GAAA,IACA,QAAAU,4BAAA,CAAAH,IAAA,EAAAC,IAAA,CAAApB,WAAA,EACA,CAAAc,MAAA,CAAAC,CAAA,SAAAzB,iBAAA,CAAA0B,GAAA,CAAAD,CAAA,GAAAtB,MAAA;YAEA,IAAAmB,GAAA,GAAAJ,GAAA,EAAAA,GAAA,GAAAI,GAAA;UACA;QACA;MACA;MACA,OAAAJ,GAAA;IACA;IACA;IACAe,UAAA;MACA,OAAAtB,IAAA,CAAAuB,KAAA,OAAApL,KAAA,CAAAqL,SAAA,QAAA1C,cAAA;IACA;IACA;IACA4B,QAAA;MACA,MAAAe,IAAA;MACA,MAAAC,UAAA,OAAAjJ,GAAA;MAEA,MAAAkJ,aAAA,GAAAT,IAAA;QACA,IAAAU,UAAA;QACA,IAAAC,SAAA;QACA,MAAAC,UAAA,OAAAlI,IAAA,CAAAsH,IAAA;QACA,SAAAa,eAAA;UACAD,UAAA,CAAAE,OAAA,CACAF,UAAA,CAAAjI,OAAA,UAAAiF,cAAA,YACA;QACA;UACAgD,UAAA,CAAAG,OAAA,CAAAH,UAAA,CAAAI,OAAA,UAAAZ,SAAA;QACA;QACA,SAAAa,eAAA;UACAP,UAAA,MACA,KAAA3E,MAAA,CAAA6E,UAAA,CAAAM,WAAA,GACA,IAAAN,UAAA,CAAAO,UAAA;UACAR,SAAA,QAAAxE,UAAA,CAAAyE,UAAA,CAAAQ,SAAA;QACA,gBAAAtE,OAAA,SAAAuE,QAAA;UACA,MAAAC,OAAA,GAAAxP,aAAA,CACA,KAAAmD,KAAA,CAAA8K,KAAA,EACAa,UAAA,EACA,KAAA/K,UAAA,EACA,IACA;UAEA6K,UAAA,MACA,KAAA3E,MAAA,CAAAuF,OAAA,CAAAJ,WAAA,GACA,IAAAI,OAAA,CAAAH,UAAA;UACAR,SAAA,QAAAxE,UAAA,CAAAmF,OAAA,CAAAF,SAAA;QACA;QACA;UAAAV,UAAA;UAAAC;QAAA;MACA;MAEA,IACA,KAAAE,eAAA,KACA,KAAAxJ,KAAA,UAAAT,MAAA,CAAAQ,kBAAA,IACA,KAAAnC,KAAA,CAAAiL,KAAA,EAAA5B,MAAA,SACA;QACA,IAAAiD,QAAA;QACA,SAAAzB,CAAA,MAAAA,CAAA,QAAA7K,KAAA,CAAA8K,KAAA,CAAAzB,MAAA,IAAAwB,CAAA;UACA,MAAAE,IAAA,OAAAtH,IAAA,MAAAzD,KAAA,CAAA8K,KAAA,CAAAD,CAAA;UACA,MAAA0B,SAAA,OAAA9I,IAAA,CACAsH,IAAA,CAAArH,OAAA,UAAAiF,cAAA,YACA;UACA4D,SAAA,CAAAC,WAAA;UACAD,SAAA,CAAAV,OAAA,CACAU,SAAA,CAAA7I,OAAA,UAAAiF,cAAA,YACA;UAEA,KAAA4C,UAAA,CAAAX,GAAA,CAAA2B,SAAA,CAAA7I,OAAA;YACA6H,UAAA,CAAAkB,GAAA,CAAAF,SAAA,CAAA7I,OAAA;YAEA,IAAAgJ,aAAA;YACA,IAAAJ,QAAA;cACAI,aAAA,GACAJ,QAAA,CAAA5I,OAAA,OAAA6I,SAAA,CAAA7I,OAAA;YACA;YACA;cAAAgI,SAAA;cAAAD;YAAA,IAAAD,aAAA,CAAAe,SAAA;YACAjB,IAAA,CAAAjD,IAAA;cACAsE,OAAA,EAAAjB,SAAA;cACAD,UAAA;cACAhB,UAAA,EAAA8B,SAAA;cACAG;YACA;YAEAJ,QAAA,OAAA7I,IAAA,CAAA8I,SAAA;UACA;QACA;QACA,OAAAjB,IAAA;MACA;MAEA,SAAAT,CAAA,MAAAA,CAAA,QAAA7K,KAAA,CAAA8K,KAAA,CAAAzB,MAAA,IAAAwB,CAAA;QACA,MAAAE,IAAA,OAAAtH,IAAA,MAAAzD,KAAA,CAAA8K,KAAA,CAAAD,CAAA;QACAU,UAAA,CAAAkB,GAAA,CAAA1B,IAAA,CAAArH,OAAA;QAEA;UAAAgI,SAAA;UAAAD;QAAA,IAAAD,aAAA,CAAAT,IAAA;QACAO,IAAA,CAAAjD,IAAA;UACAsE,OAAA,EAAAjB,SAAA;UACAD,UAAA;UACAhB,UAAA,EAAAM;QACA;MACA;MAEA,IAAA6B,QAAA;MACA,SAAA/B,CAAA,MAAAA,CAAA,QAAA7K,KAAA,CAAA8K,KAAA,CAAAzB,MAAA,IAAAwB,CAAA;QACA,MAAAE,IAAA,OAAAtH,IAAA,MAAAzD,KAAA,CAAA8K,KAAA,CAAAD,CAAA;QACA;QACA,MAAAgC,UAAA,OAAApJ,IAAA,CACAsH,IAAA,CAAArH,OAAA,UAAAiF,cAAA,YACA;QACA,MAAAmE,QAAA,OAAArJ,IAAA,CACAsH,IAAA,CAAArH,OAAA,KACA,KAAA1D,KAAA,CAAA+M,QAAA,oBACA,KAAApE,cAAA,YACA;QACA,MAAAqE,kBAAA,GACAF,QAAA,CAAAG,WAAA,YAAAH,QAAA,CAAAI,aAAA;QACA,IACAL,UAAA,CAAAX,UAAA,OAAAY,QAAA,CAAAZ,UAAA,MACA,CAAAc,kBAAA,EACA;UACA;UACA,IAAAG,QAAA,OAAA1J,IAAA,CAAAsH,IAAA;UACAoC,QAAA,CAAAC,UAAA,CAAAD,QAAA,CAAAjB,UAAA;UACA,KAAAX,UAAA,CAAAX,GAAA,CAAAuC,QAAA,CAAAzJ,OAAA;YACA6H,UAAA,CAAAkB,GAAA,CAAAU,QAAA,CAAAzJ,OAAA;YAEA;cAAAgI,SAAA;cAAAD;YAAA,IAAAD,aAAA,CAAA2B,QAAA;YACA7B,IAAA,CAAA+B,MAAA,CAAAT,QAAA;cACAD,OAAA,EAAAjB,SAAA;cACAD,UAAA;cACAhB,UAAA,EAAA0C,QAAA;cACAG,YAAA;YACA;YACAV,QAAA;UACA;QACA;QACAA,QAAA;MACA;MAEA,IAAAN,QAAA;MACA,SAAAzB,CAAA,MAAAA,CAAA,GAAAS,IAAA,CAAAjC,MAAA,IAAAwB,CAAA;QACA,IAAA6B,aAAA;QACA,IAAAJ,QAAA;UACAI,aAAA,GACAJ,QAAA,CAAA5I,OAAA,OACA4H,IAAA,CAAAT,CAAA,EAAAJ,UAAA,CAAA/G,OAAA;QACA;QAEA4H,IAAA,CAAAT,CAAA,EAAA6B,aAAA,GAAAA,aAAA;QAEAJ,QAAA,OAAA7I,IAAA,CAAA6H,IAAA,CAAAT,CAAA,EAAAJ,UAAA;MACA;MAEA,OAAAa,IAAA;IACA;IACA;IACAA,KAAA;MACA,MAAAiC,KAAA,QAAAhD,OAAA,CAAAgD,KAAA,CACA,KAAAhH,IAAA,QAAAiH,cAAA,EACA,MAAAjH,IAAA,aAAAiH,cACA;MACAD,KAAA;QAAA,GAAAA,KAAA;QAAAb,aAAA;MAAA;MACA,OAAAa,KAAA;IACA;IACA;IACAE,UAAA;MACA,MAAAA,SAAA;MACA,MAAAC,UAAA,OAAApL,GAAA,CACA,KAAAiI,OAAA,CAAAlD,GAAA,CAAAsG,CAAA,IAAAA,CAAA,CAAAlD,UAAA,CAAA/G,OAAA,GACA;;MAEA;MACA,MAAAqH,IAAA,OAAAtH,IAAA,MAAAzD,KAAA,CAAA8K,KAAA;MACA,MAAA8C,UAAA,GAAA7C,IAAA,CAAAkB,WAAA,UAAA1F,IAAA;MACA,MAAAsH,IAAA,GAAA9C,IAAA,CAAA+C,cAAA;MAEA,MAAAC,kBAAA,OAAAtK,IAAA,CAAAA,IAAA,CAAAuK,GAAA,CAAAH,IAAA,EAAAD,UAAA;MACA,MAAAK,iBAAA,OAAAxK,IAAA,CAAAA,IAAA,CAAAuK,GAAA,CAAAH,IAAA,EAAAD,UAAA;;MAEA;MACA,MAAAM,OAAA,OAAAzK,IAAA,CAAAsK,kBAAA;MACA,IAAAI,oBAAA;MACA,MAAAC,iBAAA,GAAAH,iBAAA,CAAA/B,UAAA;MACA,MAAAmC,oBAAA,OAAAJ,iBAAA,CAAA9B,SAAA;MACA,MAAAmC,oBAAA,SAAAxI,qBAAA,GACAiI,kBAAA,CAAA5B,SAAA,SACA4B,kBAAA,CAAA5B,SAAA;MACA,IAAAmC,oBAAA;QACAJ,OAAA,CAAAd,UAAA,CACAc,OAAA,CAAAhC,UAAA,MACA6B,kBAAA,CAAA5B,SAAA,MACA,KAAArG,qBAAA,UACA;QACAqI,oBAAA,GAAAJ,kBAAA,CAAA5B,SAAA;MACA;QACA+B,OAAA,CAAAd,UAAA,CAAAc,OAAA,CAAAhC,UAAA;MACA;MACAgC,OAAA,CAAA1B,WAAA,MAAAxM,KAAA,CAAAqL,SAAA;;MAEA;MACA,MAAAkD,SAAA,GACAJ,oBAAA,GAAAC,iBAAA,GAAAC,oBAAA;MACA,SAAAxD,CAAA,MAAAA,CAAA,GAAA0D,SAAA,IAAA1D,CAAA;QACA;QACA,IAAAqD,OAAA,CAAAjC,WAAA,OAAAgC,iBAAA,CAAAhC,WAAA;UACAwB,SAAA,CAAApF,IAAA;YACA0C,IAAA,EAAAmD,OAAA,CAAAhC,UAAA;YACAlB,IAAA,EAAAkD,OAAA,CAAAxK,OAAA;YACA+G,UAAA,MAAAhH,IAAA,CAAAyK,OAAA;YACAM,QAAA,EAAAd,UAAA,CAAA9C,GAAA,CAAAsD,OAAA,CAAAxK,OAAA;UACA;QACA;UACA+J,SAAA,CAAApF,IAAA;YACA0C,IAAA;YACAC,IAAA,EAAAkD,OAAA,CAAAxK,OAAA;YACA+G,UAAA,MAAAhH,IAAA,CAAAyK,OAAA;YACAM,QAAA;UACA;QACA;QAEAN,OAAA,CAAAd,UAAA,CAAAc,OAAA,CAAAhC,UAAA;MACA;MAEA,OAAAuB,SAAA;IACA;IACA;IACAgB,iBAAA;MACA,MAAAC,WAAA,OAAA9K,GAAA;MACA,WAAA+K,QAAA,SAAAlB,SAAA;QACAiB,WAAA,CAAAE,GAAA,CAAAD,QAAA,CAAAlE,UAAA,CAAA/G,OAAA,IAAAiL,QAAA,CAAAH,QAAA;MACA;MACA,OAAAE,WAAA;IACA;IACA;IACAG,aAAA;MACA,MAAA9D,IAAA,OAAAtH,IAAA,MAAAzD,KAAA,CAAA8K,KAAA;MACA,MAAA8C,UAAA,GAAA7C,IAAA,CAAAkB,WAAA,UAAA1F,IAAA;MACA,MAAAsH,IAAA,GAAA9C,IAAA,CAAA+C,cAAA;MACA,MAAAG,iBAAA,OAAAxK,IAAA,CAAAA,IAAA,CAAAuK,GAAA,CAAAH,IAAA,EAAAD,UAAA;MAEA,MAAAkB,SAAA,QAAAhI,MAAA,CAAAmH,iBAAA,CAAAhC,WAAA;MACA,MAAA8C,QAAA,GAAAd,iBAAA,CAAAH,cAAA;MACA,UAAAgB,SAAA,IAAAC,QAAA;IACA;IACAC,aAAA;MACA;MACA,YAAAvK,aAAA,QAAA9C,MAAA,CAAAI,UAAA,QAAAJ,MAAA,CAAAC,OAAA;IACA;IACAqN,QAAA;MACA;MACA,OACA,KAAA7M,KAAA,UAAAT,MAAA,CAAAK,iBAAA,IACA,KAAAI,KAAA,UAAAT,MAAA,CAAAM,mBAAA;IAEA;IACAiN,WAAA;MACA;MACA,YAAA9M,KAAA,UAAAT,MAAA,CAAAO,cAAA;IACA;IACAzF,QAAA;MACA,OAAAA,OAAA,MAAA0S,QAAA;IACA;IACAC,QAAA;MACA,YAAA1H,QAAA,EAAAuB,GAAA,UAAAjJ,KAAA,CAAAqP,OAAA;IACA;IACArD,gBAAA;MACA,YAAAhM,KAAA,CAAAC,IAAA,KAAAlC,UAAA,CAAAuR,cAAA,UAAAtP,KAAA,CAAAC,IAAA;IACA;IACAmM,SAAA;MACA,YAAApM,KAAA,CAAAC,IAAA,KAAAlC,UAAA,CAAAwR,GAAA;IACA;IACA1H,QAAA;MACA,YAAA7H,KAAA,CAAAC,IAAA,KAAAlC,UAAA,CAAA8K,KAAA;IACA;IACA5B,SAAA;MACA,YAAAjH,KAAA,CAAAwP,YAAA;IACA;IACA5D,gBAAA;MACA,YAAA5L,KAAA,CAAAyP,gBAAA;IACA;IACAC,YAAA;MACA,OAAAxP,MAAA,CAAAyP,MAAA,MAAAC,eAAA,EACAvI,GAAA,CAAAsD,CAAA,IAAAA,CAAA,CAAAkF,IAAA,EACAnF,MAAA,CAAArK,OAAA;IACA;IACAyP,wBAAA;MACA,SAAAC,sBAAA,cAAAC,SAAA;MAEA,SAAA7M,cAAA,CAAAkG,MAAA;MAEA,MAAAwG,IAAA,QAAAD,eAAA,MAAAzM,cAAA,KAAA0M,IAAA;MACA,YAAAI,OAAA,CAAAJ,IAAA,IAAAA,IAAA,CAAA5G,GAAA;IACA;IACAiH,oBAAA;MACA,MAAAC,KAAA;MACA,IAAAC,GAAA,EAAAjL,MAAA,EAAAkL,aAAA;MACA,SAAAjL,QAAA;QACAgL,GAAA,QAAA9K,SAAA,CAAAxC,GAAA;QACAqC,MAAA,QAAAI,OAAA,CAAAzC,GAAA,QAAAwC,SAAA,CAAAxC,GAAA;QACAuN,aAAA,QAAA/K,SAAA,CAAAxC,GAAA,SAAAwN,UAAA,IAAAjH,MAAA;MACA;QACA+G,GAAA,QAAA3K,iBAAA,CAAA3C,GAAA;QACAqC,MAAA,QAAAM,iBAAA,CAAA8K,OAAA;QACAF,aAAA,QAAA5K,iBAAA,CAAA3C,GAAA,SAAAwN,UAAA,IAAAjH,MAAA;MACA;MAEA,IAAAgH,aAAA;QACAF,KAAA,CAAAC,GAAA,WAAAA,GAAA,WAAAI,cAAA,aAAA1L,gBAAA;MACA;QACAqL,KAAA,CAAAC,GAAA,WAAAA,GAAA,WAAAI,cAAA;MACA;MACAL,KAAA,CAAAhL,MAAA,WAAAA,MAAA,WAAAqL,cAAA;MACA,OAAAL,KAAA;IACA;IACAM,6BAAA;MACA,MAAAN,KAAA;MACA,IAAAC,GAAA;QACAjL,MAAA;MACA,SAAAC,QAAA;QACAgL,GAAA,QAAA9K,SAAA,CAAAxC,GAAA;QACAqC,MAAA,QAAAI,OAAA,CAAAzC,GAAA,QAAAwC,SAAA,CAAAxC,GAAA;MACA;MACAqN,KAAA,CAAAC,GAAA,WAAAA,GAAA;MACAD,KAAA,CAAAhL,MAAA,WAAAA,MAAA;MACA,OAAAgL,KAAA;IACA;IACA;IACAP,gBAAA;MACA,MAAAc,MAAA;;MAEA;MACA,SAAA1Q,KAAA,CAAAC,IAAA,KAAAlC,UAAA,CAAA8K,KAAA;QACA,WAAAE,MAAA,SAAA/I,KAAA,CAAAgJ,SAAA;UACA,MAAAvB,mBAAA,QAAAmB,wBAAA,CAAAG,MAAA;UACA,IAAAtB,mBAAA;YACA;YACA,MAAAkJ,yBAAA,QAAAC,wBAAA,CACA,KAAAvN,gBAAA,CAAA0F,MAAA,GAAAlC,kBACA;YACA,MAAAgK,qBAAA,GACA9H,MAAA,UAAArB,QAAA,CAAAuB,GAAA,GACA,KAAA2H,wBAAA,MAAA/J,kBAAA,IACA;;YAEA;YACA;YACA,MAAAxE,YAAA,QAAAyO,iCAAA;cACArJ,mBAAA;cACAsJ,0BAAA;cACAJ,yBAAA,EAAAA,yBAAA;cACAE,qBAAA,EAAAA,qBAAA;cACAG,eAAA,EACAjI,MAAA,UAAArB,QAAA,CAAAuB,GAAA,GACA;gBACA3E,UAAA,OAAAA,UAAA;gBACAC,YAAA,OAAAA;cACA,IACA,KAAAlB,gBAAA,CAAA0F,MAAA,GAAAiI,eAAA,IAAA9M;YACA;YAEAwM,MAAA,CAAA3H,MAAA;cACA,QAAA/I,KAAA,CAAAgJ,SAAA,CAAAD,MAAA;cACA1G,YAAA,EAAAA;YACA;UACA;YACAqO,MAAA,CAAA3H,MAAA;cACA,QAAA/I,KAAA,CAAAgJ,SAAA,CAAAD,MAAA;cACA1G,YAAA,MAAAC,GAAA;YACA;UACA;QACA;QACA,OAAAoO,MAAA;MACA;;MAEA;MACA,SAAA1Q,KAAA,CAAAiR,wBAAA,UAAA7B,OAAA;QACA,MAAAY,SAAA,GAAA/L,YAAA,MAAAiN,YAAA;QACA,MAAAnI,MAAA,QAAArB,QAAA,EAAAuB,GAAA,IAAA+G,SAAA;QACA,IAAAjH,MAAA,SAAA/I,KAAA,CAAAgJ,SAAA;UACA,MAAA6G,IAAA;YACA,QAAA7P,KAAA,CAAAgJ,SAAA,CAAAD,MAAA,EAAA8G,IAAA;YACA5G,GAAA,EAAAF;UACA;UACA2H,MAAA,CAAA3H,MAAA;YACA,QAAA/I,KAAA,CAAAgJ,SAAA,CAAAD,MAAA;YACA1G,YAAA,MAAAC,GAAA,CACA,KAAAe,gBAAA,CAAA0F,MAAA,GAAA1G,YAAA,EAAAgF,GAAA,CAAA8J,CAAA,IACA,IAAA1N,IAAA,CAAA0N,CAAA,EAAAzN,OAAA,EACA,CACA;YACAnB,QAAA,MAAAD,GAAA,CACA,KAAAe,gBAAA,CAAA0F,MAAA,GAAAxG,QAAA,EAAA8E,GAAA,CAAA8J,CAAA,IACA,IAAA1N,IAAA,CAAA0N,CAAA,EAAAzN,OAAA,EACA,CACA;YACAmM,IAAA,EAAAA;UACA;QACA;QACA,OAAAa,MAAA;MACA;;MAEA;MACA,WAAAU,CAAA,IAAAlR,MAAA,CAAAmR,IAAA,MAAArR,KAAA,CAAAgJ,SAAA;QACA,MAAAsI,OAAA;UACA,QAAAtR,KAAA,CAAAgJ,SAAA,CAAAoI,CAAA,EAAAvB,IAAA;UACA5G,GAAA,EAAAmI;QACA;QACAV,MAAA,CAAAU,CAAA;UACA,QAAApR,KAAA,CAAAgJ,SAAA,CAAAoI,CAAA;UACA/O,YAAA,MAAAC,GAAA,CACA,KAAAe,gBAAA,CAAA+N,CAAA,GAAA/O,YAAA,EAAAgF,GAAA,CAAA8J,CAAA,IACA,IAAA1N,IAAA,CAAA0N,CAAA,EAAAzN,OAAA,EACA,CACA;UACAnB,QAAA,MAAAD,GAAA,CACA,KAAAe,gBAAA,CAAA+N,CAAA,GAAA7O,QAAA,EAAA8E,GAAA,CAAA8J,CAAA,IACA,IAAA1N,IAAA,CAAA0N,CAAA,EAAAzN,OAAA,EACA,CACA;UACAmM,IAAA,EAAAyB;QACA;MACA;MACA,OAAAZ,MAAA;IACA;IACAtG,IAAA;MACA,IAAAA,GAAA;MACA,YAAAmH,QAAA,EAAAlP,YAAA,UAAAsB,kBAAA;QACA,IAAAtB,YAAA,CAAAmP,IAAA,GAAApH,GAAA;UACAA,GAAA,GAAA/H,YAAA,CAAAmP,IAAA;QACA;MACA;MAEA,OAAApH,GAAA;IACA;IACA;IACAqH,iBAAA;MACA,WAAAnP,GAAA,MAAAtC,KAAA,CAAAiL,KAAA,EAAA5D,GAAA,CAAAqK,CAAA,QAAAjO,IAAA,CAAAiO,CAAA,EAAAhO,OAAA;IACA;IACA;AACA;AACA;AACA;AACA;AACA;AACA;IACA4M,WAAA;MACA,MAAAA,UAAA;MAEA,MAAAqB,YAAA,QAAA3R,KAAA,CAAAqL,SAAA;MACA,MAAAuG,UAAA,QAAA5R,KAAA,CAAAqL,SAAA,QAAArL,KAAA,CAAA+M,QAAA;MACA,MAAA8E,cAAA,GAAAnV,kBAAA,CACAiV,YAAA,EACA,KAAAhJ,cACA;MACA,MAAAmJ,YAAA,GAAApV,kBAAA,CAAAkV,UAAA,OAAAjJ,cAAA;;MAEA;MACA,MAAAoJ,eAAA,QAAApJ,cAAA;MACA,MAAAqJ,gBAAA,GAAAL,YAAA;MACA,IAAAM,UAAA;MACA,IAAAF,eAAA,KAAAC,gBAAA;QACAC,UAAA;MACA;MAEA,MAAAC,aAAA,GAAAtI,WAAA;QACA,SAAAuI,gBAAA,KAAAlU,iBAAA,CAAAmU,eAAA;UACA,QACA;YACAxI,WAAA,EAAAA,WAAA;UACA,GACA;YACAA,WAAA,EAAAA,WAAA;UACA,GACA;YACAA,WAAA,EAAAA,WAAA;UACA,EACA;QACA,gBAAAuI,gBAAA,KAAAlU,iBAAA,CAAAoU,cAAA;UACA,QACA;YACAzI,WAAA,EAAAA,WAAA;UACA,EACA;QACA;QACA;MACA;MAEA,SAAAxH,KAAA,UAAAT,MAAA,CAAAQ,kBAAA;QACA;QACA,SAAA0I,CAAA,MAAAA,CAAA,UAAAA,CAAA;UACA,MAAAjB,WAAA,GAAAiB,CAAA;UACA,IAAAA,CAAA;YACA;YACAyF,UAAA,IAAAjI,IAAA;cACAP,EAAA;cACA8B,WAAA;cACA0I,IAAA,EAAApW,iBAAA,CAAA2O,CAAA,OAAAnF,QAAA,KAAA1H,SAAA,CAAA2H,MAAA;YACA;UACA;YACA2K,UAAA,IAAAjI,IAAA;cACAuB,WAAA;cACA0I,IAAA,EAAApW,iBAAA,CAAA2O,CAAA,OAAAnF,QAAA,KAAA1H,SAAA,CAAA2H,MAAA;YACA;UACA;UACA2K,UAAA,IAAAjI,IAAA,IAAA6J,aAAA,CAAAtI,WAAA;QACA;QACA,OAAA0G,UAAA;MACA;MAEA,IAAAwB,YAAA,IAAAD,cAAA,IAAAC,YAAA;QACA,SAAAjH,CAAA,MAAAA,CAAA,GAAAiH,YAAA,IAAAjH,CAAA;UACAyF,UAAA,IAAAjI,IAAA;YACAuB,WAAA,OAAA5J,KAAA,CAAA+M,QAAA,IAAA+E,YAAA,GAAAjH,CAAA;YACAyH,IAAA,EAAApW,iBAAA,CAAA2O,CAAA,OAAAnF,QAAA,KAAA1H,SAAA,CAAA2H,MAAA;UACA;UACA2K,UAAA,IAAAjI,IAAA,CACA,GAAA6J,aAAA,MAAAlS,KAAA,CAAA+M,QAAA,IAAA+E,YAAA,GAAAjH,CAAA,EACA;QACA;QACA,SAAAA,CAAA,MAAAA,CAAA,QAAAgH,cAAA,IAAAhH,CAAA;UACA,MAAA0H,SAAA,GAAA1H,CAAA,GAAAoH,UAAA;UACA3B,UAAA,IAAAjI,IAAA;YACAuB,WAAA,EAAA2I,SAAA;YACAD,IAAA,EAAApW,iBAAA,CACA2V,cAAA,GAAAU,SAAA,EACA,KAAA7M,QAAA,KAAA1H,SAAA,CAAA2H,MACA;UACA;UACA2K,UAAA,IAAAjI,IAAA,IAAA6J,aAAA,CAAAK,SAAA;QACA;MACA;QACA,SAAA1H,CAAA,MAAAA,CAAA,QAAA7K,KAAA,CAAA+M,QAAA,IAAAlC,CAAA;UACA,MAAA0H,SAAA,GAAA1H,CAAA,GAAAoH,UAAA;UACA,MAAAO,UAAA,QAAAxS,KAAA,CAAAqL,SAAA,GAAAkH,SAAA;UACA,MAAAE,YAAA,GAAA/V,kBAAA,CACA8V,UAAA,EACA,KAAA7J,cACA;UAEA2H,UAAA,IAAAjI,IAAA;YACAuB,WAAA,EAAA2I,SAAA;YACAD,IAAA,EAAApW,iBAAA,CACAuW,YAAA,EACA,KAAA/M,QAAA,KAAA1H,SAAA,CAAA2H,MACA;UACA;UACA2K,UAAA,IAAAjI,IAAA,IAAA6J,aAAA,CAAAK,SAAA;QACA;QACA,IAAAN,UAAA;UACA,MAAAQ,YAAA,GAAA/V,kBAAA,CACA,KAAAsD,KAAA,CAAAqL,SAAA,QAAArL,KAAA,CAAA+M,QAAA,QACA,KAAApE,cACA;UACA2H,UAAA,IAAAjI,IAAA;YACAuB,WAAA,OAAA5J,KAAA,CAAA+M,QAAA;YACAuF,IAAA,EAAApW,iBAAA,CACAuW,YAAA,EACA,KAAA/M,QAAA,KAAA1H,SAAA,CAAA2H,MACA;UACA;UACA2K,UAAA,IAAAjI,IAAA,IAAA6J,aAAA,MAAAlS,KAAA,CAAA+M,QAAA;QACA;QACAuD,UAAA;MACA;MAEA,OAAAA,UAAA;IACA;IACA;IACArF,MAAA;MACA,gBAAAqF,UAAA,aAAAA,UAAA;IACA;IACA6B,iBAAA;MACA,YAAAnS,KAAA,CAAA0S,aAAA,IAAAzU,iBAAA,CAAAmU,eAAA;IACA;IACA5B,eAAA;MACA,SAAA2B,gBAAA,KAAAlU,iBAAA,CAAAmU,eAAA;QACA,OAAAvI,IAAA,CAAAuB,KAAA,MAAApG,WAAA;MACA,gBAAAmN,gBAAA,KAAAlU,iBAAA,CAAAoU,cAAA;QACA,OAAAxI,IAAA,CAAAuB,KAAA,MAAApG,WAAA;MACA,gBAAAmN,gBAAA,KAAAlU,iBAAA,CAAA0U,QAAA;QACA,YAAA3N,WAAA;MACA;MACA,OAAA6E,IAAA,CAAAuB,KAAA,MAAApG,WAAA;IACA;IACA2D,eAAA;MACA,uBAAAnD,WAAA;QACA,WAAA/B,IAAA,GAAAmP,iBAAA;MACA;MAEA,SAAA5S,KAAA,CAAAC,IAAA,KAAAlC,UAAA,CAAAwR,GAAA;QACA,YAAA/J,WAAA,CAAAqN,MAAA;MACA;;MAEA;MACA;MACA;MACA,OACAxT,KAAA,MAAAW,KAAA,CAAA8K,KAAA,KAAAgI,EAAA,MAAAtN,WAAA,CAAAuN,KAAA,EAAAC,SAAA;MAAA;IAEA;IACAC,iBAAA;MACA,YAAAvL,QAAA,SAAAA,QAAA,CAAAuB,GAAA,SAAA2G,eAAA;IACA;IACAsD,eAAA;MACA,YAAAhN,kBAAA;IACA;IACAiN,gBAAA;MACA,OAAAtJ,IAAA,CAAAuJ,IAAA,MAAAlN,kBAAA,SAAAC,iBAAA;IACA;IACAqH,eAAA;MACA,YAAA/Q,OAAA,QAAA+J,aAAA;IACA;IACA6M,YAAA;MACA,SAAArT,KAAA,CAAAqK,QAAA;QACA,MAAAiJ,OAAA,OAAA7P,IAAA,MAAAzD,KAAA,CAAA8K,KAAA,MAAA9K,KAAA,CAAA8K,KAAA,CAAAzB,MAAA;QACA,MAAA6E,OAAA,OAAAzK,IAAA,MAAAzD,KAAA,CAAA8K,KAAA;QACA,MAAA8C,UAAA,GAAAM,OAAA,CAAAjC,WAAA,UAAA1F,IAAA;QACA,MAAAsH,IAAA,GAAAK,OAAA,CAAAJ,cAAA;QAEA,MAAAG,iBAAA,OAAAxK,IAAA,CAAAA,IAAA,CAAAuK,GAAA,CAAAH,IAAA,EAAAD,UAAA;QAEA,OAAAK,iBAAA,CAAAvK,OAAA,KAAA4P,OAAA,CAAA5P,OAAA;MACA;MAEA,OACA,KAAA6G,OAAA,CAAAlB,MAAA,SAAA9C,IAAA,aAAAiH,cAAA,QACA,KAAAxN,KAAA,CAAAC,IAAA,KAAAlC,UAAA,CAAA8K,KAAA;IAEA;IACA0K,YAAA;MACA,YAAAhN,IAAA,aAAAvG,KAAA,CAAAC,IAAA,KAAAlC,UAAA,CAAA8K,KAAA;IACA;IACA;IACA2K,SAAA;MACA,YAAAH,WAAA,SAAAE,WAAA;IACA;IAEAE,sBAAA;MACA,OACA,KAAAhX,OAAA,IACA,MAAA2J,qBAAA,KACA,KAAAvD,WAAA,CAAAC,GAAA,WACA,KAAAI,aAAA,CAAAmG,MAAA,QACA,KAAAlG,cAAA,CAAAkG,MAAA;IAEA;IAEA;IACAqK,SAAA;MACA,SAAAjX,OAAA;QACA,aAAA2F,KAAA;UACA,UAAAyF,OAAA,SAAAlG,MAAA,CAAAK,iBAAA;YACA;UACA,UAAAL,MAAA,CAAAK,iBAAA;YACA,MAAA2R,WAAA,QAAA3T,KAAA,CAAAqK,QAAA;YACA,SAAAlG,gBAAA,KAAAtG,iBAAA,CAAA+V,SAAA;cACA,+CAAAD,WAAA;YACA;YACA,+CAAAA,WAAA;UACA,UAAAhS,MAAA,CAAAO,cAAA;YACA;UACA;YACA;QACA;MACA;MAEA,aAAAE,KAAA;QACA,UAAAyF,OAAA,SAAAlG,MAAA,CAAAK,iBAAA;UACA;QACA,UAAAL,MAAA,CAAAK,iBAAA;UACA,MAAA2R,WAAA,QAAA3T,KAAA,CAAAqK,QAAA;UACA,SAAAlG,gBAAA,KAAAtG,iBAAA,CAAA+V,SAAA;YACA,iDAAAD,WAAA;UACA;UACA,iDAAAA,WAAA;QACA,UAAAhS,MAAA,CAAAO,cAAA;UACA;QACA;UACA;MACA;IACA;IACA2R,WAAA;MACA,aAAAjN,SAAA,IAAA3C,YAAA,MAAA6P,wBAAA;IACA;IACAA,yBAAA;MACA,6BAAA1R,KAAA,wBAAAyF,OAAA;IACA;IACAkM,cAAA;MACA,YAAA3S,YAAA,SAAAsS,QAAA,gBAAAG,UAAA;IACA;IAEAG,mBAAA;MACA,MAAAC,WAAA;MACA,SAAAtG,CAAA,MAAAA,CAAA,QAAArC,IAAA,CAAAjC,MAAA,IAAAsE,CAAA;QACA,MAAArD,GAAA,QAAAgB,IAAA,CAAAqC,CAAA;QACA,SAAA+D,CAAA,MAAAA,CAAA,QAAApB,UAAA,IAAAjH,MAAA,IAAAqI,CAAA;UACA,MAAA1G,IAAA,QAAAsF,UAAA,IAAAoB,CAAA;UACAuC,WAAA,CAAA5L,IAAA,MAAA6L,yBAAA,CAAA5J,GAAA,EAAAU,IAAA,EAAA2C,CAAA,EAAA+D,CAAA;QACA;QACA,SAAAA,CAAA,MAAAA,CAAA,QAAApB,UAAA,IAAAjH,MAAA,IAAAqI,CAAA;UACA,MAAA1G,IAAA,QAAAsF,UAAA,IAAAoB,CAAA;UACAuC,WAAA,CAAA5L,IAAA,CACA,KAAA6L,yBAAA,CACA5J,GAAA,EACAU,IAAA,EACA2C,CAAA,EACA+D,CAAA,QAAApB,UAAA,IAAAjH,MACA,CACA;QACA;MACA;MACA,OAAA4K,WAAA;IACA;IACAE,sBAAA;MACA,MAAAF,WAAA;MACA,SAAApJ,CAAA,MAAAA,CAAA,QAAA4C,SAAA,CAAApE,MAAA,IAAAwB,CAAA;QACAoJ,WAAA,CAAA5L,IAAA,CACA,KAAA+L,wBAAA,MAAA3G,SAAA,CAAA5C,CAAA,EAAAJ,UAAA,EAAAI,CAAA,CACA;MACA;MACA,OAAAoJ,WAAA;IACA;IACAI,YAAA;MACA,MAAAC,IAAA;MACA,SAAA3G,CAAA,MAAAA,CAAA,QAAArC,IAAA,CAAAjC,MAAA,IAAAsE,CAAA;QACA,SAAA+D,CAAA,MAAAA,CAAA,QAAAzG,KAAA,CAAA5B,MAAA,IAAAqI,CAAA;UACA4C,IAAA,CAAAjM,IAAA,MAAAkM,cAAA,CAAA7C,CAAA,EAAA/D,CAAA;QACA;MACA;MACA,OAAA2G,IAAA;IACA;IACAE,eAAA;MACA,MAAAF,IAAA;MACA,SAAAzJ,CAAA,MAAAA,CAAA,QAAA4C,SAAA,CAAApE,MAAA,IAAAwB,CAAA;QACA,MAAA/H,GAAA,GAAA+G,IAAA,CAAAuB,KAAA,CAAAP,CAAA;QACA,MAAA9H,GAAA,GAAA8H,CAAA;QACAyJ,IAAA,CAAAjM,IAAA,MAAAkM,cAAA,CAAAzR,GAAA,EAAAC,GAAA;MACA;MACA,OAAAuR,IAAA;IACA;IAEA;IACAG,WAAA;MACA;QACA;QACA,MAAA5M,OAAA,SAAA/G,wBAAA,SAAAmO,OAAA,KACA,KAAA1O,qBAAA;QACA;QACA,KAAA+C,gBAAA,CAAAC;MAAA;IAEA;IAEA;IACA2N,aAAA;MACA,eAAAlR,KAAA,CAAAiJ,GAAA;IACA;IACA;IACA+G,UAAA;MACA,OAAA/L,YAAA,MAAAiN,YAAA;IACA;IACA;IACAnB,uBAAA;MACA,OACA,KAAAC,SAAA,EAAA3G,MAAA,aAAA2G,SAAA,SAAAJ,eAAA;IAEA;IAEA;AACA;AACA;IACA8E,qBAAA;MACA,MAAAA,oBAAA;MACA,KAAApJ,IAAA,CAAAqJ,OAAA,EAAArK,GAAA,EAAAqD,CAAA;QACA+G,oBAAA,CAAArM,IAAA;QACA,IAAAuM,aAAA;QACA,MAAAC,6BAAA,GAAAA,CAAA7J,IAAA,EAAA0G,CAAA;UACA,MAAA3G,IAAA,QAAA+J,iBAAA,CAAApD,CAAA,EAAA/D,CAAA;UACA,KAAA5C,IAAA;UAEA,MAAAgK,OAAA,GACA,KAAA3P,QAAA,IACA,KAAA4P,WAAA,CAAAtD,CAAA,EAAA/D,CAAA,KACA,KAAAtI,QAAA,UAAAV,UAAA,CAAAC,GAAA;UACA,MAAAqQ,UAAA,GACA,KAAA7P,QAAA,IACA,KAAA4P,WAAA,CAAAtD,CAAA,EAAA/D,CAAA,KACA,KAAAtI,QAAA,UAAAV,UAAA,CAAAE,MAAA;;UAEA;UACA,IACAkQ,OAAA,IACA,CAAAE,UAAA,KACA,KAAA5S,YAAA,CAAAuI,GAAA,CAAAG,IAAA,CAAArH,OAAA,OACA,KAAAnB,QAAA,CAAAqI,GAAA,CAAAG,IAAA,CAAArH,OAAA,MACA;YACA;YACA,IAAAzD,IAAA,GAAApC,iBAAA,CAAAuG,SAAA;YACA,IAAA2Q,OAAA;cACA9U,IAAA,QAAAkE,gBAAA;YACA;cACAlE,IAAA,QAAAoC,YAAA,CAAAuI,GAAA,CAAAG,IAAA,CAAArH,OAAA,MACA7F,iBAAA,CAAAuG,SAAA,GACAvG,iBAAA,CAAA+V,SAAA;YACA;YAEA,IAAAgB,aAAA,IAAAF,oBAAA,CAAA/G,CAAA;cACA,IAAA+G,oBAAA,CAAA/G,CAAA,EAAAiH,aAAA,EAAA3U,IAAA,KAAAA,IAAA;gBACA;gBACAyU,oBAAA,CAAA/G,CAAA,EAAAiH,aAAA,EAAAM,WAAA;cACA;gBACA;gBACAR,oBAAA,CAAA/G,CAAA,EAAAtF,IAAA;kBACAuB,WAAA,EAAAoB,IAAA,CAAApB,WAAA;kBACAsL,WAAA;kBACAjV;gBACA;gBACA2U,aAAA;cACA;YACA;cACA;cACAF,oBAAA,CAAA/G,CAAA,EAAAtF,IAAA;gBACAuB,WAAA,EAAAoB,IAAA,CAAApB,WAAA;gBACAsL,WAAA;gBACAjV;cACA;YACA;UACA,WAAA2U,aAAA,IAAAF,oBAAA,CAAA/G,CAAA;YACA;YACAiH,aAAA;UACA;QACA;QACA,SAAAlD,CAAA,MAAAA,CAAA,QAAApB,UAAA,IAAAjH,MAAA,IAAAqI,CAAA;UACAmD,6BAAA,MAAAvE,UAAA,IAAAoB,CAAA,GAAAA,CAAA;QACA;QACA,IAAAkD,aAAA,IAAAF,oBAAA,CAAA/G,CAAA;UACAiH,aAAA;QACA;QACA,SAAAlD,CAAA,MAAAA,CAAA,QAAApB,UAAA,IAAAjH,MAAA,IAAAqI,CAAA;UACAmD,6BAAA,CACA,KAAAvE,UAAA,IAAAoB,CAAA,GACAA,CAAA,QAAApB,UAAA,IAAAjH,MACA;QACA;MACA;MACA,OAAAqL,oBAAA;IACA;IAEA;IACAS,8BAAA;MACA,YAAAzF,WAAA,CAAArG,MAAA,aAAA+L,4BAAA;IACA;IACAC,oBAAA;MACA,OACA,MAAA9T,yBAAA,IACA,KAAAZ,yBAAA,KACA,KAAAkH,OAAA,UAAAA,OAAA,UAAAoL,gBAAA;IAEA;IAEA;IACAqC,cAAA;MACA,MAAAC,OAAA;MACA,IAAAC,iBAAA;MACA,SAAA3K,CAAA,MAAAA,CAAA,QAAAS,IAAA,CAAAjC,MAAA,IAAAwB,CAAA;QACA0K,OAAA,CAAAlN,IAAA,CAAAmN,iBAAA;QACA,UAAAlK,IAAA,CAAAT,CAAA,EAAA6B,aAAA;UACA8I,iBAAA,SAAAzQ,eAAA;QACA;QACAyQ,iBAAA,SAAAvQ,QAAA,CAAAC,KAAA;MACA;MACA,OAAAqQ,OAAA;IACA;EACA;EACAE,OAAA;IACA,GAAAtX,YAAA;IACA,GAAAC,UAAA;IAEA;IACA;IACA;;IAEA;IACAsX,0BAAA9I,QAAA,EAAAhD,WAAA;MACA,OAAAxN,kBAAA,MAAAkP,IAAA,CAAAsB,QAAA,EAAAnC,UAAA,EAAAb,WAAA;IACA;IACA;IACAkL,kBAAAhS,GAAA,EAAAC,GAAA;MACA,SAAA/C,KAAA,CAAAqK,QAAA;QACA,MAAAI,UAAA,QAAAgD,SAAA,CAAA3K,GAAA,OAAAC,GAAA,GAAA0H,UAAA;QACA,KAAAA,UAAA;QACA,WAAAhH,IAAA,CAAAgH,UAAA;MACA;QACA,YAAAkL,uBAAA,CACA,KAAAnI,cAAA,QAAAjH,IAAA,GAAAxD,GAAA,EACAD,GACA;MACA;IACA;IACA8S,iBAAA7S,GAAA;MACA,OAAA1C,OAAA,MAAAiL,IAAA,CAAAvI,GAAA,GAAA2J,aAAA;IACA;IACA;IACAiJ,wBAAA/I,QAAA,EAAAiJ,SAAA;MACA,MAAAC,cAAA,QAAAxF,UAAA,IAAAjH,MAAA;MACA,MAAA0M,YAAA,GAAAF,SAAA,QAAAvF,UAAA,IAAAjH,MAAA;MACA,MAAA2B,IAAA,GAAA+K,YAAA,GACA,KAAAzF,UAAA,IAAAuF,SAAA,IACA,KAAAvF,UAAA,IAAAuF,SAAA,QAAAvF,UAAA,IAAAjH,MAAA;MACA,IAAA2M,gBAAA,GAAApJ,QAAA;MACA,IAAAkJ,cAAA;QACA,IAAAC,YAAA;UACAC,gBAAA,GAAApJ,QAAA;QACA,WAAAA,QAAA,UAAArC,OAAA,CAAAlB,MAAA;UACA;QACA;MACA;MACA,MAAAiB,GAAA,QAAAC,OAAA,CAAAyL,gBAAA;MACA,KAAA1L,GAAA,KAAAU,IAAA;MACA,IAAAV,GAAA,CAAAgD,YAAA;QACA;MACA;MAEA,MAAAvC,IAAA,GAAA3O,kBAAA,CAAAkO,GAAA,CAAAG,UAAA,EAAAO,IAAA,CAAApB,WAAA;MACA,SAAAgC,eAAA;QACA;QACA,IACA,KAAAxJ,KAAA,UAAAT,MAAA,CAAAQ,kBAAA,IACA,KAAAnC,KAAA,CAAAiL,KAAA,EAAA5B,MAAA,MACA;UACA,UAAAoI,gBAAA,CAAA7G,GAAA,CAAAG,IAAA,CAAArH,OAAA;YACA;UACA;QACA;MACA;QACA;QACA,IAAAsH,IAAA,CAAApB,WAAA,QAAAoB,IAAA,CAAApB,WAAA,SAAA5J,KAAA,CAAA+M,QAAA;UACA;QACA;MACA;MACA,OAAAhC,IAAA;IACA;IACA;;IAEA;IACA;IACA;IACAkL,oBAAAC,CAAA,EAAApO,EAAA;MACA,SAAA3E,cAAA,CAAAkG,MAAA;QACA,SAAAjH,KAAA,UAAA4M,YAAA;UACA,KAAA5M,KAAA,QAAAT,MAAA,CAAAE,mBAAA;QACA;QAEA,KAAAqB,aAAA,GAAA4E,EAAA;MACA;IACA;IACAqO,qBAAAD,CAAA;MACA,SAAA/S,cAAA,CAAAkG,MAAA;QACA,SAAAjH,KAAA,UAAAT,MAAA,CAAAE,mBAAA;UACA,KAAAO,KAAA,QAAA4M,YAAA;QACA;QAEA,KAAA9L,aAAA;MACA;IACA;IACAkT,gBAAAF,CAAA,EAAApO,EAAA;MACA,KAAA1F,KAAA,QAAAT,MAAA,CAAAG,mBAAA;MACA,KAAAoB,aAAA;MAEA,SAAAgG,iBAAA,CAAA0B,GAAA,CAAA9C,EAAA;QACA;QACA,KAAA3E,cAAA,QAAAA,cAAA,CAAAuH,MAAA,CAAAC,CAAA,IAAAA,CAAA,IAAA7C,EAAA;;QAEA;QACA,SAAA3E,cAAA,CAAAkG,MAAA;UACA,KAAAjH,KAAA,QAAA4M,YAAA;QACA;MACA;QACA;QACA,KAAA7L,cAAA,CAAAkF,IAAA,CAAAP,EAAA;MACA;MAEAoO,CAAA,CAAAG,eAAA;IACA;IACAC,oBAAAJ,CAAA;MACA;MACA;MACA,IACAA,CAAA,EAAAK,MAAA,EAAAC,sBAAA,EAAA1O,EAAA,iCACAoO,CAAA,EAAAK,MAAA,EAAAE,UAAA,EAAAA,UAAA,EAAA3O,EAAA,iCACAoO,CAAA,EAAAK,MAAA,EAAAG,SAAA,EAAAC,QAAA;MAAA,EAEA;MAEA,SAAAvU,KAAA,UAAAT,MAAA,CAAAG,mBAAA;QACA,KAAAM,KAAA,QAAA4M,YAAA;MACA;MAEA,KAAA7L,cAAA;;MAEA;MACA,KAAAH,gBAAA;MACA,KAAA4T,gBAAA;IACA;IAEA3G,QAAAJ,IAAA;MACA,OAAAA,IAAA,CAAA5G,GAAA,IAAA4G,IAAA,CAAAgH,SAAA;IACA;IACA;;IAEA;IACA;IACA;;IAEA;IACAC,eAAA;MACA,SAAA9V,YAAA;QACA,KAAAqC,gBAAA,QAAArD,KAAA,CAAAgJ,SAAA;QACA;MACA;MAEA,IAAA+N,OAAA,EAAAC,OAAA;MACA,SAAAhX,KAAA,CAAAC,IAAA,KAAAlC,UAAA,CAAA8K,KAAA;QACA,SAAA7I,KAAA,CAAA8K,KAAA,CAAAzB,MAAA;UACA;UACA0N,OAAA,OAAAtT,IAAA,MAAAzD,KAAA,CAAA8K,KAAA;UACAkM,OAAA,OAAAvT,IAAA,MAAAzD,KAAA,CAAA8K,KAAA,MAAA9K,KAAA,CAAA8K,KAAA,CAAAzB,MAAA;UACA2N,OAAA,CAAAlL,OAAA,CAAAkL,OAAA,CAAAjL,OAAA;;UAEA;UACAgL,OAAA,GAAAla,aAAA,CACA,KAAAmD,KAAA,CAAA8K,KAAA,EACAiM,OAAA,EACA,KAAAnW,UAAA,EACA,IACA;UACAoW,OAAA,GAAAna,aAAA,CACA,KAAAmD,KAAA,CAAA8K,KAAA,EACAkM,OAAA,EACA,KAAApW,UAAA,EACA,IACA;QACA;MACA;QACA,SAAA2J,OAAA,CAAAlB,MAAA;UACA;UACA0N,OAAA,OAAAtT,IAAA,MAAA8G,OAAA,IAAAE,UAAA;UACAuM,OAAA,OAAAvT,IAAA,MAAA8G,OAAA,MAAAA,OAAA,CAAAlB,MAAA,MAAAoB,UAAA;UACAuM,OAAA,CAAAlL,OAAA,CAAAkL,OAAA,CAAAjL,OAAA;QACA;MACA;MAEA,KAAAgL,OAAA,KAAAC,OAAA;;MAEA;MACA,MAAAC,GAAA,cACA,KAAAjX,KAAA,CAAAiJ,GACA,sBAAA8N,OAAA,CAAAG,WAAA,cAAAF,OAAA,CAAAE,WAAA;MACAna,GAAA,CAAAka,GAAA,EACAE,IAAA,CAAAnO,SAAA;QACA,KAAA3F,gBAAA,GAAA2F,SAAA;QACA,KAAAoO,qBAAA;MACA,GACAC,KAAA,CAAAC,GAAA;QACA,KAAAC,SAAA,CACA,oEACA;MACA;IACA;IACA;IACAH,sBAAA;MACA,MAAA5T,WAAA,OAAAC,IAAA,GAAAC,OAAA;MACA,KAAAJ,gBAAA,CAAAC,OAAA;MACA,KAAAD,gBAAA,CAAAE,WAAA,GAAAA,WAAA;MAEA,KAAAgU,OAAA,CACAC,GAAA,CACA,CAAAnM,IAAA,EAAAL,KAAA,EAAA2E,eAAA,EAAAvF,QAAA,EAAA3F,YAAA;QACA;QACA,MAAAgT,YAAA,GAAAC,OAAA;UACA,MAAAC,KAAA,GAAA/N,IAAA,CAAAuB,KAAA,CAAAuM,OAAA;UACA,MAAAE,OAAA,GAAAhO,IAAA,CAAAuB,KAAA,EAAAuM,OAAA,GAAAC,KAAA;UACA;YAAAA,KAAA;YAAAC;UAAA;QACA;QACA,MAAAzb,kBAAA,GAAAA,CAAA2O,IAAA,EAAAnB,WAAA;UACA;YAAAgO,KAAA;YAAAC;UAAA,IAAAH,YAAA,CAAA9N,WAAA;UACA,MAAAkO,OAAA,OAAArU,IAAA,CAAAsH,IAAA;UACA+M,OAAA,CAAAC,QAAA,CAAAD,OAAA,CAAAE,QAAA,KAAAJ,KAAA;UACAE,OAAA,CAAAG,UAAA,CAAAH,OAAA,CAAAI,UAAA,KAAAL,OAAA;UACA,OAAAC,OAAA;QACA;;QAEA;QACA,MAAAhN,KAAA;QACA,IAAAT,QAAA;UACA,WAAAC,GAAA,IAAAgB,IAAA;YACAR,KAAA,CAAAzC,IAAA,CAAAiC,GAAA,CAAAG,UAAA;UACA;QACA;UACA,WAAAH,GAAA,IAAAgB,IAAA;YACA,WAAAN,IAAA,IAAAC,KAAA;cACA;cACA,MAAAF,IAAA,GAAA3O,kBAAA,CACAkO,GAAA,CAAAG,UAAA,EACAO,IAAA,CAAApB,WACA;cACAkB,KAAA,CAAAzC,IAAA,CAAA0C,IAAA;YACA;UACA;QACA;;QAEA;QACA,MAAAoN,SAAA,OAAAvU,GAAA;QACA,WAAAmH,IAAA,IAAAD,KAAA;UACAqN,SAAA,CAAAvJ,GAAA,CAAA7D,IAAA,CAAArH,OAAA,QAAApB,GAAA;;UAEA;UACA,WAAA4H,QAAA,IAAAhK,MAAA,CAAAyP,MAAA,CAAAC,eAAA;YACA;YACA,IACA1F,QAAA,CAAA7H,YAAA,EAAAuI,GAAA,CAAAG,IAAA,CAAArH,OAAA,OACAwG,QAAA,CAAA3H,QAAA,EAAAqI,GAAA,CAAAG,IAAA,CAAArH,OAAA,QAAAgB,YAAA,EACA;cACAyT,SAAA,CAAApb,GAAA,CAAAgO,IAAA,CAAArH,OAAA,IAAA+I,GAAA,CAAAvC,QAAA,CAAA2F,IAAA,CAAA5G,GAAA;cACA;YACA;UACA;QACA;QACA,OAAAkP,SAAA;MACA,GACA,CACA,KAAA5N,OAAA,EACA,KAAAU,KAAA,EACA,KAAA2E,eAAA,EACA,KAAA5P,KAAA,CAAAqK,QAAA,EACA,KAAA3F,YAAA,CAEA,EACAyS,IAAA,CAAAgB,SAAA;QACA;QACA,IAAA3U,WAAA,SAAAF,gBAAA,CAAAE,WAAA;UACA,KAAAG,kBAAA,GAAAwU,SAAA;QACA;MACA,GACAC,OAAA;QACA,SAAA9U,gBAAA,CAAAE,WAAA,KAAAA,WAAA;UACA,KAAAF,gBAAA,CAAAC,OAAA;QACA;MACA;IACA;IACA;IACA2H,6BAAAH,IAAA,EAAAnB,WAAA;MACA,MAAA+D,CAAA,GAAAvR,kBAAA,CAAA2O,IAAA,EAAAnB,WAAA;MACA,YAAAjG,kBAAA,CAAA5G,GAAA,CAAA4Q,CAAA,CAAAjK,OAAA,WAAApB,GAAA;IACA;IACA+V,iBAAAvV,GAAA,EAAAC,GAAA;MACA,SAAAX,KAAA,UAAAT,MAAA,CAAAK,iBAAA,SAAAvF,OAAA;QACA;QACA;MACA;;MAEA;MACA,KAAAoG,WAAA;QAAAC,GAAA;QAAAC;MAAA;MAEA,SAAAX,KAAA,UAAAT,MAAA,CAAAK,iBAAA,SAAAkB,aAAA;QACA;QACA;MACA;MAEA,MAAA6H,IAAA,QAAA+J,iBAAA,CAAAhS,GAAA,EAAAC,GAAA;MACA,KAAAgI,IAAA;;MAEA;MACA,MAAAuN,SAAA,QAAA3U,kBAAA,CAAA5G,GAAA,CAAAgO,IAAA,CAAArH,OAAA,WAAApB,GAAA;MACA,WAAAiW,UAAA,SAAA7I,WAAA;QACA,IAAA4I,SAAA,CAAA1N,GAAA,CAAA2N,UAAA,CAAAtP,GAAA;UACA,KAAAhG,uBAAA,CAAAsV,UAAA,CAAAtP,GAAA;QACA;UACA,KAAAhG,uBAAA,CAAAsV,UAAA,CAAAtP,GAAA;QACA;MACA;IACA;IACA;;IAEA;IACA;IACA;IACA,MAAAX,gBAAA;MACA,KAAA3B,oBAAA;MACA,MAAA5J,GAAA,kBAAAoa,IAAA,CAAAzP,QAAA;QACA,KAAA8Q,WAAA,CAAA9Q,QAAA;MACA;IACA;IACA;IACA+Q,yBAAA;MACA,SAAAzY,KAAA,CAAAC,IAAA,KAAAlC,UAAA,CAAA8K,KAAA;QACA,KAAA6P,0BAAA;QACA,KAAA7R,kBAAA;MACA;MAEA,KAAAxE,YAAA,OAAAC,GAAA;MACA,KAAAC,QAAA,OAAAD,GAAA;MACA,SAAA2Q,gBAAA;QACA,KAAA0F,wBAAA,MAAAjR,QAAA,CAAAuB,GAAA;MACA;IACA;IACA;IACA0P,yBAAA7Q,EAAA;MACA,KAAAzF,YAAA,GACA,IAAAC,GAAA,MAAAsN,eAAA,CAAA9H,EAAA,GAAAzF,YAAA,SAAAC,GAAA;MACA,KAAAC,QAAA,OAAAD,GAAA,MAAAsN,eAAA,CAAA9H,EAAA,GAAAvF,QAAA,SAAAD,GAAA;MACA,KAAAsW,SAAA,YAAAhW,cAAA;IACA;IACA;IACAiW,2BAAAC,SAAA;MACA,OACAA,SAAA,CAAAlP,WAAA,SAAA0G,UAAA,OAAA1G,WAAA,IACAkP,SAAA,CAAAlP,WAAA,IACA,KAAA0G,UAAA,SAAAA,UAAA,IAAAjH,MAAA,MAAAO,WAAA;IAEA;IACA;IACAmP,kBAAAD,SAAA;MACA,MAAA3I,KAAA;MACA,MAAA2F,cAAA,QAAAxF,UAAA,IAAAjH,MAAA;MACA,KAAAyM,cAAA,SAAA+C,0BAAA,CAAAC,SAAA;QACA3I,KAAA,CAAAC,GAAA,WACA0I,SAAA,CAAAlP,WAAA,QAAA0G,UAAA,OAAA1G,WACA,WAAA5E,WAAA;QACAmL,KAAA,CAAAhL,MAAA,WAAA2T,SAAA,CAAA5D,WAAA,WAAAlQ,WAAA;MACA;QACAmL,KAAA,CAAAC,GAAA,gBAAAE,UAAA,IAAAjH,MAAA,MACA,KAAAmH,cACA,aAAA1L,gBAAA,QACAgU,SAAA,CAAAlP,WAAA,QAAA0G,UAAA,OAAA1G,WACA,WAAA5E,WAAA;QACAmL,KAAA,CAAAhL,MAAA,WAAA2T,SAAA,CAAA5D,WAAA,WAAAlQ,WAAA;MACA;MACA,OAAAmL,KAAA;IACA;IACA;IACAW,kCAAA;MACArJ,mBAAA;MACAsJ,0BAAA;MAAA;MACAJ,yBAAA;MAAA;MACAE,qBAAA;MAAA;MACAG,eAAA,GAAAlT,uBAAA;IACA;MACA,MAAAuE,YAAA,OAAAC,GAAA;MAEA,SAAAuI,CAAA,MAAAA,CAAA,QAAAN,OAAA,CAAAlB,MAAA,IAAAwB,CAAA;QACA,MAAAP,GAAA,QAAAC,OAAA,CAAAM,CAAA;QACA,MAAAE,IAAA,GAAAT,GAAA,CAAAG,UAAA;QAEA,IAAAsG,0BAAA;UACA,MAAAiI,OAAA,GAAA5c,kBAAA,CACA2O,IAAA,EACA,KAAAE,KAAA,CAAA5B,MAAA,SAAA8I,gBAAA,MACA;;UAEA;UACA,IAAA8G,uBAAA;UAEA,WAAAjO,IAAA,IAAA6F,qBAAA;YACA,IAAA9F,IAAA,CAAArH,OAAA,MAAAsH,IAAA,IAAAA,IAAA,IAAAgO,OAAA,CAAAtV,OAAA;cACAmN,qBAAA,CAAA7F,IAAA,EAAA2J,OAAA,CAAAxD,CAAA;gBACA9O,YAAA,CAAAoK,GAAA,KAAAhJ,IAAA,CAAA0N,CAAA,EAAAzN,OAAA;cACA;cACA,OAAAmN,qBAAA,CAAA7F,IAAA;cACAiO,uBAAA;cACA;YACA;UACA;UAEA,IAAAA,uBAAA;UAEA,WAAAjO,IAAA,IAAA2F,yBAAA;YACA,IAAA5F,IAAA,CAAArH,OAAA,MAAAsH,IAAA,IAAAA,IAAA,IAAAgO,OAAA,CAAAtV,OAAA;cACAiN,yBAAA,CAAA3F,IAAA,EAAA2J,OAAA,CAAAxD,CAAA;gBACA9O,YAAA,CAAAoK,GAAA,KAAAhJ,IAAA,CAAA0N,CAAA,EAAAzN,OAAA;cACA;cACA,OAAAiN,yBAAA,CAAA3F,IAAA;cACAiO,uBAAA;cACA;YACA;UACA;UAEA,IAAAA,uBAAA;QACA;;QAEA;QACA,MAAAC,cAAA,GAAAlI,eAAA,CAAA1M,UAAA,CAAAyD,OAAA,GACAiJ,eAAA,CAAA1M,UAAA,CAAA0G,IAAA,eACA;;QAEA;QACA,MAAAmO,eAAA,GAAAxb,mBAAA,CACAqT,eAAA,CAAAzM,YAAA,CAAA8G,SACA;QACA,MAAA+N,aAAA,GAAA3b,gBAAA,CAAAC,mBAAA,CAAAqN,IAAA;QACA,MAAAsO,qBAAA,GAAAha,KAAA,CACAyT,EAAA,IAAAsG,aAAA,IAAAD,eAAA,SAAA3T,WAAA,CAAAuN,KAAA,EACAuG,MAAA;QACA,IAAAvM,QAAA,GACAiE,eAAA,CAAAzM,YAAA,CAAAgV,OAAA,GACAvI,eAAA,CAAAzM,YAAA,CAAA8G,SAAA;QACA,IAAA0B,QAAA,OAAAA,QAAA;QACA,MAAAyM,mBAAA,GAAApd,kBAAA,CACAid,qBAAA,EACAtM,QACA;QAEA,SAAA0M,CAAA,MAAAA,CAAA,QAAAxO,KAAA,CAAA5B,MAAA,IAAAoQ,CAAA;UACA,MAAAC,SAAA,QAAA/D,uBAAA,CAAA9K,CAAA,EAAA4O,CAAA;UACA,KAAAC,SAAA;UACA,MAAAV,OAAA,GAAA5c,kBAAA,CACAsd,SAAA,EACA,KAAAvH,gBAAA,KACA;;UAEA;UACA,IAAAnB,eAAA,CAAAzM,YAAA,CAAAwD,OAAA;YACA,IACAiR,OAAA,CAAAtV,OAAA,MAAA2V,qBAAA,CAAA3V,OAAA,MACAgW,SAAA,CAAAhW,OAAA,MAAA8V,mBAAA,CAAA9V,OAAA,IACA;cACA;YACA;UACA;;UAEA;UACA,MAAAuE,KAAA,GAAAR,mBAAA,CAAAoD,CAAA,GAAA8O,SAAA,CAAAzD,CAAA;YACA,MAAA0D,iBAAA,OAAAnW,IAAA,CACAyS,CAAA,CAAAwD,SAAA,CAAAhW,OAAA,KAAAwV,cACA;YACA,MAAAW,eAAA,OAAApW,IAAA,CACAyS,CAAA,CAAA8C,OAAA,CAAAtV,OAAA,KAAAwV,cACA;YAEA,MAAAY,YAAA,GACA3d,WAAA,CAAA6c,OAAA,EAAAY,iBAAA,UACAzd,WAAA,CAAAud,SAAA,EAAAG,eAAA;YACA,QAAAC,YAAA,KAAA5D,CAAA,CAAA6D,IAAA;UACA;UACA,IAAA9R,KAAA;YACA5F,YAAA,CAAAoK,GAAA,CAAAiN,SAAA,CAAAhW,OAAA;UACA;QACA;MACA;MACA,OAAArB,YAAA;IACA;IACA;IACA2X,6BAAA;MACA;MACA,KAAA3X,YAAA,OAAAC,GAAA;MACA,MAAA2X,eAAA,QAAAnJ,iCAAA;QACArJ,mBAAA,OAAAA,mBAAA;QACAuJ,eAAA;UACA1M,UAAA,OAAAA,UAAA;UACAC,YAAA,OAAAA;QACA;MACA;MAEA,MAAA2V,aAAA,GAAAld,gBAAA,CACA,IAAAyG,IAAA,MAAAzD,KAAA,CAAA8K,KAAA,MACA,KAAAvE,IAAA,QAAAiH,cACA;MACA,MAAA2M,WAAA,GAAAnd,gBAAA,CAAAkd,aAAA,OAAA1M,cAAA;MACA,KAAA4M,mBAAA,CAAAH,eAAA,EAAAC,aAAA,EAAAC,WAAA;IACA;IACA;IACAC,oBAAA/X,YAAA,EAAAqX,SAAA,EAAAV,OAAA;MACA,KAAAtW,uBAAA;MACA,KAAAD,wBAAA;MAEA,IAAA4X,UAAA;MACA,IAAAC,cAAA;MACA,IACAjY,YAAA,CAAAmP,IAAA,GAAA8I,cAAA,GAAAD,UAAA,GACA,KAAA1X,WAAA,EACA;QACA2X,cAAA,GAAAjY,YAAA,CAAAmP,IAAA,GAAA6I,UAAA,QAAA1X,WAAA;MACA;MACA,IAAAyE,iBAAA,OAAA/E,YAAA;MACA+E,iBAAA,GAAAA,iBAAA,CAAAsD,MAAA,CAAAyG,CAAA,IACAlU,aAAA,CAAAkU,CAAA,EAAAuI,SAAA,EAAAV,OAAA,CACA;MAEA,SAAAnO,CAAA,MAAAA,CAAA,GAAAzD,iBAAA,CAAAiC,MAAA,GAAAiR,cAAA,QAAAzP,CAAA;QACA,MAAA0P,OAAA,GAAAC,UAAA;UACA,WAAArJ,CAAA,IAAA/J,iBAAA,CAAAmG,KAAA,CACA1C,CAAA,GAAAyP,cAAA,EACAzP,CAAA,GAAAyP,cAAA,GAAAA,cACA;YACA,KAAAjY,YAAA,CAAAoK,GAAA,CAAA0E,CAAA;UACA;UACA,KAAA9O,YAAA,OAAAC,GAAA,MAAAD,YAAA;UACA,IAAAwI,CAAA,IAAAzD,iBAAA,CAAAiC,MAAA,GAAAiR,cAAA;YACA;YACA,KAAAjY,YAAA,OAAAC,GAAA,CAAAD,YAAA;YACA,KAAAI,wBAAA,CAAA4F,IAAA,CACAmS,UAAA;cACA,KAAA9X,uBAAA;cAEA,SAAAxB,YAAA;gBACA,KAAAuZ,QAAA;cACA;cACA,KAAA7X,cAAA;YACA,OACA;UACA;QACA,GAAAiI,CAAA,GAAAwP,UAAA;QAEA,KAAA5X,wBAAA,CAAA4F,IAAA,CAAAkS,OAAA;MACA;IACA;IACAG,qBAAA;MACA,WAAAH,OAAA,SAAA9X,wBAAA;QACAkY,YAAA,CAAAJ,OAAA;MACA;MACA,KAAA7X,uBAAA;IACA;IACA,MAAAkY,mBAAAC,YAAA;MAAA/a,IAAA;MAAAgb,KAAA;IAAA;MACA,IAAAC,OAAA;MAEA,IAAA9a,IAAA;MACA;MACA,SAAA4H,OAAA;QACA5H,IAAA;QACA8a,OAAA,GAAA7d,+BAAA,MAAAkG,sBAAA;QACA2X,OAAA,CAAAlU,kBAAA;QACA,WAAAyD,GAAA,IAAApK,MAAA,CAAAmR,IAAA,MAAAxK,kBAAA;UACAkU,OAAA,CAAAlU,kBAAA,CAAAyD,GAAA,KACA,QAAAzD,kBAAA,CAAAyD,GAAA,EACA,CAAAjD,GAAA,CAAA8J,CAAA,QAAA1N,IAAA,CAAA0N,CAAA;QACA;QACA4J,OAAA,CAAA/J,eAAA;UACA1M,UAAA,OAAAA,UAAA;UACAC,YAAA,OAAAA;QACA;MACA;QACAtE,IAAA;QACA8a,OAAA,CAAA1Y,YAAA,QAAA+E,iBAAA;QACA2T,OAAA,CAAAxY,QAAA,QAAAgF,aAAA;QACA,SAAAG,QAAA,UAAAnG,yBAAA;UACAwZ,OAAA,CAAAC,KAAA;QACA;UACAD,OAAA,CAAAC,KAAA;UACAD,OAAA,CAAAjb,IAAA,GAAA+a,YAAA,CAAA/a,IAAA;UACAib,OAAA,CAAAD,KAAA,GAAAD,YAAA,CAAAC,KAAA;UACA7W,YAAA,MAAAiN,YAAA,IAAA2J,YAAA,CAAA/a,IAAA;QACA;MACA;MAEA,MAAAzD,IAAA,iBAAA2D,KAAA,CAAAiJ,GAAA,aAAA8R,OAAA;;MAEA;MACA,MAAAE,kBAAA,QAAA1T,aAAA,CAAA8B,MAAA;MACA,SAAA3B,QAAA;QACA,SAAAA,QAAA,CAAAuB,GAAA,SAAA2G,eAAA;UACA,KAAAsL,QAAA,EAAAC,OAAA,WAAAlb,IAAA;YACAmb,OAAA,OAAApb,KAAA,CAAAiJ,GAAA;YACAgS;UACA;QACA;UACA,KAAAC,QAAA,EAAAC,OAAA,UAAAlb,IAAA;YACAmb,OAAA,OAAApb,KAAA,CAAAiJ,GAAA;YACAgS,kBAAA;YACA;YACA3W,UAAA,OAAAA,UAAA,CAAA0G,IAAA;YACAqQ,gBAAA,OAAA/W,UAAA,CAAAyD,OAAA;YACAuT,mBAAA,OAAA/W,YAAA,CAAAwD,OAAA;YACAwT,qBAAA,OAAAhX,YAAA,CAAA8G,SAAA;YACAmQ,mBAAA,OAAAjX,YAAA,CAAAgV;UACA;QACA;MACA;QACA,IAAAsB,YAAA,CAAA/a,IAAA,SAAA8P,eAAA;UACA,KAAAsL,QAAA,EAAAC,OAAA,WAAAlb,IAAA;YACAmb,OAAA,OAAApb,KAAA,CAAAiJ,GAAA;YACAgS;UACA;QACA;UACA,KAAAC,QAAA,EAAAC,OAAA,UAAAlb,IAAA;YACAmb,OAAA,OAAApb,KAAA,CAAAiJ,GAAA;YACAgS;UACA;QACA;MACA;MAEA,KAAAQ,YAAA;MACA,KAAA7Y,cAAA;IACA;IACA,MAAA8Y,sBAAA;MACA,IACA,KAAA3X,sBAAA,CAAAqF,IAAA,GAAAC,MAAA,GACA,KAAAvF,iBAAA,CAAAsF,IAAA,GAAAC,MAAA,KACA,GACA;QACA,KAAAkO,SAAA;QACA;MACA;MAEA,SAAA1M,CAAA,MAAAA,CAAA,QAAA9G,sBAAA,CAAAsF,MAAA,IAAAwB,CAAA;QACA,KAAA/G,iBAAA,CAAA+G,CAAA,SAAA/G,iBAAA,CAAA+G,CAAA,EAAA8Q,MAAA,CACA,KAAA5X,sBAAA,CAAA8G,CAAA,CACA;QACA,KAAA9G,sBAAA,CAAA8G,CAAA;MACA;MAEA,MAAAkQ,OAAA;QACAjb,IAAA,OAAAE,KAAA,CAAAF,IAAA;QACAiN,QAAA,OAAA/M,KAAA,CAAA+M,QAAA;QACAjC,KAAA,OAAA9K,KAAA,CAAA8K,KAAA;QACA7K,IAAA,OAAAD,KAAA,CAAAC,IAAA;QACA2b,YAAA,OAAA9X,iBAAA,CAAAsF,IAAA,GAAA/B,GAAA,CAAAsC,KAAA;UACA;YACAV,GAAA,EAAAU,KAAA,CAAAV,GAAA;YACAnJ,IAAA,EAAA6J,KAAA,CAAA7J,IAAA;YACA+b,QAAA,EAAAlS,KAAA,CAAAkS,QAAA;YACAnC,SAAA,EAAA/P,KAAA,CAAA+P,SAAA;YACAV,OAAA,EAAArP,KAAA,CAAAqP;UACA;QACA;MACA;MAEA1c,GAAA,iBAAA0D,KAAA,CAAAiJ,GAAA,IAAA8R,OAAA,EACA5D,IAAA;QACA;MAAA,CACA,EACAE,KAAA,CAAAC,GAAA;QACAwE,OAAA,CAAAC,KAAA,CAAAzE,GAAA;QACA,KAAAC,SAAA,CACA,iEACA;MACA;MAEA;IACA;IAEA,MAAAyE,mBAAAlc,IAAA;MACA,MAAAib,OAAA;MACA,SAAArT,QAAA,UAAAnG,yBAAA;QACAwZ,OAAA,CAAAC,KAAA;QACAD,OAAA,CAAAhS,MAAA,QAAArB,QAAA,CAAAuB,GAAA;QAEA,KAAAiS,QAAA,EAAAC,OAAA;UACAC,OAAA,OAAApb,KAAA,CAAAiJ;QACA;MACA;QACA8R,OAAA,CAAAC,KAAA;QACAD,OAAA,CAAAjb,IAAA,GAAAA,IAAA;QAEA,KAAAob,QAAA,EAAAC,OAAA;UACAC,OAAA,OAAApb,KAAA,CAAAiJ,GAAA;UACAnJ;QACA;MACA;MACA,MAAAhD,OAAA,iBAAAkD,KAAA,CAAAiJ,GAAA,aAAA8R,OAAA;MACA,KAAA1Y,YAAA,OAAAC,GAAA;MACA,SAAAuF,OAAA,OAAAoU,OAAA,CAAAC,OAAA;QAAApc,IAAA;MAAA,QACA,KAAA2b,YAAA;IACA;IACA;;IAEA;IACA;IACA;IACAU,gBAAA;MACA;MACA,MAAAC,UAAA,GAAAC,QAAA,CAAAC,aAAA;MACA,IAAAF,UAAA;QACA;QAAA;UAAAlX,KAAA,OAAAD,QAAA,CAAAC,KAAA;UAAAC,MAAA,OAAAF,QAAA,CAAAE;QAAA,IACAiX,UAAA,CAAAG,qBAAA;MACA;IACA;IACA;IACArI,0BAAA5J,GAAA,EAAAU,IAAA,EAAA2C,CAAA,EAAA+D,CAAA;MACA,MAAA5O,GAAA,GAAA4O,CAAA;MACA,MAAA3O,GAAA,GAAA4K,CAAA;MACA,MAAA5C,IAAA,QAAA+J,iBAAA,CAAAhS,GAAA,EAAAC,GAAA;MACA,MAAAyZ,UAAA,QAAAC,qBAAA,CAAA1R,IAAA,EAAAjI,GAAA,EAAAC,GAAA;;MAEA;MACA,MAAAgT,YAAA,GAAArE,CAAA,QAAApB,UAAA,IAAAjH,MAAA;MACA,MAAAqT,UAAA,IAAA3R,IAAA;;MAEA;MACA,SAAA5J,qBAAA,SAAAuB,uBAAA;QACA8Z,UAAA,CAAAG,KAAA;MACA;;MAEA;MACAH,UAAA,CAAArM,KAAA,CAAAhL,MAAA,WAAAqL,cAAA;;MAEA;MACA,IACA,MAAAd,WAAA,CAAArG,MAAA,QACA,KAAA4F,OAAA,IACA,KAAA7M,KAAA,UAAAT,MAAA,CAAAQ,kBAAA,KACA,KAAAU,WAAA,CAAAC,GAAA,KAAAA,GAAA,IACA,KAAAD,WAAA,CAAAE,GAAA,KAAAA,GAAA,IACA,CAAA2Z,UAAA,EACA;QACA;QACAF,UAAA,CAAAG,KAAA,IACA;MACA;QACA;QACA,IAAA5R,IAAA;UACA,MAAAwB,SAAA,OAAA9I,IAAA,CACAsH,IAAA,CAAArH,OAAA,UAAAiF,cAAA,YACA;UACA,MAAAiU,cAAA,GAAArQ,SAAA,CAAA2L,UAAA;UACA,IAAA0E,cAAA;YACAJ,UAAA,CAAAG,KAAA;UACA,WAAAC,cAAA;YACAJ,UAAA,CAAAG,KAAA;YACAH,UAAA,CAAArM,KAAA,CAAA0M,cAAA;UACA;QACA;QAEAL,UAAA,CAAAG,KAAA;QACA,IAAA5Z,GAAA,gBAAA6S,gBAAA,CAAA7S,GAAA,GACAyZ,UAAA,CAAAG,KAAA;QACA,IAAA5Z,GAAA,UAAAuI,IAAA,CAAAjC,MAAA,cAAAuM,gBAAA,CAAA7S,GAAA,OACAyZ,UAAA,CAAAG,KAAA;QACA,IAAA5G,YAAA,IAAAjT,GAAA,QACA0Z,UAAA,CAAAG,KAAA;QACA,KAAA5G,YAAA,IAAAjT,GAAA,UAAAwN,UAAA,IAAAjH,MAAA,EACAmT,UAAA,CAAAG,KAAA;QACA,IAAA5G,YAAA,IAAAjT,GAAA,UAAAwN,UAAA,IAAAjH,MAAA,MACAmT,UAAA,CAAAG,KAAA;QACA,IACA,CAAA5G,YAAA,IACAjT,GAAA,UAAAwN,UAAA,IAAAjH,MAAA,QAAAiH,UAAA,IAAAjH,MAAA,MAEAmT,UAAA,CAAAG,KAAA;QAEA,MAAAG,gBAAA,GACA,KAAA1a,KAAA,UAAAT,MAAA,CAAAG,mBAAA,GACA,KAAAqB,cAAA,CAAAkG,MAAA,GACA,KAAAqG,WAAA,CAAArG,MAAA;QACA,IACA,KAAAjH,KAAA,UAAAT,MAAA,CAAAK,iBAAA,IACA,KAAAI,KAAA,UAAAT,MAAA,CAAAE,mBAAA,IACAib,gBAAA,QACA;UACAN,UAAA,CAAAG,KAAA;QACA;UACAH,UAAA,CAAAG,KAAA;QACA;MACA;;MAEA;MACA,IAAAD,UAAA;QACAF,UAAA,CAAAG,KAAA,IACA;MACA;;MAEA;MACA,IAAAH,UAAA,CAAArM,KAAA,CAAA4M,eAAA;QACAP,UAAA,CAAArM,KAAA,CAAA4M,eAAA;MACA;MAEA,OAAAP,UAAA;IACA;IACA;IACAC,sBAAA1R,IAAA,EAAAjI,GAAA,EAAAC,GAAA;MACA,IAAAia,CAAA;MACA,MAAAC,CAAA;MACA,KAAAlS,IAAA;QAAA4R,KAAA,EAAAK,CAAA;QAAA7M,KAAA,EAAA8M;MAAA;MAEA,MAAAC,mBAAA,GACA,KAAAvZ,kBAAA,CAAA5G,GAAA,CAAAgO,IAAA,CAAArH,OAAA,WAAApB,GAAA;;MAEA;;MAEA,SAAA2E,QAAA;QACA+V,CAAA;QACA;UAAAL,KAAA,EAAAK,CAAA;UAAA7M,KAAA,EAAA8M;QAAA;MACA;MAEA,IACA,MAAA5Y,mBAAA,IACA,KAAAjC,KAAA,UAAAT,MAAA,CAAAK,iBAAA,IACA,KAAAI,KAAA,UAAAT,MAAA,CAAAQ,kBAAA,EACA;QACA;QACA8a,CAAA,CAAAF,eAAA;;QAEA;QACA,MAAA/H,WAAA,QAAAA,WAAA,CAAAlS,GAAA,EAAAC,GAAA;QACA,IAAAiS,WAAA;UACA;UACA,SAAA3P,QAAA,UAAAV,UAAA,CAAAC,GAAA;YACA,SAAAxC,KAAA,UAAAT,MAAA,CAAAQ,kBAAA;cACA6a,CAAA;YACA;cACA,SAAA7Y,gBAAA,KAAAtG,iBAAA,CAAAuG,SAAA;gBACA6Y,CAAA,CAAAF,eAAA;cACA,WACA,KAAA5Y,gBAAA,KAAAtG,iBAAA,CAAA+V,SAAA,EACA;gBACAoJ,CAAA;cACA;YACA;UACA,gBAAA3X,QAAA,UAAAV,UAAA,CAAAE,MAAA;YACA,SAAAzC,KAAA,UAAAT,MAAA,CAAAQ,kBAAA;cACA6a,CAAA;YACA;UACA;QACA;UACA;UACA;UACA,SAAA5a,KAAA,UAAAT,MAAA,CAAAQ,kBAAA;YACA,SAAAK,SAAA,CAAAoI,GAAA,CAAAG,IAAA,CAAArH,OAAA;cACAsZ,CAAA;YACA;cACAA,CAAA;YACA;UACA;YACA,SAAA3a,YAAA,CAAAuI,GAAA,CAAAG,IAAA,CAAArH,OAAA;cACAuZ,CAAA,CAAAF,eAAA;YACA,gBAAAxa,QAAA,CAAAqI,GAAA,CAAAG,IAAA,CAAArH,OAAA;cACAsZ,CAAA;YACA;UACA;QACA;MACA;MAEA,SAAA5a,KAAA,UAAAT,MAAA,CAAAE,mBAAA;QACA;QACA,MAAA0W,UAAA,QAAArV,aAAA;QACA,IAAAga,mBAAA,CAAAtS,GAAA,CAAA2N,UAAA;UACA,SAAA3I,eAAA,CAAA2I,UAAA,GAAAhW,QAAA,EAAAqI,GAAA,CAAAG,IAAA,CAAArH,OAAA;YACAsZ,CAAA;UACA;YACAC,CAAA,CAAAF,eAAA;UACA;QACA;UACAE,CAAA,CAAAF,eAAA;QACA;QACA;UAAAJ,KAAA,EAAAK,CAAA;UAAA7M,KAAA,EAAA8M;QAAA;MACA;MAEA,IACA,KAAA5Y,mBAAA,IACA,KAAAjC,KAAA,UAAAT,MAAA,CAAAI,UAAA,IACA,KAAAK,KAAA,UAAAT,MAAA,CAAAC,OAAA,IACA,KAAAQ,KAAA,UAAAT,MAAA,CAAAO,cAAA,IACA,KAAAE,KAAA,UAAAT,MAAA,CAAAG,mBAAA,EACA;QACA,IAAAqb,cAAA;QACA,IAAA/S,GAAA;QAEA,IACA,KAAAhI,KAAA,UAAAT,MAAA,CAAAI,UAAA,IACA,KAAAK,KAAA,UAAAT,MAAA,CAAAC,OAAA,IACA,KAAAQ,KAAA,UAAAT,MAAA,CAAAO,cAAA,EACA;UACAib,cAAA,GAAAD,mBAAA,CAAA1L,IAAA;UACApH,GAAA,QAAAA,GAAA;QACA,gBAAAhI,KAAA,UAAAT,MAAA,CAAAG,mBAAA;UACAqb,cAAA,OAAAD,mBAAA,EAAAxS,MAAA,CAAAC,CAAA,IACA,KAAAzB,iBAAA,CAAA0B,GAAA,CAAAD,CAAA,CACA,EAAAtB,MAAA;UAEAe,GAAA,QAAAD,iBAAA;QACA,gBAAA9F,mBAAA;UACA,IACA,MAAA4O,gBAAA,SAAA5R,UAAA,EAAAgI,MAAA,SACA6T,mBAAA,CAAAtS,GAAA,MAAAlD,QAAA,EAAAuB,GAAA,SAAA5H,UAAA,GACA;YACA;YACA8b,cAAA,GAAAD,mBAAA,CAAA1L,IAAA;YACApH,GAAA,QAAAA,GAAA;UACA;YACA+S,cAAA,GAAAD,mBAAA,CAAA1L,IAAA;YACApH,GAAA,QAAAA,GAAA;UACA;QACA;QAEA,MAAA0S,gBAAA,GACA,KAAA1a,KAAA,UAAAT,MAAA,CAAAG,mBAAA,GACA,KAAAqB,cAAA,CAAAkG,MAAA,GACA,KAAAqG,WAAA,CAAArG,MAAA;QAEA,SAAA2F,YAAA,UAAArN,MAAA,CAAAI,UAAA;UACA,IAAAqI,GAAA,QAAA+S,cAAA,KAAA/S,GAAA;YACA;YACA,IAAA0S,gBAAA,eAAAzY,mBAAA;cACA;cACA,MAAA+Y,KAAA;cACAH,CAAA,CAAAF,eAAA,GAAAK,KAAA;YACA;cACA,MAAAA,KAAA;cACAH,CAAA,CAAAF,eAAA,GAAAK,KAAA;YACA;UACA;QACA,gBAAApO,YAAA,UAAArN,MAAA,CAAAC,OAAA;UACA,IAAAub,cAAA;YACA,IAAAL,gBAAA;cACA,MAAAO,YAAA,GACA,KAAAjb,KAAA,UAAAT,MAAA,CAAAG,mBAAA,GACA,KAAAqB,cAAA,MACA,KAAAuM,WAAA,IAAAzG,GAAA;cACA,IACA,KAAA2G,eAAA,CAAAyN,YAAA,GAAA9a,QAAA,EAAAqI,GAAA,CACAG,IAAA,CAAArH,OAAA,EACA,GACA;gBACAsZ,CAAA;cACA;gBACA,MAAAI,KAAA;gBACAH,CAAA,CAAAF,eAAA,GAAAK,KAAA;cACA;YACA;cACA;cACA,MAAAE,IAAA,GAAAH,cAAA,GAAA/S,GAAA;cACA,MAAAgT,KAAA;cACA,IAAAG,KAAA;cACA,UAAAlZ,mBAAA;gBACAkZ,KAAA,GAAA1T,IAAA,CAAAuB,KAAA,CAAAkS,IAAA,eACAE,QAAA,KACAC,WAAA,GACAC,SAAA,OACAC,QAAA;gBACA,IACAL,IAAA,UACA,KAAAna,cAAA,CAAAkG,MAAA,QACAe,GAAA,UAAAjH,cAAA,CAAAkG,MAAA,IACA,KAAAlG,cAAA,CAAAkG,MAAA,UACAe,GAAA,UAAAsF,WAAA,CAAArG,MAAA,GACA;kBACAkU,KAAA;gBACA;cACA;gBACAA,KAAA,GAAA1T,IAAA,CAAAuB,KAAA,CAAAkS,IAAA,eACAE,QAAA,KACAC,WAAA,GACAC,SAAA,OACAC,QAAA;cACA;cAEAV,CAAA,CAAAF,eAAA,GAAAK,KAAA,GAAAG,KAAA;YACA;UACA,WAAAT,gBAAA;YACA,MAAAc,GAAA;YACAX,CAAA,CAAAF,eAAA,GAAAa,GAAA;UACA;QACA;MACA;MAEA;QAAAjB,KAAA,EAAAK,CAAA;QAAA7M,KAAA,EAAA8M;MAAA;IACA;IACA7I,yBAAArJ,IAAA,EAAAF,CAAA;MACA,MAAA/H,GAAA,GAAA+G,IAAA,CAAAuB,KAAA,CAAAP,CAAA;MACA,MAAA9H,GAAA,GAAA8H,CAAA;MAEA,IAAA2R,UAAA;MACA;MACA,SAAA/N,gBAAA,CAAA1R,GAAA,CAAAgO,IAAA,CAAArH,OAAA;QACA8Y,UAAA,QAAAC,qBAAA,CAAA1R,IAAA,EAAAjI,GAAA,EAAAC,GAAA;QACA,SAAAX,KAAA,UAAAT,MAAA,CAAAK,iBAAA;UACAwa,UAAA,CAAAG,KAAA;QACA;QAEA,MAAAI,eAAA,GAAAP,UAAA,CAAArM,KAAA,CAAA4M,eAAA;QACA,IACAA,eAAA,IACA1f,WAAA,CAAAC,yBAAA,CAAAyf,eAAA,eACA;UACAP,UAAA,CAAAG,KAAA;QACA;MACA;QACAH,UAAA;UACAG,KAAA;UACAxM,KAAA;QACA;MACA;;MAEA;MACA,IAAAqM,UAAA,CAAArM,KAAA,CAAA4M,eAAA;QACAP,UAAA,CAAArM,KAAA,CAAA4M,eAAA;MACA;;MAEA;MACA;MACA;MACA;;MAEA;MACA,IACA,MAAArN,WAAA,CAAArG,MAAA,QACA,KAAAjH,KAAA,UAAAT,MAAA,CAAAK,iBAAA,KACA,KAAAa,WAAA,CAAAC,GAAA,KAAAA,GAAA,IACA,KAAAD,WAAA,CAAAE,GAAA,KAAAA,GAAA,IACA,KAAA0L,gBAAA,CAAA1R,GAAA,CAAAgO,IAAA,CAAArH,OAAA,KACA;QACA;QACA8Y,UAAA,CAAAG,KAAA,IACA;MACA;QACA;QACA,IAAA5Z,GAAA,QAAAyZ,UAAA,CAAAG,KAAA;QACAH,UAAA,CAAAG,KAAA;QACA,IAAA5Z,GAAA;UACAyZ,UAAA,CAAArM,KAAA,CAAA0N,gBAAA;QACA;QAEA,IAAA/a,GAAA,QAAA0Z,UAAA,CAAAG,KAAA;QACAH,UAAA,CAAAG,KAAA;QACA,IAAA7Z,GAAA,KAAA+G,IAAA,CAAAuB,KAAA,MAAAqC,SAAA,CAAApE,MAAA;UACAmT,UAAA,CAAArM,KAAA,CAAA2N,iBAAA;QACA;MACA;MAEA,OAAAtB,UAAA;IACA;IACAjI,eAAAzR,GAAA,EAAAC,GAAA;MACA,SAAA9B,YAAA;QACA;UACA8c,KAAA,EAAAA,CAAA;YACA,SAAA/a,gBAAA;cACA;cACA,IACAF,GAAA,UAAAD,WAAA,CAAAC,GAAA,IACAC,GAAA,UAAAF,WAAA,CAAAE,GAAA,EACA;gBACA,KAAAC,gBAAA;cACA;YACA,WACA,KAAAZ,KAAA,UAAAT,MAAA,CAAAK,iBAAA,KACA,KAAAiR,gBAAA,SAAAlD,sBAAA,GACA;cACA;cACA,KAAA/M,gBAAA;YACA;YAEA,KAAAqV,gBAAA,CAAAvV,GAAA,EAAAC,GAAA;UACA;UACAib,SAAA,EAAAA,CAAA;YACA;YACA,IACA,KAAA5b,KAAA,UAAA4M,YAAA,KACA,MAAAvS,OAAA,IACA,OAAAwW,gBAAA,SAAAlD,sBAAA,KACA,KAAAL,WAAA,CAAArG,MAAA,QAEA,KAAA4U,wBAAA;UACA;UACAC,SAAA,EAAAA,CAAA;YACA;YACA,UAAAlb,gBAAA;cACA,KAAAqV,gBAAA,CAAAvV,GAAA,EAAAC,GAAA;cACA,UAAA/C,KAAA,CAAAqK,QAAA;gBACA,MAAAU,IAAA,QAAA+J,iBAAA,CAAAhS,GAAA,EAAAC,GAAA;gBACA,IAAAgI,IAAA;kBACAA,IAAA,CAAAc,OAAA,CAAAd,IAAA,CAAArH,OAAA,UAAAiF,cAAA;kBACA,MAAA+Q,SAAA,GAAAra,KAAA,CAAA0L,IAAA,EAAAoT,GAAA;kBACA,MAAAnF,OAAA,GAAA3Z,KAAA,CAAA0L,IAAA,EACAoT,GAAA,GACA1R,GAAA,MAAA0F,gBAAA;kBACA,MAAAiM,UAAA,GACA,KAAA1Y,QAAA,KAAA1H,SAAA,CAAA2H,MAAA;kBACA,IAAA0Y,UAAA;kBACA,SAAArS,eAAA;oBACAqS,UAAA;kBACA;oBACAA,UAAA;kBACA;kBACA,KAAAxa,cAAA,MAAA6V,SAAA,CAAA4E,MAAA,CACAD,UACA,KAAA3E,SAAA,CAAA4E,MAAA,CAAAF,UAAA,QAAApF,OAAA,CAAAsF,MAAA,CACAF,UACA;gBACA;cACA;YACA;UACA;UACAG,UAAA,EAAAA,CAAA;YACA,KAAA1a,cAAA;UACA;QACA;MACA;MACA;IACA;IACA+S,iBAAA;MACA;MACA,SAAA5T,gBAAA;MAEA,KAAAC,uBAAA;MACA,WAAAsV,UAAA,SAAA7I,WAAA;QACA,KAAAzM,uBAAA,CAAAsV,UAAA,CAAAtP,GAAA;MACA;MACA,KAAApG,WAAA;QAAAC,GAAA;QAAAC,GAAA;MAAA;;MAEA;MACA,KAAAyb,OAAA;IACA;IACA;;IAEA;IACA;IACA;IACAC,aAAA;MACA,KAAArc,KAAA,QAAA6E,QAAA,GACA,KAAAtF,MAAA,CAAAM,mBAAA,GACA,KAAAN,MAAA,CAAAK,iBAAA;MACA,KAAAmC,gBAAA,GAAAtG,iBAAA,CAAAuG,SAAA;MACA,KAAA/B,YAAA,OAAAC,GAAA;MACA,KAAAC,QAAA,OAAAD,GAAA;MAEA,SAAAoF,QAAA,UAAAnG,yBAAA;QACA,KAAAkX,wBAAA;MACA;MACA,KAAAG,SAAA,YAAAhW,cAAA;MACA,KAAA8D,cAAA;IACA;IACAgY,YAAA;MACA,KAAAtc,KAAA,QAAA4M,YAAA;MACA,KAAA0L,oBAAA;;MAEA;MACA,KAAAvW,gBAAA,GAAAtG,iBAAA,CAAAuG,SAAA;MACA,KAAAC,mBAAA;IACA;IACA4Z,yBAAA;MACA,KAAAU,KAAA;IACA;IACAC,sBAAA9W,EAAA;MACA,SAAAJ,QAAA;QACA,KAAAiX,KAAA;MACA;QACA,KAAAF,YAAA;MACA;MAEA,KAAA7F,SAAA;QACA,KAAAD,wBAAA,CAAA7Q,EAAA;QACA,KAAA6W,KAAA,kBAAA7W,EAAA;MACA;IACA;IACA2T,aAAA;MACA,KAAAkD,KAAA;IACA;IACA;;IAEA;IACA;IACA;IACAE,cAAA;MACA,KAAAzc,KAAA,QAAAT,MAAA,CAAAO,cAAA;MACA,KAAAgZ,QAAA,EAAAC,OAAA;IACA;IACA2D,oBAAA;MACA,KAAA1c,KAAA,QAAA4M,YAAA;IACA;IAEA;IACA+P,qBAAAC,cAAA;MACA,UAAAvZ,iBAAA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;;MAEA,KAAAyV,QAAA,EAAAC,OAAA;MACA;MACA;QAAApY,GAAA;QAAAD,GAAA;QAAAyN;MAAA,SAAA9K,iBAAA;MACA,IAAAiU,SAAA,QAAA5E,iBAAA,CAAAhS,GAAA,EAAAC,GAAA;MACA,IAAAiW,OAAA,OAAAvV,IAAA,CAAAiW,SAAA;MACAV,OAAA,CAAAf,UAAA,CACAyB,SAAA,CAAAxB,UAAA,UAAA/F,gBAAA,GAAA5B,OACA;MAEA,SAAAnE,QAAA,SAAAvE,OAAA;QACA;QACA;QACA,IAAAgL,MAAA;QACA,SAAAhL,OAAA;UACAgL,MAAA,QAAAjS,UAAA;QACA,gBAAAwL,QAAA;UACA,QAAA3I,IAAA,GAAAwb,MAAA,KAAAvF,SAAA,CAAAuF,MAAA;YACApM,MAAA;UACA;QACA;;QAEA;QACA6G,SAAA,GAAA7c,aAAA,MAAAmD,KAAA,CAAA8K,KAAA,EAAA4O,SAAA,EAAA7G,MAAA;QACAmG,OAAA,GAAAnc,aAAA,MAAAmD,KAAA,CAAA8K,KAAA,EAAAkO,OAAA,EAAAnG,MAAA;MACA;;MAEA;MACA,MAAAqM,MAAA,QAAAxP,WAAA,CAAArI,GAAA,CAAAsD,CAAA;QACA;QACA,IAAAA,CAAA,CAAAmQ,KAAA,CAAAzR,MAAA;UACA,OAAAsB,CAAA,CAAAmQ,KAAA;QACA;UACA;UACA;QACA;MACA;MACA,MAAAqE,YAAA,GAAAC,kBAAA,CAAAF,MAAA,CAAAxU,MAAA,CAAArK,OAAA,EAAAgf,IAAA;MAEA,MAAAjE,OAAA,QAAApb,KAAA,CAAAsf,OAAA,SAAAtf,KAAA,CAAAiJ,GAAA;MAEA,IAAAgO,GAAA;MACA,IAAA+H,cAAA;QACA;QACA,MAAAO,KAAA,GAAA7F,SAAA,CAAAxC,WAAA,GAAAgF,OAAA;QACA,MAAAsD,GAAA,GAAAxG,OAAA,CAAA9B,WAAA,GAAAgF,OAAA;;QAEA;QACAjF,GAAA,uEAAAmI,kBAAA,CACA,KAAApf,KAAA,CAAAF,IACA,WAAAyf,KAAA,IAAAC,GAAA,YAAAJ,kBAAA,CACA,8DACA,IAAAhE,OAAA,aAAA5V,WAAA,CAAAuN,KAAA,QAAAoM,YAAA;MACA;QACAlI,GAAA,mEAAAmI,kBAAA,CACA,KAAApf,KAAA,CAAAF,IACA,UAAAsf,kBAAA,CACA,iEACAhE,OACA,aAAA1B,SAAA,CAAAxC,WAAA,YAAA8B,OAAA,CAAA9B,WAAA,eAAAkI,kBAAA,CACA,KAAApf,KAAA,CAAAyf,QAAA,MACA,iDAAAja,WAAA,CAAAuN,KAAA;MACA;;MAEA;MACA2M,MAAA,CAAAC,IAAA,CAAA1I,GAAA;MACA,KAAA7U,KAAA,QAAA4M,YAAA;IACA;IACA;;IAEA;IACA;IACA;IACA4Q,YAAA1J,CAAA;MACA;MACA,IAAA2J,KAAA,EAAAC,KAAA;MACA,iBAAA5J,CAAA;QACA;QACA;QAAA;UAAA2J,KAAA;UAAAC;QAAA,IAAA5J,CAAA,CAAA6J,OAAA;MACA;QACA;QACA;QAAA;UAAAF,KAAA;UAAAC;QAAA,IAAA5J,CAAA;MACA;MACA;QAAA8J,IAAA;QAAA5P;MAAA,IAAA8F,CAAA,CAAA+J,aAAA,CAAA1D,qBAAA;MACA,MAAA2D,CAAA,GAAAL,KAAA,GAAAG,IAAA;MACA,MAAAG,CAAA,GAAAL,KAAA,GAAA1P,GAAA,GAAAsP,MAAA,CAAAU,OAAA;MACA;QAAAF,CAAA;QAAAC;MAAA;IACA;IACAE,SAAAvd,GAAA;MACA,SAAA9C,KAAA,CAAAqK,QAAA;QACAvH,GAAA,GAAAtG,KAAA,CAAAsG,GAAA,KAAA+G,IAAA,CAAAuB,KAAA,MAAAqC,SAAA,CAAApE,MAAA;MACA;QACAvG,GAAA,GAAAtG,KAAA,CAAAsG,GAAA,UAAAmI,KAAA,CAAA5B,MAAA;MACA;MACA,OAAAvG,GAAA;IACA;IACAwd,SAAAvd,GAAA;MACA,SAAA/C,KAAA,CAAAqK,QAAA;QACAtH,GAAA,GAAAvG,KAAA,CAAAuG,GAAA;MACA;QACAA,GAAA,GAAAvG,KAAA,CAAAuG,GAAA,UAAAuI,IAAA,CAAAjC,MAAA;MACA;MACA,OAAAtG,GAAA;IACA;IACA;IACAwd,gBAAAL,CAAA,EAAAC,CAAA;MACA;QAAAjb,KAAA;QAAAC;MAAA,SAAAF,QAAA;MACA,IAAAlC,GAAA,GAAA8G,IAAA,CAAAuB,KAAA,CAAA8U,CAAA,GAAAhb,KAAA;MACA,UAAAlF,KAAA,CAAAqK,QAAA;QACAtH,GAAA,QAAAuS,aAAA,CAAAjM,MAAA;QACA,SAAAwB,CAAA,MAAAA,CAAA,QAAAyK,aAAA,CAAAjM,MAAA,IAAAwB,CAAA;UACA,IAAAqV,CAAA,QAAA5K,aAAA,CAAAzK,CAAA;YACA9H,GAAA,GAAA8H,CAAA;YACA;UACA;QACA;MACA;MACA,IAAA/H,GAAA,GAAA+G,IAAA,CAAAuB,KAAA,CAAA+U,CAAA,GAAAhb,MAAA;;MAEA;MACA,UAAAnF,KAAA,CAAAqK,QAAA,IAAAvH,GAAA,QAAAwN,UAAA,IAAAjH,MAAA;QACA,MAAAmX,WAAA,GAAA3W,IAAA,CAAAuB,KAAA,EAAA+U,CAAA,QAAArb,gBAAA,IAAAK,MAAA;QACA,IAAAqb,WAAA,SAAAlQ,UAAA,IAAAjH,MAAA;UACA;UACAvG,GAAA,GAAA0d,WAAA;QACA;MACA;MAEA1d,GAAA,QAAAud,QAAA,CAAAvd,GAAA;MACAC,GAAA,QAAAud,QAAA,CAAAvd,GAAA;MACA;QACAD,GAAA;QACAC;MACA;IACA;IACAyb,QAAA;MACA,UAAAhX,SAAA;MAEA,UAAAlC,SAAA,UAAAC,OAAA;;MAEA;MACA,IACA,KAAAnD,KAAA,UAAAT,MAAA,CAAAK,iBAAA,IACA,KAAAI,KAAA,UAAAT,MAAA,CAAAQ,kBAAA,EACA;QACA;QACA,IAAAse,MAAA,GACA,MAAAlb,OAAA,CAAAxC,GAAA,QAAAuC,SAAA,CAAAvC,GAAA,IACA8G,IAAA,CAAA6W,GAAA,MAAAnb,OAAA,CAAAxC,GAAA,QAAAuC,SAAA,CAAAvC,GAAA;QACA,IAAA4d,MAAA,GACA,MAAApb,OAAA,CAAAzC,GAAA,QAAAwC,SAAA,CAAAxC,GAAA,IACA+G,IAAA,CAAA6W,GAAA,MAAAnb,OAAA,CAAAzC,GAAA,QAAAwC,SAAA,CAAAxC,GAAA;QACA,IAAA8d,KAAA,CAAAH,MAAA,GAAAA,MAAA;QACA,IAAAG,KAAA,CAAAD,MAAA,GAAAA,MAAA;;QAEA;QACA,IAAAE,QAAA,QAAAvb,SAAA,CAAAxC,GAAA;QACA,IAAAge,MAAA,QAAAvb,OAAA,CAAAzC,GAAA,GAAA6d,MAAA;QACA,IAAAI,QAAA,QAAAzb,SAAA,CAAAvC,GAAA;QACA,IAAAie,MAAA,QAAAzb,OAAA,CAAAxC,GAAA,GAAA0d,MAAA;;QAEA;QACA,SAAAzgB,KAAA,CAAAqK,QAAA;UACA0W,QAAA;UACAC,MAAA;UACAP,MAAA;QACA;;QAEA;QACA,SAAA9V,CAAA,GAAAkW,QAAA,EAAAlW,CAAA,IAAAmW,MAAA,EAAAnW,CAAA,IAAAgW,MAAA;UACA,SAAA3D,CAAA,GAAA+D,QAAA,EAAA/D,CAAA,IAAAgE,MAAA,EAAAhE,CAAA,IAAAyD,MAAA;YACA,MAAA1V,IAAA,QAAA+J,iBAAA,CAAAnK,CAAA,EAAAqS,CAAA;YACA,KAAAjS,IAAA;YAEA,SAAA/K,KAAA,CAAAqK,QAAA;cACA;cACA,MAAA4W,kBAAA,GACA,KAAAxS,gBAAA,CAAA1R,GAAA,CAAAgO,IAAA,CAAArH,OAAA,OACA,KAAAsR,WAAA,CAAArK,CAAA,EAAAqS,CAAA;cACA,KAAAiE,kBAAA;YACA;YAEA,SAAA5b,QAAA,UAAAV,UAAA,CAAAC,GAAA;cACA,SAAAxC,KAAA,UAAAT,MAAA,CAAAQ,kBAAA;gBACA,KAAAK,SAAA,CAAAiK,GAAA,CAAA1B,IAAA,CAAArH,OAAA;cACA;gBACA;gBACA,SAAAS,gBAAA,KAAAtG,iBAAA,CAAAuG,SAAA;kBACA,KAAA/B,YAAA,CAAAoK,GAAA,CAAA1B,IAAA,CAAArH,OAAA;kBACA,KAAAnB,QAAA,CAAA2e,MAAA,CAAAnW,IAAA,CAAArH,OAAA;gBACA,WACA,KAAAS,gBAAA,KAAAtG,iBAAA,CAAA+V,SAAA,EACA;kBACA,KAAArR,QAAA,CAAAkK,GAAA,CAAA1B,IAAA,CAAArH,OAAA;kBACA,KAAArB,YAAA,CAAA6e,MAAA,CAAAnW,IAAA,CAAArH,OAAA;gBACA;cACA;YACA,gBAAA2B,QAAA,UAAAV,UAAA,CAAAE,MAAA;cACA,SAAAzC,KAAA,UAAAT,MAAA,CAAAQ,kBAAA;gBACA,KAAAK,SAAA,CAAA0e,MAAA,CAAAnW,IAAA,CAAArH,OAAA;cACA;gBACA;gBACA,KAAArB,YAAA,CAAA6e,MAAA,CAAAnW,IAAA,CAAArH,OAAA;gBACA,KAAAnB,QAAA,CAAA2e,MAAA,CAAAnW,IAAA,CAAArH,OAAA;cACA;YACA;;YAEA;YACA,SAAA1D,KAAA,CAAAC,IAAA,KAAAlC,UAAA,CAAA8K,KAAA;cACA,MAAAsY,YAAA,GAAAtkB,aAAA,CACA,KAAAmD,KAAA,CAAA8K,KAAA,EACAC,IAAA,EACA,KAAAnK,UAAA,EACA,IACA;cACA,MAAAwgB,cAAA,GAAAvkB,aAAA,CACA,KAAAmD,KAAA,CAAA8K,KAAA,EACA,KAAAQ,IAAA,CAAA0R,CAAA,EAAAvS,UAAA,EACA,KAAA7J,UAAA,EACA,IACA;;cAEA;cACA,MAAAwgB,cAAA,CAAA1d,OAAA,WAAAmD,kBAAA;gBACA;gBACA,KAAAA,kBAAA,CAAAua,cAAA,CAAA1d,OAAA,UAAApB,GAAA;;gBAEA;gBACA,MAAA+e,oBAAA,QAAAC,wBAAA,CAAAtE,CAAA;gBACA,WAAA7L,CAAA,IAAAkQ,oBAAA;kBACA,MAAAE,aAAA,GAAA1kB,aAAA,CACA,KAAAmD,KAAA,CAAA8K,KAAA,EACA,IAAArH,IAAA,CAAA0N,CAAA,GACA,KAAAvQ,UAAA,EACA,IACA;kBACA,KAAAiG,kBAAA,CAAAua,cAAA,CAAA1d,OAAA,IAAA+I,GAAA,CACA8U,aAAA,CAAA7d,OAAA,EACA;gBACA;cACA;;cAEA;cACA,SAAA2B,QAAA,UAAAV,UAAA,CAAAC,GAAA;gBACA,KAAAiC,kBAAA,CAAAua,cAAA,CAAA1d,OAAA,IAAA+I,GAAA,CACA0U,YAAA,CAAAzd,OAAA,EACA;cACA,gBAAA2B,QAAA,UAAAV,UAAA,CAAAE,MAAA;gBACA,KAAAgC,kBAAA,CAAAua,cAAA,CAAA1d,OAAA,IAAAwd,MAAA,CACAC,YAAA,CAAAzd,OAAA,EACA;cACA;YACA;UACA;QACA;QACA,KAAArB,YAAA,OAAAC,GAAA,MAAAD,YAAA;MACA,gBAAAD,KAAA,UAAAT,MAAA,CAAAO,cAAA;QACA;QACA,MAAAa,GAAA,QAAAuC,SAAA,CAAAvC,GAAA;QACA,MAAAD,GAAA,QAAAwC,SAAA,CAAAxC,GAAA;QACA,MAAAyN,OAAA,QAAAhL,OAAA,CAAAzC,GAAA,QAAAwC,SAAA,CAAAxC,GAAA;QAEA,IAAAyN,OAAA;UACA,KAAA9K,iBAAA;YAAA1C,GAAA;YAAAD,GAAA;YAAAyN;UAAA;QACA;UACA,KAAA9K,iBAAA;QACA;MACA,gBAAArD,KAAA,UAAAT,MAAA,CAAAM,mBAAA;QACA;QACA,MAAA2K,QAAA,QAAAtH,SAAA,CAAAvC,GAAA;QACA,MAAA6G,WAAA,QAAAtE,SAAA,CAAAxC,GAAA;QACA,MAAAoS,WAAA,SAAA3P,OAAA,CAAAzC,GAAA,QAAAwC,SAAA,CAAAxC,GAAA;QACA,IAAAoS,WAAA;UACA,KAAAnR,sBAAA,CAAA6I,QAAA,EAAAvE,IAAA,CACA,KAAAmZ,iBAAA,CAAA5U,QAAA,EAAAhD,WAAA,EAAAsL,WAAA,CACA;QACA;MACA;;MAEA;MACA,KAAA9P,QAAA;MACA,KAAAE,SAAA;MACA,KAAAC,OAAA;IACA;IACAyP,YAAAlS,GAAA,EAAAC,GAAA;MACA;MACA,SAAAqC,QAAA;QACA,SAAApF,KAAA,CAAAqK,QAAA;UACA,IACA9N,SAAA,CAAAuG,GAAA,OAAAwC,SAAA,CAAAxC,GAAA,OAAAyC,OAAA,CAAAzC,GAAA,KACAvG,SAAA,CAAAuG,GAAA,OAAAyC,OAAA,CAAAzC,GAAA,OAAAwC,SAAA,CAAAxC,GAAA,GACA;YACA,SAAAyC,OAAA,CAAAzC,GAAA,QAAAwC,SAAA,CAAAxC,GAAA;cACA,OACA,KAAAyC,OAAA,CAAAzC,GAAA,KAAAA,GAAA,SAAAyC,OAAA,CAAAxC,GAAA,IAAAA,GAAA,IACA,KAAAuC,SAAA,CAAAxC,GAAA,KAAAA,GAAA,SAAAwC,SAAA,CAAAvC,GAAA,IAAAA,GAAA,IACA,KAAAuC,SAAA,CAAAxC,GAAA,KAAAA,GAAA,SAAAyC,OAAA,CAAAzC,GAAA,KAAAA,GAAA;YAEA,gBAAAyC,OAAA,CAAAzC,GAAA,QAAAwC,SAAA,CAAAxC,GAAA;cACA,OACA,KAAAyC,OAAA,CAAAzC,GAAA,KAAAA,GAAA,SAAAyC,OAAA,CAAAxC,GAAA,IAAAA,GAAA,IACA,KAAAuC,SAAA,CAAAxC,GAAA,KAAAA,GAAA,SAAAwC,SAAA,CAAAvC,GAAA,IAAAA,GAAA,IACA,KAAAuC,SAAA,CAAAxC,GAAA,KAAAA,GAAA,SAAAyC,OAAA,CAAAzC,GAAA,KAAAA,GAAA;YAEA;cACA;cACA,OACAvG,SAAA,CAAAwG,GAAA,OAAAuC,SAAA,CAAAvC,GAAA,OAAAwC,OAAA,CAAAxC,GAAA,KACAxG,SAAA,CAAAwG,GAAA,OAAAwC,OAAA,CAAAxC,GAAA,OAAAuC,SAAA,CAAAvC,GAAA;YAEA;UACA;UACA;QACA;QAEA,OACA,CAAAxG,SAAA,CAAAuG,GAAA,OAAAwC,SAAA,CAAAxC,GAAA,OAAAyC,OAAA,CAAAzC,GAAA,KACAvG,SAAA,CAAAuG,GAAA,OAAAyC,OAAA,CAAAzC,GAAA,OAAAwC,SAAA,CAAAxC,GAAA,OACAvG,SAAA,CAAAwG,GAAA,OAAAuC,SAAA,CAAAvC,GAAA,OAAAwC,OAAA,CAAAxC,GAAA,KACAxG,SAAA,CAAAwG,GAAA,OAAAwC,OAAA,CAAAxC,GAAA,OAAAuC,SAAA,CAAAvC,GAAA;MAEA;MACA;IACA;IACA0e,SAAAvL,CAAA;MACA,UAAA1O,SAAA;MACA,IAAA0O,CAAA,CAAA6J,OAAA,EAAA1W,MAAA;MACA,UAAA/D,SAAA;MAEA4Q,CAAA,CAAAwL,cAAA;MACA;QAAA5e,GAAA;QAAAC;MAAA,SAAAwd,eAAA,CACA,GAAArgB,MAAA,CAAAyP,MAAA,MAAAiQ,WAAA,CAAA1J,CAAA,EACA;MAEA,IACA,KAAA5M,qBAAA,IACAxG,GAAA,SAAAwC,SAAA,CAAAxC,GAAA,QAAAwG,qBAAA,EACA;QACAxG,GAAA,QAAAwC,SAAA,CAAAxC,GAAA,QAAAwG,qBAAA;MACA,gBAAAlH,KAAA,UAAAT,MAAA,CAAAO,cAAA;QACA,MAAA6T,YAAA,QAAAzQ,SAAA,CAAAxC,GAAA,QAAAwN,UAAA,IAAAjH,MAAA;QACA,IAAA0M,YAAA;UACAjT,GAAA,GAAA+G,IAAA,CAAAC,GAAA,CAAAhH,GAAA,OAAAwN,UAAA,IAAAjH,MAAA;QACA;MACA;MAEA,KAAA9D,OAAA;QAAAzC,GAAA;QAAAC;MAAA;IACA;IACA4e,UAAAzL,CAAA;MACA;QAAApT,GAAA;QAAAC;MAAA,SAAAwd,eAAA,CACA,GAAArgB,MAAA,CAAAyP,MAAA,MAAAiQ,WAAA,CAAA1J,CAAA,EACA;;MAEA;MACA,SAAAjP,QAAA;QACA,WAAA0C,KAAA,SAAA7F,iBAAA,CAAAf,GAAA,EAAA4Y,MAAA,CACA,KAAA5X,sBAAA,CAAAhB,GAAA,CACA;UACA,IACAxG,SAAA,CACAuG,GAAA,EACA6G,KAAA,CAAAC,WAAA,MACA,CAAAD,KAAA,CAAAC,WAAA,GAAAD,KAAA,CAAAuL,WAAA,SACA,GACA;YACA,KAAA0M,KAAA,CAAAC,gBAAA,CAAAC,mBAAA,CAAAnY,KAAA,CAAAV,GAAA;YACA;UACA;QACA;MACA;MAEA,UAAAzB,SAAA;MACA,IAAA0O,CAAA,CAAA6J,OAAA,EAAA1W,MAAA;;MAEA,MAAA0B,IAAA,QAAA+J,iBAAA,CAAAhS,GAAA,EAAAC,GAAA;MACA,KAAAgI,IAAA;;MAEA;MACA,SAAA/K,KAAA,CAAAqK,QAAA,UAAAoE,gBAAA,CAAA1R,GAAA,CAAAgO,IAAA,CAAArH,OAAA;QACA;MACA;MAEA,KAAA0B,QAAA;MACA,KAAAE,SAAA;QAAAxC,GAAA;QAAAC;MAAA;MACA,KAAAwC,OAAA;QAAAzC,GAAA;QAAAC;MAAA;;MAEA;MACAmT,CAAA,CAAAwL,cAAA;;MAEA;MACA,SAAAza,QAAA;QACA,KAAA5B,QAAA,QAAAV,UAAA,CAAAC,GAAA;MACA,WACA,KAAAxC,KAAA,UAAAT,MAAA,CAAAQ,kBAAA,IACA,KAAAK,SAAA,CAAAoI,GAAA,CAAAG,IAAA,CAAArH,OAAA,OACA,KAAAS,gBAAA,KAAAtG,iBAAA,CAAAuG,SAAA,IACA,KAAA/B,YAAA,CAAAuI,GAAA,CAAAG,IAAA,CAAArH,OAAA,OACA,KAAAS,gBAAA,KAAAtG,iBAAA,CAAA+V,SAAA,IACA,KAAArR,QAAA,CAAAqI,GAAA,CAAAG,IAAA,CAAArH,OAAA,KACA;QACA,KAAA2B,QAAA,QAAAV,UAAA,CAAAE,MAAA;MACA;QACA,KAAAQ,QAAA,QAAAV,UAAA,CAAAC,GAAA;MACA;IACA;IACA;;IAEA;IACA;IACA;IACAmd,iBAAA;MACA,MAAAC,KAAA,OAAAve,IAAA,MAAAzD,KAAA,CAAA8K,KAAA,KACAmX,kBAAA;QAAAC,YAAA;MAAA,GACAF,KAAA;MACA,MAAAG,aAAA,GAAAH,KAAA,CAAAA,KAAA,CAAA3Y,MAAA;MAEA,OAAA8Y,aAAA;IACA;IACAC,sBAAA;MACAne,YAAA,yBAAAQ,aAAA;MACA,IACA,KAAArC,KAAA,SAAAT,MAAA,CAAAI,UAAA,IACA,KAAAK,KAAA,SAAAT,MAAA,CAAAC,OAAA,EAEA,KAAAQ,KAAA,QAAA4M,YAAA;IACA;IACAqT,sBAAA;MACA,KAAAre,eAAA,SAAAA,eAAA;MACAC,YAAA,2BAAAD,eAAA;IACA;IACAse,uBAAA;MACA,KAAA9d,gBAAA,SAAAA,gBAAA;MACAP,YAAA,4BAAAO,gBAAA;IACA;IACA+d,0BAAAC,GAAA;MACA,KAAAne,mBAAA,KAAAme,GAAA;MACA,KAAAtH,QAAA,EAAAC,OAAA;QACApT,OAAA,IAAAya;MACA;IACA;IACA;;IAEA;IACA;IACA;IACAC,iBAAAvM,CAAA;MACA,KAAA/P,iBAAA,GAAA+P,CAAA,CAAAK,MAAA,CAAAmM,WAAA,GAAAxM,CAAA,CAAAK,MAAA,CAAAoM,WAAA;MACA,KAAAzc,kBAAA,GAAAgQ,CAAA,CAAAK,MAAA,CAAAqM,UAAA;IACA;IACAC,SAAA3M,CAAA;MACA,KAAA4M,oBAAA;IACA;IACA;IACAA,qBAAA;MACA,MAAAC,gBAAA,QAAAnB,KAAA,CAAAoB,cAAA;MACA,IAAAD,gBAAA;QACA,KAAA9c,cAAA,GAAA7I,mBAAA,CAAA2lB,gBAAA;UACAE,YAAA;QACA;MACA;MAEA,MAAAC,iBAAA,QAAAtB,KAAA,CAAAuB,eAAA,EAAAC,GAAA;MACA,IAAAF,iBAAA;QACA,KAAA9c,qBAAA,GAAAhJ,mBAAA,CAAA8lB,iBAAA;UACAD,YAAA;QACA;MACA;IACA;IACA;;IAEA;IACA;IACA;IACAI,SAAAnN,CAAA;MACAA,CAAA,CAAAoN,wBAAA;MACA,SAAAtjB,KAAA,CAAAC,IAAA,KAAAlC,UAAA,CAAA8K,KAAA;QACA;QACA;QACA,UAAAtC,IAAA,aAAAiH,cAAA,QAAAjD,OAAA,CAAAlB,MAAA;UACA,KAAA9C,IAAA;QACA;UACA,KAAAA,IAAA;UACA,KAAAoY,KAAA,2BAAA/d,UAAA;QACA;MACA;QACA,KAAA2F,IAAA;MACA;MACA,KAAAG,cAAA;IACA;IACA6c,SAAArN,CAAA;MACAA,CAAA,CAAAoN,wBAAA;MACA,SAAAtjB,KAAA,CAAAC,IAAA,KAAAlC,UAAA,CAAA8K,KAAA;QACA;QACA;QACA,SAAAtC,IAAA;UACA,KAAAA,IAAA;QACA;UACA,KAAAA,IAAA,GAAAsD,IAAA,CAAAuJ,IAAA,MAAA7I,OAAA,CAAAlB,MAAA,QAAAmE,cAAA;UACA,KAAAmR,KAAA,2BAAA/d,UAAA;QACA;MACA;QACA,KAAA2F,IAAA;MACA;MACA,KAAAG,cAAA;IACA;IACA;;IAEA;IACA;IACA;IACA8c,SAAA;MACA,KAAArH,eAAA;IACA;IACA;;IAEA;IACA;IACA;IACAsH,UAAA;MACA,KAAA7c,SAAA;MACA3C,YAAA,MAAA6P,wBAAA;IACA;IACA;;IAEA;IACA;IACA;;IAEA;IACA4P,sBAAA3I,OAAA;MACA,KAAA3X,sBAAA,CACA5F,qBAAA,CAAAud,OAAA,CAAAD,KAAA,EAAAC,OAAA,CAAA4I,YAAA,EACA,CAAA5b,OAAA,GAAAgT,OAAA,CAAAhT,OAAA;MACA,KAAA3E,sBAAA,GAAAoF,IAAA,CAAAC,KAAA,CACAD,IAAA,CAAAE,SAAA,MAAAtF,sBAAA,CACA;IACA;IAEA;IACAwgB,yBAAA7I,OAAA;MACA,KAAA3X,sBAAA,CACA5F,qBAAA,CAAAud,OAAA,CAAAD,KAAA,EAAAC,OAAA,CAAA4I,YAAA,EACA,CAAAxb,YAAA,CAAA4S,OAAA,CAAA8I,aAAA,EAAA9b,OAAA,GAAAgT,OAAA,CAAAhT,OAAA;MACA,KAAA3E,sBAAA,GAAAoF,IAAA,CAAAC,KAAA,CACAD,IAAA,CAAAE,SAAA,MAAAtF,sBAAA,CACA;IACA;IAEA;IACAsV,2BAAA;MACA,UAAAhR,QAAA;;MAEA;MACA,KAAAtE,sBAAA,GAAAoF,IAAA,CAAAC,KAAA,CACAD,IAAA,CAAAE,SAAA,MAAAhB,QAAA,CAAAE,gBAAA,CACA;;MAEA;MACA,WAAAE,EAAA,SAAA1E,sBAAA;QACA,KAAAA,sBAAA,CAAA0E,EAAA,EAAAC,OAAA;QACA,SAAA3E,sBAAA,CAAA0E,EAAA,EAAAK,YAAA;UACA,WAAA0b,aAAA,SAAAzgB,sBAAA,CAAA0E,EAAA,EACAK,YAAA;YACA,KAAA/E,sBAAA,CAAA0E,EAAA,EAAAK,YAAA,CACA0b,aAAA,CACA,CAAA9b,OAAA;UACA;QACA;MACA;;MAEA;MACA,SAAAL,QAAA,CAAAuB,GAAA,SAAAjJ,KAAA,CAAAgJ,SAAA;QACA,MAAA8a,gBAAA,GACA,KAAA9jB,KAAA,CAAAgJ,SAAA,MAAAtB,QAAA,CAAAuB,GAAA,EAAA6a,gBAAA;QAEA,WAAAhc,EAAA,IAAAgc,gBAAA;UACA,KAAA1gB,sBAAA,CAAA0E,EAAA,EAAAC,OAAA;UAEA+b,gBAAA,CAAAhc,EAAA,EAAA6M,OAAA,CAAAkP,aAAA;YACA,KAAAzgB,sBAAA,CAAA0E,EAAA,EAAAK,YAAA,CACA0b,aAAA,CACA,CAAA9b,OAAA;UACA;QACA;MACA;IACA;IAEA;IACAgc,UAAAhZ,IAAA,EAAA1I,YAAA,YAAAA,YAAA;MACA,MAAAkd,KAAA,OAAA9b,IAAA,CAAAsH,IAAA;MACA,MAAAyU,GAAA,OAAA/b,IAAA,CAAAsH,IAAA;MACAyU,GAAA,CAAAzH,QAAA,CAAAyH,GAAA,CAAAxH,QAAA,UAAAhY,KAAA,CAAA+M,QAAA;MAEA,WAAAoE,CAAA,IAAA9O,YAAA;QACA,MAAA2hB,aAAA,OAAAvgB,IAAA,CAAA0N,CAAA,EAAAzN,OAAA;QACA,IACA6b,KAAA,CAAA7b,OAAA,MAAAsgB,aAAA,IACAA,aAAA,IAAAxE,GAAA,CAAA9b,OAAA,IACA;UACA;QACA;MACA;MAEA;IACA;IAEA;IACA4d,yBAAA2C,MAAA,EAAA5hB,YAAA,YAAAA,YAAA;MACA,MAAA6hB,MAAA,OAAA5hB,GAAA;MACA,MAAA6hB,eAAA,OAAA7hB,GAAA,CAAAD,YAAA;MACA,KACA,IAAAsI,CAAA,MACAA,CAAA,QAAA2F,UAAA,IAAAjH,MAAA,QAAAiH,UAAA,IAAAjH,MAAA,EACA,EAAAsB,CAAA,EACA;QACA,MAAAI,IAAA,QAAA+J,iBAAA,CAAAnK,CAAA,EAAAsZ,MAAA;QACA,KAAAlZ,IAAA;QAEA,IAAAoZ,eAAA,CAAAvZ,GAAA,CAAAG,IAAA,CAAArH,OAAA;UACAwgB,MAAA,CAAAzX,GAAA,CAAA1B,IAAA,CAAArH,OAAA;QACA;MACA;MAEA,OAAAwgB,MAAA;IACA;IAEA;IACAtT,yBAAA/J,kBAAA,QAAAA,kBAAA;MACA,KAAAA,kBAAA;MAEA,MAAAud,qBAAA;MACA,WAAApZ,IAAA,IAAAnE,kBAAA;QACA,MAAAwd,OAAA,GAAAxnB,aAAA,CACA,KAAAmD,KAAA,CAAA8K,KAAA,EACA,IAAArH,IAAA,CAAAgD,QAAA,CAAAuE,IAAA,IACA,KAAApK,UACA,EAAA8C,OAAA;QACA0gB,qBAAA,CAAAC,OAAA,QAAAxd,kBAAA,CAAAmE,IAAA,GAAA3D,GAAA,CACA8J,CAAA,IAAAtU,aAAA,MAAAmD,KAAA,CAAA8K,KAAA,MAAArH,IAAA,CAAA0N,CAAA,QAAAvQ,UAAA,CACA;MACA;MACA,OAAAwjB,qBAAA;IACA;IACA;;IAEA;IACA;IACA;;IAEA;IACA5C,kBAAA5U,QAAA,EAAAhD,WAAA,EAAAsL,WAAA;MACA,MAAA4D,SAAA,GAAAlc,YAAA,CACA,KAAA0O,IAAA,CAAAsB,QAAA,EAAAnC,UAAA,EACAb,WAAA,EACAsL,WACA;MAEA;QACAjM,GAAA,EAAA3J,QAAA,GAAAke,QAAA;QACA3B,QAAA;QACA/b,IAAA,OAAAqJ,kBAAA;QACA,GAAA2P,SAAA;QACAlP,WAAA;QACAsL;MACA;IACA;IAEA;IACAoP,gBAAAC,WAAA;MACA,KAAAzgB,iBAAA,CAAA6Q,OAAA,EAAA6P,WAAA,EAAA5X,QAAA;QACA4X,WAAA,CAAA7P,OAAA,EAAAhL,KAAA,EAAA8a,UAAA;UACA,IAAAF,WAAA,CAAAtb,GAAA,KAAAU,KAAA,CAAAV,GAAA;YACA,KAAAnF,iBAAA,CAAA8I,QAAA,EAAA6X,UAAA,IAAAF,WAAA;YACA,KAAAzgB,iBAAA,YAAAA,iBAAA;YACA;UACA;QACA;MACA;MAEA,KAAAC,sBAAA,CAAA4Q,OAAA,EAAA6P,WAAA,EAAA5X,QAAA;QACA4X,WAAA,CAAA7P,OAAA,EAAAhL,KAAA,EAAA8a,UAAA;UACA,IAAAF,WAAA,CAAAtb,GAAA,KAAAU,KAAA,CAAAV,GAAA;YACA,KAAAlF,sBAAA,CAAA6I,QAAA,EAAA6X,UAAA,IAAAF,WAAA;YACA,KAAAxgB,sBAAA,YAAAA,sBAAA;YACA;UACA;QACA;MACA;IACA;IAEA;IACA2gB,kBAAAC,aAAA;MACA,KAAA7gB,iBAAA,CAAA6Q,OAAA,EAAA6P,WAAA,EAAA5X,QAAA;QACA4X,WAAA,CAAA7P,OAAA,EAAAhL,KAAA,EAAA8a,UAAA;UACA,IAAAE,aAAA,KAAAhb,KAAA,CAAAV,GAAA;YACA,KAAAnF,iBAAA,CAAA8I,QAAA,EAAAS,MAAA,CAAAoX,UAAA;YACA;UACA;QACA;MACA;MAEA,KAAA1gB,sBAAA,CAAA4Q,OAAA,EAAA6P,WAAA,EAAA5X,QAAA;QACA4X,WAAA,CAAA7P,OAAA,EAAAhL,KAAA,EAAA8a,UAAA;UACA,IAAAE,aAAA,KAAAhb,KAAA,CAAAV,GAAA;YACA,KAAAlF,sBAAA,CAAA6I,QAAA,EAAAS,MAAA,CAAAoX,UAAA;YACA;UACA;QACA;MACA;IACA;IAEA;IACAG,gBAAA;MACA;MACA,KAAA9gB,iBAAA,GAAAnH,oBAAA,CACA,KAAAqD,KAAA,EACA,KAAAA,KAAA,CAAA4b,YAAA,MACA;MAEA,KAAAiJ,2BAAA;;MAEA;MACA,WAAA9b,MAAA,SAAA/I,KAAA,CAAA8kB,eAAA;QACA,MAAAC,cAAA,QAAA/kB,KAAA,CAAA8kB,eAAA,CAAA/b,MAAA;QACA,WAAA4b,aAAA,IAAAI,cAAA,CAAAC,cAAA;UACA,MAAAT,WAAA,QAAAzgB,iBAAA,CACAsF,IAAA,GACA6b,IAAA,CAAAV,WAAA,IAAAA,WAAA,CAAAtb,GAAA,KAAA0b,aAAA;UAEA,KAAAJ,WAAA,CAAAvb,SAAA,EAAAub,WAAA,CAAAvb,SAAA;UACAub,WAAA,CAAAvb,SAAA,CAAAX,IAAA,CAAA0c,cAAA;QACA;MACA;IACA;IAEA;IACAF,4BAAA;MACA,KAAA9gB,sBAAA;MACA,WAAAuG,GAAA,SAAAxG,iBAAA;QACA,KAAAC,sBAAA,CAAAsE,IAAA;MACA;IACA;IAEA;IACA6c,uBAAAvb,KAAA;MACA,UAAAI,4BAAA,UAAAqF,OAAA,EACA,KAAAuP,KAAA,mBAAAhV,KAAA;IACA;IAEA;;IAEA;IACA;IACA;;IAEA;IACAwb,cAAA;MACA;MACA,KAAAnlB,KAAA,CAAAiL,KAAA,YAAAzI,SAAA,EACA6E,GAAA,CAAAqK,CAAA,QAAAjO,IAAA,CAAAiO,CAAA,GACA0T,IAAA,EAAAjU,CAAA,EAAAkU,CAAA,KAAAlU,CAAA,CAAAzN,OAAA,KAAA2hB,CAAA,CAAA3hB,OAAA;MAEA;QAAA4hB,QAAA;QAAAC;MAAA,SAAAC,uBAAA,CACA,KAAAxlB,KAAA,CAAAiL,KACA;;MAEA;MACA,SAAAJ,CAAA,MAAAA,CAAA,QAAA7K,KAAA,CAAA8K,KAAA,CAAAzB,MAAA,IAAAwB,CAAA;QACA,MAAAE,IAAA,OAAAtH,IAAA,MAAAzD,KAAA,CAAA8K,KAAA,CAAAD,CAAA;QACAE,IAAA,CAAAc,OAAA,CAAAd,IAAA,CAAArH,OAAA,UAAAiF,cAAA;QACAoC,IAAA,CAAAyB,WAAA,CAAA8Y,QAAA;QACAva,IAAA,CAAAc,OAAA,CAAAd,IAAA,CAAArH,OAAA,UAAAiF,cAAA;QACA,KAAA3I,KAAA,CAAA8K,KAAA,CAAAD,CAAA,IAAAE,IAAA,CAAAmM,WAAA;MACA;;MAEA;MACA,KAAAlX,KAAA,CAAA+M,QAAA,GAAAwY,QAAA,GAAAD,QAAA;;MAEA;MACAhpB,GAAA,iBAAA0D,KAAA,CAAAiJ,GAAA,SAAAjJ,KAAA,EACAmX,IAAA;QACA,KAAA/U,KAAA,QAAA4M,YAAA;MACA,GACAqI,KAAA,CAAAC,GAAA;QACA,KAAAC,SAAA,CAAAD,GAAA;MACA;IACA;IAEA;IACAkO,wBAAAva,KAAA;MACA,IAAAqa,QAAA;MACA,IAAAC,QAAA;MACA,WAAAva,IAAA,IAAAC,KAAA;QACA,MAAAwa,QAAA,OAAAhiB,IAAA,CAAAuH,IAAA;QACA,MAAAD,IAAA,OAAAtH,IAAA,CACAgiB,QAAA,CAAA/hB,OAAA,UAAAiF,cAAA,YACA;QACA,MAAA+c,UAAA,GAAA3a,IAAA,CAAAkC,WAAA;QACA,IAAAyY,UAAA,GAAAJ,QAAA;UACAA,QAAA,GAAAI,UAAA;QACA,WAAAA,UAAA,GAAAH,QAAA;UACAA,QAAA,GAAAG,UAAA;QACA;MACA;MACA;QAAAJ,QAAA;QAAAC;MAAA;IACA;IAEA;;IAEA;IACAI,sBAAA;MACA,IACA,KAAAvjB,KAAA,UAAAT,MAAA,CAAAK,iBAAA,IACA,KAAA0F,QAAA,IACA,OAAAA,QAAA,EAAAuB,GAAA,SAAAjJ,KAAA,CAAAgJ,SAAA;MAAA;MACA,MAAAzI,qBAAA,KACA,MAAAqC,cAAA,SAAAF,uBAAA,GACA;QACA,WAAA6X,OAAA,SAAA9X,wBAAA;UACAkY,YAAA,CAAAJ,OAAA;QACA;QACA,KAAAP,4BAAA;MACA;IACA;EACA;EACA4L,KAAA;IACAvjB,aAAA;MACA,SAAAD,KAAA,UAAAT,MAAA,CAAAK,iBAAA;QACA,KAAAY,cAAA;MACA;IACA;IACA5C,KAAA;MACA6lB,SAAA;MACAC,QAAA;QACA,KAAApN,0BAAA;QACA,KAAA5B,cAAA;MACA;IACA;IACA1U,MAAA2jB,SAAA,EAAAC,SAAA;MACA,KAAApN,SAAA,YAAAkK,oBAAA;;MAEA;MACA,IAAAkD,SAAA,UAAArkB,MAAA,CAAAO,cAAA;QACA,KAAAuD,iBAAA;MACA,WAAAugB,SAAA,UAAArkB,MAAA,CAAAK,iBAAA;QACA,KAAAY,cAAA;MACA;MAEA,IAAAmjB,SAAA,UAAApkB,MAAA,CAAAQ,kBAAA;QACA,KAAAyW,SAAA;UACA,MAAAqN,KAAA,GAAA5J,QAAA,CAAA6J,cAAA;UACA,IAAAD,KAAA;YACA,MAAAE,OAAA;YACA,MAAAhG,CAAA,GACA8F,KAAA,CAAA1J,qBAAA,GAAAnM,GAAA,GAAAsP,MAAA,CAAAU,OAAA,GAAA+F,OAAA;YACAzG,MAAA,CAAA0G,QAAA;cAAAhW,GAAA,EAAA+P,CAAA;cAAAkG,QAAA;YAAA;UACA;QACA;MACA;IACA;IACA3W,WAAA;MACAmW,SAAA;MACAC,QAAA;QACA,KAAA7iB,uBAAA;QACA,WAAAsV,UAAA,SAAA7I,WAAA;UACA,KAAAzM,uBAAA,CAAAsV,UAAA,CAAAtP,GAAA;QACA;MACA;IACA;IACAxB,oBAAA+a,GAAA,EAAA8D,MAAA;MACA,IAAA9d,IAAA,CAAAE,SAAA,CAAA8Z,GAAA,MAAAha,IAAA,CAAAE,SAAA,CAAA4d,MAAA;QACA,KAAAX,qBAAA;MACA;IACA;IACApf,KAAA;MACA,KAAAqS,SAAA;QACA,KAAAuD,eAAA;MACA;IACA;IACA5R,QAAA;MACA,KAAAqO,SAAA;QACA,KAAAuD,eAAA;MACA;IACA;IACA1I,qBAAA;MACAoS,SAAA;MACAC,QAAAS,GAAA;QACA5L,YAAA,MAAArU,mCAAA;QACA,KAAAA,mCAAA,GAAAkU,UAAA;UACA,KAAAnU,4BAAA,GAAAkgB,GAAA;QACA;MACA;IACA;IACA/Y,eAAA;MACA;MACA;MACA,SAAAjH,IAAA,QAAAiH,cAAA,SAAAjD,OAAA,CAAAlB,MAAA;QACA,KAAA9C,IAAA;MACA;IACA;IACAC,cAAA;MACA;MACAvC,YAAA,yBAAAuC,aAAA;;MAEA;MACA,KAAAoS,SAAA;QACA,KAAAuD,eAAA;MACA;IACA;IACAvb,WAAA;MACA,SAAAZ,KAAA,CAAAC,IAAA,KAAAlC,UAAA,CAAA8K,KAAA;QACA,KAAAiO,cAAA;MACA;IACA;IACApS,aAAA;MACA,KAAA0S,qBAAA;IACA;IACAxH,gBAAA;MACA;MACA,KAAAwH,qBAAA;;MAEA;MACA,IACA,KAAApX,KAAA,CAAAC,IAAA,KAAAlC,UAAA,CAAA8K,KAAA,IACA,KAAAzG,KAAA,UAAAT,MAAA,CAAAK,iBAAA,IACA,KAAA0F,QAAA,EACA;QACA,KAAArF,YAAA,OAAAC,GAAA;QACA,KAAAqW,wBAAA,MAAAjR,QAAA,CAAAuB,GAAA;MACA;IACA;IACAxE,cAAA;MACA,KAAA2d,qBAAA;IACA;IACAtc,sBAAA;MACA7B,YAAA,iCAAA6B,qBAAA;IACA;IACAxB,WAAAiiB,GAAA,EAAAC,IAAA;MACA,IAAAD,GAAA,CAAAxe,OAAA,KAAAye,IAAA,CAAAze,OAAA,IAAAwe,GAAA,CAAAxe,OAAA;QACA,KAAA4d,qBAAA;MACA;IACA;IACAphB,aAAAgiB,GAAA,EAAAC,IAAA;MACA,IAAAD,GAAA,CAAAxe,OAAA,KAAAye,IAAA,CAAAze,OAAA,IAAAwe,GAAA,CAAAxe,OAAA;QACA,KAAA4d,qBAAA;MACA;IACA;IACAjgB,SAAA;MACAzB,YAAA,oBAAAyB,QAAA;IACA;IACAtF,cAAA;MACA,SAAAA,aAAA,SAAAwL,eAAA;QACA,KAAApJ,SAAA,OAAAF,GAAA,CACA,KAAAtC,KAAA,CAAAiL,KAAA,CAAA5D,GAAA,CAAAqK,CAAA,QAAAjO,IAAA,CAAAiO,CAAA,EAAAhO,OAAA,GACA;QACA,KAAAtB,KAAA,QAAAT,MAAA,CAAAQ,kBAAA;MACA;IACA;EACA;EACAskB,QAAA;IACA,KAAAhO,wBAAA;IAEAiO,gBAAA,eAAApQ,mBAAA;EACA;EACAqQ,QAAA;IACA;IACA,MAAAC,SAAA,OAAAC,eAAA,CAAAnH,MAAA,CAAAD,QAAA,CAAAqH,MAAA;;IAEA;IACA,IACA,KAAA9mB,KAAA,CAAAyP,gBAAA,KACA,KAAArP,aAAA,UAAAJ,KAAA,CAAAiL,KAAA,SAAAjL,KAAA,CAAAiL,KAAA,CAAA5B,MAAA,SACA;MACA,KAAAjH,KAAA,QAAAT,MAAA,CAAAQ,kBAAA;IACA,WAAAykB,SAAA,CAAA7pB,GAAA;MACA,MAAAgqB,cAAA,GAAAve,IAAA,CAAAC,KAAA,CAAAme,SAAA,CAAA7pB,GAAA;MACA,KAAA0I,iBAAA,GAAAshB,cAAA;MACA,KAAA3kB,KAAA,QAAAT,MAAA,CAAAO,cAAA;;MAEA;MACA,MAAA8kB,MAAA,OAAAC,GAAA,CAAAvH,MAAA,CAAAD,QAAA,CAAAyH,IAAA;MACAF,MAAA,CAAAG,YAAA,CAAAjG,MAAA;MACAxB,MAAA,CAAA0H,OAAA,CAAAC,YAAA,KAAAhL,QAAA,CAAAiL,KAAA,EAAAN,MAAA,CAAAxJ,QAAA;IACA,gBAAA/Y,aAAA;MACA,KAAArC,KAAA;IACA;MACA,KAAAA,KAAA;IACA;;IAEA;IACA,SAAAsF,QAAA;MACA,KAAApD,UAAA,GACA,KAAAoD,QAAA,EAAAsJ,eAAA,EAAA1M,UAAA,IACAxG,uBAAA,CAAAwG,UAAA;MACA,KAAAC,YAAA,GACA,KAAAmD,QAAA,EAAAsJ,eAAA,EAAAzM,YAAA,IACAzG,uBAAA,CAAAyG,YAAA;MACA,SAAAsD,OAAA;QACA,SAAA7H,KAAA,CAAAgJ,SAAA,MAAAtB,QAAA,CAAAuB,GAAA,GAAA+H,eAAA;UACA;UACA;YAAA1M,UAAA;YAAAC;UAAA,IACA,KAAAvE,KAAA,CAAAgJ,SAAA,MAAAtB,QAAA,CAAAuB,GAAA,GAAA+H,eAAA;UACA,IAAA1M,UAAA,OAAAA,UAAA,GAAAA,UAAA;UACA,IAAAC,YAAA,OAAAA,YAAA,GAAAA,YAAA;QACA;UACA,KAAAD,UAAA,GAAAxG,uBAAA,CAAAwG,UAAA;UACA,KAAAC,YAAA,GAAAzG,uBAAA,CAAAyG,YAAA;QACA;MACA;IACA;;IAEA;IACA;IACA;;IAEA;IACA,KAAA4X,eAAA;IACAuK,gBAAA,gBAAAlD,QAAA;IACAkD,gBAAA,gBAAA7D,QAAA;IACA,UAAA7hB,YAAA;MACA,MAAAumB,OAAA,GAAAlL,QAAA,CAAA6J,cAAA;MACA,IAAA/oB,cAAA;QACAoqB,OAAA,CAAAb,gBAAA,oBAAA/E,SAAA;QACA4F,OAAA,CAAAb,gBAAA,mBAAAjF,QAAA;QACA8F,OAAA,CAAAb,gBAAA,kBAAAlI,OAAA;QACA+I,OAAA,CAAAb,gBAAA,qBAAAlI,OAAA;MACA;MACA+I,OAAA,CAAAb,gBAAA,mBAAA/E,SAAA;MACA4F,OAAA,CAAAb,gBAAA,mBAAAjF,QAAA;MACA8F,OAAA,CAAAb,gBAAA,iBAAAlI,OAAA;IACA;;IAEA;IACA,KAAAoG,eAAA;EACA;EACA4C,cAAA;IACAC,mBAAA,eAAAnR,mBAAA;IACAmR,mBAAA,gBAAAjE,QAAA;IACAiE,mBAAA,gBAAA5E,QAAA;EACA;EACA6E,UAAA;IACAvoB,SAAA;IACAM,sBAAA;IACAR,iBAAA;IACAS,gBAAA;IACApB,iBAAA;IACAM,MAAA;IACAC,oBAAA;IACAC,OAAA;IACAP,gBAAA;IACAQ,eAAA;IACAP,aAAA;IACAQ,gBAAA;IACAE,kBAAA;IACAT,WAAA;IACAC,mBAAA;IACAC,gBAAA;IACAgB,kBAAA;IAAA;IACAC,yBAAA;IAAA;IACAR;EACA;AACA"},"metadata":{},"sourceType":"module","externalDependencies":[]}